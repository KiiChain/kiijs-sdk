/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

/**
 * State defines if a connection is in one of the following states:
 * INIT, TRYOPEN, OPEN or UNINITIALIZED.
 *
 *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
 *  - STATE_INIT: A connection end has just started the opening handshake.
 *  - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty
 * chain.
 *  - STATE_OPEN: A connection end has completed the handshake.
 * @default "STATE_UNINITIALIZED_UNSPECIFIED"
 */
export enum IbcCoreConnectionV1State {
  STATE_UNINITIALIZED_UNSPECIFIED = "STATE_UNINITIALIZED_UNSPECIFIED",
  STATE_INIT = "STATE_INIT",
  STATE_TRYOPEN = "STATE_TRYOPEN",
  STATE_OPEN = "STATE_OPEN",
}

/**
 * State defines if a channel is in one of the following states:
 * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
 *
 *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
 *  - STATE_INIT: A channel has just started the opening handshake.
 *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
 *  - STATE_OPEN: A channel has completed the handshake. Open channels are
 * ready to send and receive packets.
 *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
 * packets.
 *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
 *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
 * @default "STATE_UNINITIALIZED_UNSPECIFIED"
 */
export enum IbcCoreChannelV1State {
  STATE_UNINITIALIZED_UNSPECIFIED = "STATE_UNINITIALIZED_UNSPECIFIED",
  STATE_INIT = "STATE_INIT",
  STATE_TRYOPEN = "STATE_TRYOPEN",
  STATE_OPEN = "STATE_OPEN",
  STATE_CLOSED = "STATE_CLOSED",
  STATE_FLUSHING = "STATE_FLUSHING",
  STATE_FLUSHCOMPLETE = "STATE_FLUSHCOMPLETE",
}

/**
 * Order defines if a channel is ORDERED or UNORDERED
 * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
 *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
 * which they were sent.
 *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
 * @default "ORDER_NONE_UNSPECIFIED"
 */
export enum IbcCoreChannelV1Order {
  ORDER_NONE_UNSPECIFIED = "ORDER_NONE_UNSPECIFIED",
  ORDER_UNORDERED = "ORDER_UNORDERED",
  ORDER_ORDERED = "ORDER_ORDERED",
}

/**
 * OrderBy defines the sorting order
 * - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults
 * to ASC in this case.
 *  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
 *  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
 * @default "ORDER_BY_UNSPECIFIED"
 */
export enum CosmosTxV1Beta1OrderBy {
  ORDER_BY_UNSPECIFIED = "ORDER_BY_UNSPECIFIED",
  ORDER_BY_ASC = "ORDER_BY_ASC",
  ORDER_BY_DESC = "ORDER_BY_DESC",
}

/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
 * method.
 *
 *  - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
 *  - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
 * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
 *  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
 * for a CheckTx execution response only.
 *  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
 * returns immediately.
 * @default "BROADCAST_MODE_UNSPECIFIED"
 */
export enum CosmosTxV1Beta1BroadcastMode {
  BROADCAST_MODE_UNSPECIFIED = "BROADCAST_MODE_UNSPECIFIED",
  BROADCAST_MODE_BLOCK = "BROADCAST_MODE_BLOCK",
  BROADCAST_MODE_SYNC = "BROADCAST_MODE_SYNC",
  BROADCAST_MODE_ASYNC = "BROADCAST_MODE_ASYNC",
}

/**
 * SignMode represents a signing mode with its own security guarantees.
 *
 * This enum should be considered a registry of all known sign modes
 * in the Cosmos ecosystem. Apps are not expected to support all known
 * sign modes. Apps that would like to support custom  sign modes are
 * encouraged to open a small PR against this file to add a new case
 * to this SignMode enum describing their sign mode so that different
 * apps have a consistent version of this enum.
 *
 *  - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
 * rejected.
 *  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
 * verified with raw bytes from Tx.
 *  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
 * human-readable textual representation on top of the binary representation
 * from SIGN_MODE_DIRECT.
 *
 * Since: cosmos-sdk 0.50
 *  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
 * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
 * require signers signing over other signers' `signer_info`.
 *
 * Since: cosmos-sdk 0.46
 *  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
 * Amino JSON and will be removed in the future.
 *  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
 * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
 *
 * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
 * but is not implemented on the SDK by default. To enable EIP-191, you need
 * to pass a custom `TxConfig` that has an implementation of
 * `SignModeHandler` for EIP-191. The SDK may decide to fully support
 * EIP-191 in the future.
 *
 * Since: cosmos-sdk 0.45.2
 * @default "SIGN_MODE_UNSPECIFIED"
 */
export enum CosmosTxSigningV1Beta1SignMode {
  SIGN_MODE_UNSPECIFIED = "SIGN_MODE_UNSPECIFIED",
  SIGN_MODE_DIRECT = "SIGN_MODE_DIRECT",
  SIGN_MODE_TEXTUAL = "SIGN_MODE_TEXTUAL",
  SIGN_MODE_DIRECT_AUX = "SIGN_MODE_DIRECT_AUX",
  SIGN_MODE_LEGACY_AMINO_JSON = "SIGN_MODE_LEGACY_AMINO_JSON",
  SIGN_MODE_EIP_191 = "SIGN_MODE_EIP_191",
}

/**
 * VoteOption enumerates the valid vote options for a given governance proposal.
 *
 *  - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 *  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 *  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 *  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 *  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @default "VOTE_OPTION_UNSPECIFIED"
 */
export enum CosmosGovV1VoteOption {
  VOTE_OPTION_UNSPECIFIED = "VOTE_OPTION_UNSPECIFIED",
  VOTE_OPTION_YES = "VOTE_OPTION_YES",
  VOTE_OPTION_ABSTAIN = "VOTE_OPTION_ABSTAIN",
  VOTE_OPTION_NO = "VOTE_OPTION_NO",
  VOTE_OPTION_NO_WITH_VETO = "VOTE_OPTION_NO_WITH_VETO",
}

/**
 * ProposalStatus enumerates the valid statuses of a proposal.
 *
 *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
 *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
 * period.
 *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
 * period.
 *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
 * passed.
 *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
 * been rejected.
 *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
 * failed.
 * @default "PROPOSAL_STATUS_UNSPECIFIED"
 */
export enum CosmosGovV1ProposalStatus {
  PROPOSAL_STATUS_UNSPECIFIED = "PROPOSAL_STATUS_UNSPECIFIED",
  PROPOSAL_STATUS_DEPOSIT_PERIOD = "PROPOSAL_STATUS_DEPOSIT_PERIOD",
  PROPOSAL_STATUS_VOTING_PERIOD = "PROPOSAL_STATUS_VOTING_PERIOD",
  PROPOSAL_STATUS_PASSED = "PROPOSAL_STATUS_PASSED",
  PROPOSAL_STATUS_REJECTED = "PROPOSAL_STATUS_REJECTED",
  PROPOSAL_STATUS_FAILED = "PROPOSAL_STATUS_FAILED",
}

/**
 * VoteOption enumerates the valid vote options for a given governance proposal.
 *
 *  - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 *  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 *  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 *  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 *  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @default "VOTE_OPTION_UNSPECIFIED"
 */
export enum CosmosGovV1Beta1VoteOption {
  VOTE_OPTION_UNSPECIFIED = "VOTE_OPTION_UNSPECIFIED",
  VOTE_OPTION_YES = "VOTE_OPTION_YES",
  VOTE_OPTION_ABSTAIN = "VOTE_OPTION_ABSTAIN",
  VOTE_OPTION_NO = "VOTE_OPTION_NO",
  VOTE_OPTION_NO_WITH_VETO = "VOTE_OPTION_NO_WITH_VETO",
}

/**
 * ProposalStatus enumerates the valid statuses of a proposal.
 *
 *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
 *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
 * period.
 *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
 * period.
 *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
 * passed.
 *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
 * been rejected.
 *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
 * failed.
 * @default "PROPOSAL_STATUS_UNSPECIFIED"
 */
export enum CosmosGovV1Beta1ProposalStatus {
  PROPOSAL_STATUS_UNSPECIFIED = "PROPOSAL_STATUS_UNSPECIFIED",
  PROPOSAL_STATUS_DEPOSIT_PERIOD = "PROPOSAL_STATUS_DEPOSIT_PERIOD",
  PROPOSAL_STATUS_VOTING_PERIOD = "PROPOSAL_STATUS_VOTING_PERIOD",
  PROPOSAL_STATUS_PASSED = "PROPOSAL_STATUS_PASSED",
  PROPOSAL_STATUS_REJECTED = "PROPOSAL_STATUS_REJECTED",
  PROPOSAL_STATUS_FAILED = "PROPOSAL_STATUS_FAILED",
}

/**
 * AccessType defines the types of permissions for the operations
 * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
 *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
 *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
 * @default "ACCESS_TYPE_PERMISSIONLESS"
 */
export enum CosmosEvmVmV1AccessType {
  ACCESS_TYPE_PERMISSIONLESS = "ACCESS_TYPE_PERMISSIONLESS",
  ACCESS_TYPE_RESTRICTED = "ACCESS_TYPE_RESTRICTED",
  ACCESS_TYPE_PERMISSIONED = "ACCESS_TYPE_PERMISSIONED",
}

/**
 * Owner enumerates the ownership of a ERC20 contract.
 *
 *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
 *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
 *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
 * @default "OWNER_UNSPECIFIED"
 */
export enum CosmosEvmErc20V1Owner {
  OWNER_UNSPECIFIED = "OWNER_UNSPECIFIED",
  OWNER_MODULE = "OWNER_MODULE",
  OWNER_EXTERNAL = "OWNER_EXTERNAL",
}

/**
 * SignedMsgType is a type of signed message in the consensus.
 *
 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
 * @default "SIGNED_MSG_TYPE_UNKNOWN"
 */
export enum TendermintTypesSignedMsgType {
  SIGNED_MSG_TYPE_UNKNOWN = "SIGNED_MSG_TYPE_UNKNOWN",
  SIGNED_MSG_TYPE_PREVOTE = "SIGNED_MSG_TYPE_PREVOTE",
  SIGNED_MSG_TYPE_PRECOMMIT = "SIGNED_MSG_TYPE_PRECOMMIT",
  SIGNED_MSG_TYPE_PROPOSAL = "SIGNED_MSG_TYPE_PROPOSAL",
}

/**
 * BlockIdFlag indicates which BlockID the signature is for
 * @default "BLOCK_ID_FLAG_UNKNOWN"
 */
export enum TendermintTypesBlockIDFlag {
  BLOCK_ID_FLAG_UNKNOWN = "BLOCK_ID_FLAG_UNKNOWN",
  BLOCK_ID_FLAG_ABSENT = "BLOCK_ID_FLAG_ABSENT",
  BLOCK_ID_FLAG_COMMIT = "BLOCK_ID_FLAG_COMMIT",
  BLOCK_ID_FLAG_NIL = "BLOCK_ID_FLAG_NIL",
}

/**
 * BondStatus is the status of a validator.
 *
 *  - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.
 *  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.
 *  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.
 *  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
 * @default "BOND_STATUS_UNSPECIFIED"
 */
export enum CosmosStakingV1Beta1BondStatus {
  BOND_STATUS_UNSPECIFIED = "BOND_STATUS_UNSPECIFIED",
  BOND_STATUS_UNBONDED = "BOND_STATUS_UNBONDED",
  BOND_STATUS_UNBONDING = "BOND_STATUS_UNBONDING",
  BOND_STATUS_BONDED = "BOND_STATUS_BONDED",
}

/**
 * ContractCodeHistoryOperationType actions that caused a code change
 * - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
 *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
 *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
 *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
 * @default "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
 */
export enum CosmwasmWasmV1ContractCodeHistoryOperationType {
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED",
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT",
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE",
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS",
}

/**
 * AccessType permission types
 * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
 *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
 *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
 *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
 * @default "ACCESS_TYPE_UNSPECIFIED"
 */
export enum CosmwasmWasmV1AccessType {
  ACCESS_TYPE_UNSPECIFIED = "ACCESS_TYPE_UNSPECIFIED",
  ACCESS_TYPE_NOBODY = "ACCESS_TYPE_NOBODY",
  ACCESS_TYPE_EVERYBODY = "ACCESS_TYPE_EVERYBODY",
  ACCESS_TYPE_ANY_OF_ADDRESSES = "ACCESS_TYPE_ANY_OF_ADDRESSES",
}

/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 * message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface CosmosBaseQueryV1Beta1PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin
   * querying the next page most efficiently. Only one of offset or key
   * should be set.
   * @format byte
   */
  key?: string;
  /**
   * offset is a numeric offset that can be used when key is unavailable.
   * It is less efficient than using key. Only one of offset or key should
   * be set.
   * @format uint64
   */
  offset?: string;
  /**
   * limit is the total number of results to be returned in the result page.
   * If left empty it will default to a value to be set by each app.
   * @format uint64
   */
  limit?: string;
  /**
   * count_total is set to true  to indicate that the result set should include
   * a count of the total number of items available for pagination in UIs.
   * count_total is only respected when offset is used. It is ignored when key
   * is set.
   */
  count_total?: boolean;
  /**
   * reverse is set to true if results are to be returned in the descending order.
   *
   * Since: cosmos-sdk 0.43
   */
  reverse?: boolean;
}

/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface CosmosBaseQueryV1Beta1PageResponse {
  /**
   * next_key is the key to be passed to PageRequest.key to
   * query the next page most efficiently. It will be empty if
   * there are no more results.
   * @format byte
   */
  next_key?: string;
  /**
   * total is total number of results available if PageRequest.count_total
   * was set, its value is undefined otherwise
   * @format uint64
   */
  total?: string;
}

/**
 * AbsoluteTxPosition is a unique transaction position that allows for global
 * ordering of transactions.
 */
export interface CosmwasmWasmV1AbsoluteTxPosition {
  /**
   * BlockHeight is the block the contract was created at
   * @format uint64
   */
  block_height?: string;
  /**
   * TxIndex is a monotonic counter within the block (actual transaction index,
   * or gas consumed)
   * @format uint64
   */
  tx_index?: string;
}

/** AccessConfig access control type. */
export interface CosmwasmWasmV1AccessConfig {
  /**
   * AccessType permission types
   * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
   *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
   *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
   *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
   * @default "ACCESS_TYPE_UNSPECIFIED"
   */
  permission?:
    | "ACCESS_TYPE_UNSPECIFIED"
    | "ACCESS_TYPE_NOBODY"
    | "ACCESS_TYPE_EVERYBODY"
    | "ACCESS_TYPE_ANY_OF_ADDRESSES";
  addresses?: string[];
}

/** CodeInfoResponse contains code meta data from CodeInfo */
export interface CosmwasmWasmV1CodeInfoResponse {
  /** @format uint64 */
  code_id?: string;
  creator?: string;
  /** @format byte */
  data_hash?: string;
  /** AccessConfig access control type. */
  instantiate_permission?: {
    /**
     * AccessType permission types
     * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
     *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
     *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
     *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
     * @default "ACCESS_TYPE_UNSPECIFIED"
     */
    permission?:
      | "ACCESS_TYPE_UNSPECIFIED"
      | "ACCESS_TYPE_NOBODY"
      | "ACCESS_TYPE_EVERYBODY"
      | "ACCESS_TYPE_ANY_OF_ADDRESSES";
    addresses?: string[];
  };
}

/** ContractCodeHistoryEntry metadata to a contract. */
export interface CosmwasmWasmV1ContractCodeHistoryEntry {
  /**
   * ContractCodeHistoryOperationType actions that caused a code change
   * - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
   *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
   *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
   *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
   * @default "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
   */
  operation?:
    | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
    | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
    | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
    | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
  /**
   * CodeID is the reference to the stored WASM code
   * @format uint64
   */
  code_id?: string;
  /** Updated Tx position when the operation was executed. */
  updated?: {
    /**
     * BlockHeight is the block the contract was created at
     * @format uint64
     */
    block_height?: string;
    /**
     * TxIndex is a monotonic counter within the block (actual transaction index,
     * or gas consumed)
     * @format uint64
     */
    tx_index?: string;
  };
  /** @format byte */
  msg?: string;
}

/** ContractInfo stores a WASM contract instance */
export interface CosmwasmWasmV1ContractInfo {
  /**
   * CodeID is the reference to the stored Wasm code
   * @format uint64
   */
  code_id?: string;
  /** Creator address who initially instantiated the contract */
  creator?: string;
  /** Admin is an optional address that can execute migrations */
  admin?: string;
  /** Label is optional metadata to be stored with a contract instance. */
  label?: string;
  /** Created Tx position when the contract was instantiated. */
  created?: {
    /**
     * BlockHeight is the block the contract was created at
     * @format uint64
     */
    block_height?: string;
    /**
     * TxIndex is a monotonic counter within the block (actual transaction index,
     * or gas consumed)
     * @format uint64
     */
    tx_index?: string;
  };
  ibc_port_id?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  extension?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/** Model is a struct that holds a KV pair */
export interface CosmwasmWasmV1Model {
  /**
   * hex-encode key to read it better (this is often ascii)
   * @format byte
   */
  key?: string;
  /**
   * base64-encode raw value
   * @format byte
   */
  value?: string;
}

/** Params defines the set of wasm parameters. */
export interface CosmwasmWasmV1Params {
  /** AccessConfig access control type. */
  code_upload_access?: {
    /**
     * AccessType permission types
     * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
     *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
     *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
     *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
     * @default "ACCESS_TYPE_UNSPECIFIED"
     */
    permission?:
      | "ACCESS_TYPE_UNSPECIFIED"
      | "ACCESS_TYPE_NOBODY"
      | "ACCESS_TYPE_EVERYBODY"
      | "ACCESS_TYPE_ANY_OF_ADDRESSES";
    addresses?: string[];
  };
  /**
   * AccessType permission types
   * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
   *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
   *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
   *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
   * @default "ACCESS_TYPE_UNSPECIFIED"
   */
  instantiate_default_permission?:
    | "ACCESS_TYPE_UNSPECIFIED"
    | "ACCESS_TYPE_NOBODY"
    | "ACCESS_TYPE_EVERYBODY"
    | "ACCESS_TYPE_ANY_OF_ADDRESSES";
}

/**
 * QueryAllContractStateResponse is the response type for the
 * Query/AllContractState RPC method
 */
export interface CosmwasmWasmV1QueryAllContractStateResponse {
  models?: {
    /**
     * hex-encode key to read it better (this is often ascii)
     * @format byte
     */
    key?: string;
    /**
     * base64-encode raw value
     * @format byte
     */
    value?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryBuildAddressResponse is the response type for the Query/BuildAddress RPC
 * method.
 */
export interface CosmwasmWasmV1QueryBuildAddressResponse {
  /** Address is the contract address */
  address?: string;
}

/** QueryCodeResponse is the response type for the Query/Code RPC method */
export interface CosmwasmWasmV1QueryCodeResponse {
  /** CodeInfoResponse contains code meta data from CodeInfo */
  code_info?: {
    /** @format uint64 */
    code_id?: string;
    creator?: string;
    /** @format byte */
    data_hash?: string;
    /** AccessConfig access control type. */
    instantiate_permission?: {
      /**
       * AccessType permission types
       * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
       *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
       *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
       *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
       * @default "ACCESS_TYPE_UNSPECIFIED"
       */
      permission?:
        | "ACCESS_TYPE_UNSPECIFIED"
        | "ACCESS_TYPE_NOBODY"
        | "ACCESS_TYPE_EVERYBODY"
        | "ACCESS_TYPE_ANY_OF_ADDRESSES";
      addresses?: string[];
    };
  };
  /** @format byte */
  data?: string;
}

/** QueryCodesResponse is the response type for the Query/Codes RPC method */
export interface CosmwasmWasmV1QueryCodesResponse {
  code_infos?: {
    /** @format uint64 */
    code_id?: string;
    creator?: string;
    /** @format byte */
    data_hash?: string;
    /** AccessConfig access control type. */
    instantiate_permission?: {
      /**
       * AccessType permission types
       * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
       *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
       *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
       *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
       * @default "ACCESS_TYPE_UNSPECIFIED"
       */
      permission?:
        | "ACCESS_TYPE_UNSPECIFIED"
        | "ACCESS_TYPE_NOBODY"
        | "ACCESS_TYPE_EVERYBODY"
        | "ACCESS_TYPE_ANY_OF_ADDRESSES";
      addresses?: string[];
    };
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryContractHistoryResponse is the response type for the
 * Query/ContractHistory RPC method
 */
export interface CosmwasmWasmV1QueryContractHistoryResponse {
  entries?: {
    /**
     * ContractCodeHistoryOperationType actions that caused a code change
     * - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
     *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
     *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
     *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
     * @default "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
     */
    operation?:
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
    /**
     * CodeID is the reference to the stored WASM code
     * @format uint64
     */
    code_id?: string;
    /** Updated Tx position when the operation was executed. */
    updated?: {
      /**
       * BlockHeight is the block the contract was created at
       * @format uint64
       */
      block_height?: string;
      /**
       * TxIndex is a monotonic counter within the block (actual transaction index,
       * or gas consumed)
       * @format uint64
       */
      tx_index?: string;
    };
    /** @format byte */
    msg?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryContractInfoResponse is the response type for the Query/ContractInfo RPC
 * method
 */
export interface CosmwasmWasmV1QueryContractInfoResponse {
  /** address is the address of the contract */
  address?: string;
  /** ContractInfo stores a WASM contract instance */
  contract_info?: {
    /**
     * CodeID is the reference to the stored Wasm code
     * @format uint64
     */
    code_id?: string;
    /** Creator address who initially instantiated the contract */
    creator?: string;
    /** Admin is an optional address that can execute migrations */
    admin?: string;
    /** Label is optional metadata to be stored with a contract instance. */
    label?: string;
    /** Created Tx position when the contract was instantiated. */
    created?: {
      /**
       * BlockHeight is the block the contract was created at
       * @format uint64
       */
      block_height?: string;
      /**
       * TxIndex is a monotonic counter within the block (actual transaction index,
       * or gas consumed)
       * @format uint64
       */
      tx_index?: string;
    };
    ibc_port_id?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    extension?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  };
}

/**
 * QueryContractsByCodeResponse is the response type for the
 * Query/ContractsByCode RPC method
 */
export interface CosmwasmWasmV1QueryContractsByCodeResponse {
  /** contracts are a set of contract addresses */
  contracts?: string[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryContractsByCreatorResponse is the response type for the
 * Query/ContractsByCreator RPC method.
 */
export interface CosmwasmWasmV1QueryContractsByCreatorResponse {
  /** ContractAddresses result set */
  contract_addresses?: string[];
  /** Pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface CosmwasmWasmV1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /** AccessConfig access control type. */
    code_upload_access?: {
      /**
       * AccessType permission types
       * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
       *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
       *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
       *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
       * @default "ACCESS_TYPE_UNSPECIFIED"
       */
      permission?:
        | "ACCESS_TYPE_UNSPECIFIED"
        | "ACCESS_TYPE_NOBODY"
        | "ACCESS_TYPE_EVERYBODY"
        | "ACCESS_TYPE_ANY_OF_ADDRESSES";
      addresses?: string[];
    };
    /**
     * AccessType permission types
     * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
     *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
     *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
     *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
     * @default "ACCESS_TYPE_UNSPECIFIED"
     */
    instantiate_default_permission?:
      | "ACCESS_TYPE_UNSPECIFIED"
      | "ACCESS_TYPE_NOBODY"
      | "ACCESS_TYPE_EVERYBODY"
      | "ACCESS_TYPE_ANY_OF_ADDRESSES";
  };
}

/**
 * QueryPinnedCodesResponse is the response type for the
 * Query/PinnedCodes RPC method
 */
export interface CosmwasmWasmV1QueryPinnedCodesResponse {
  code_ids?: string[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryRawContractStateResponse is the response type for the
 * Query/RawContractState RPC method
 */
export interface CosmwasmWasmV1QueryRawContractStateResponse {
  /**
   * Data contains the raw store data
   * @format byte
   */
  data?: string;
}

/**
 * QuerySmartContractStateResponse is the response type for the
 * Query/SmartContractState RPC method
 */
export interface CosmwasmWasmV1QuerySmartContractStateResponse {
  /**
   * Data contains the json data returned from the smart contract
   * @format byte
   */
  data?: string;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *     // or ...
 *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
 *       foo = any.unpack(Foo.getDefaultInstance());
 *     }
 *
 * Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 * Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 * JSON
 *
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
export interface GoogleProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized
   * protocol buffer message. This string must contain at least
   * one "/" character. The last segment of the URL's path must represent
   * the fully qualified name of the type (as in
   * `path/google.protobuf.Duration`). The name should be in a canonical form
   * (e.g., leading "." is not accepted).
   *
   * In practice, teams usually precompile into the binary all types that they
   * expect it to use in the context of Any. However, for URLs which use the
   * scheme `http`, `https`, or no scheme, one can optionally set up a type
   * server that maps type URLs to message definitions as follows:
   *
   * * If no scheme is provided, `https` is assumed.
   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
   *   value in binary format, or produce an error.
   * * Applications are allowed to cache lookup results based on the
   *   URL, or have them precompiled into a binary to avoid any
   *   lookup. Therefore, binary compatibility needs to be preserved
   *   on changes to types. (Use versioned type names to manage
   *   breaking changes.)
   *
   * Note: this functionality is not currently available in the official
   * protobuf release, and it is not used for type URLs beginning with
   * type.googleapis.com.
   *
   * Schemes other than `http`, `https` (or the empty scheme) might be
   * used with implementation specific semantics.
   */
  type_url?: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   * @format byte
   */
  value?: string;
}

export interface GrpcGatewayRuntimeError {
  error?: string;
  /** @format int32 */
  code?: number;
  message?: string;
  details?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
}

/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface CosmosBaseV1Beta1Coin {
  denom?: string;
  amount?: string;
}

/**
 * DenomAuthorityMetadata specifies metadata for addresses that have specific
 * capabilities over a token factory denom. Right now there is only one Admin
 * permission, but is planned to be extended to the future.
 */
export interface KiichainTokenfactoryV1Beta1DenomAuthorityMetadata {
  /** Can be empty for no admin, or a valid kii address */
  admin?: string;
}

/** Params defines the parameters for the tokenfactory module. */
export interface KiichainTokenfactoryV1Beta1Params {
  denom_creation_fee?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * if denom_creation_fee is an empty array, then this field is used to add
   * more gas consumption to the base cost.
   * https://github.com/CosmWasm/token-factory/issues/11
   * @format uint64
   */
  denom_creation_gas_consume?: string;
}

/**
 * QueryDenomAuthorityMetadataResponse defines the response structure for the
 * DenomAuthorityMetadata gRPC query.
 */
export interface KiichainTokenfactoryV1Beta1QueryDenomAuthorityMetadataResponse {
  /**
   * DenomAuthorityMetadata specifies metadata for addresses that have specific
   * capabilities over a token factory denom. Right now there is only one Admin
   * permission, but is planned to be extended to the future.
   */
  authority_metadata?: {
    /** Can be empty for no admin, or a valid kii address */
    admin?: string;
  };
}

/**
 * QueryDenomsFromAdminRequest defines the response structure for the
 * DenomsFromAdmin gRPC query.
 */
export interface KiichainTokenfactoryV1Beta1QueryDenomsFromAdminResponse {
  denoms?: string[];
}

/**
 * QueryDenomsFromCreatorRequest defines the response structure for the
 * DenomsFromCreator gRPC query.
 */
export interface KiichainTokenfactoryV1Beta1QueryDenomsFromCreatorResponse {
  denoms?: string[];
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface KiichainTokenfactoryV1Beta1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    denom_creation_fee?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * if denom_creation_fee is an empty array, then this field is used to add
     * more gas consumption to the base cost.
     * https://github.com/CosmWasm/token-factory/issues/11
     * @format uint64
     */
    denom_creation_gas_consume?: string;
  };
}

/** Data type which has the name of the currency */
export interface KiichainOracleV1Beta1Denom {
  /** Stores the name of a token pair, e.g: "BTC/USD" */
  name?: string;
}

/** DenomOracleExchangeRate is the data type that represents an set of denom - exchange rate values */
export interface KiichainOracleV1Beta1DenomOracleExchangeRate {
  denom?: string;
  /**
   * Data type that stores the final calculated exchange rate after all votes were
   * aggregated to that single exchange, record the last block height and timestamp when rate was updated
   */
  oracle_exchange_rate?: {
    exchange_rate?: string;
    last_update?: string;
    /** @format int64 */
    last_update_timestamp?: string;
  };
}

/**
 * Data type that stores the final calculated exchange rate after all votes were
 * aggregated to that single exchange, record the last block height and timestamp when rate was updated
 */
export interface KiichainOracleV1Beta1OracleExchangeRate {
  exchange_rate?: string;
  last_update?: string;
  /** @format int64 */
  last_update_timestamp?: string;
}

/**
 * Twap = Time-weighted average price
 * Data type that computes the average price over an specific period of time
 */
export interface KiichainOracleV1Beta1OracleTwap {
  denom?: string;
  twap?: string;
  /** @format int64 */
  lookback_seconds?: string;
}

/** Params defines the parameters for the module */
export interface KiichainOracleV1Beta1Params {
  /**
   * The number of blocks per voting
   * @format uint64
   */
  vote_period?: string;
  /**
   * Minimum percentage of validators required to approve a price. For instance, if vote_threshold = "0.5" at least 50% of validators must submit votes
   * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
   */
  vote_threshold?: string;
  /**
   * Acceptable deviation from the media price (higher and lower)
   * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
   */
  reward_band?: string;
  /**
   * List of allowed assets
   * DenomList is a custom data type, defined on x/oracle/types/denom.go
   */
  whitelist?: {
    /** Stores the name of a token pair, e.g: "BTC/USD" */
    name?: string;
  }[];
  /**
   * How much stake is slashed if a validator fails to submit votes
   * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
   */
  slash_fraction?: string;
  /**
   * Define the window (in blocks) to vote, if not receive penalties due to bad performance
   * @format uint64
   */
  slash_window?: string;
  /**
   * Minimum percentage of voting on windows to avoid slashing. For instance, if min_valid_per_window = 0.8, then a validator must submit votes in 80% of windows to avoid slashing
   * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
   */
  min_valid_per_window?: string;
  /**
   * How far back (in blocks) the module can compute historical price metrics
   * @format uint64
   */
  lookback_duration?: string;
}

/**
 * Data type represents a list of prices snapshots for all currencies at an specific time
 * PriceSnapshotItems is a custom type, defined on x/orcale/types/snapshots.go
 */
export interface KiichainOracleV1Beta1PriceSnapshot {
  /** @format int64 */
  snapshot_timestamp?: string;
  price_snapshot_items?: {
    denom?: string;
    /**
     * Data type that stores the final calculated exchange rate after all votes were
     * aggregated to that single exchange, record the last block height and timestamp when rate was updated
     */
    oracle_exchange_rate?: {
      exchange_rate?: string;
      last_update?: string;
      /** @format int64 */
      last_update_timestamp?: string;
    };
  }[];
}

/** Data type represents one historical price record for a single exchange rate */
export interface KiichainOracleV1Beta1PriceSnapshotItem {
  denom?: string;
  /**
   * Data type that stores the final calculated exchange rate after all votes were
   * aggregated to that single exchange, record the last block height and timestamp when rate was updated
   */
  oracle_exchange_rate?: {
    exchange_rate?: string;
    last_update?: string;
    /** @format int64 */
    last_update_timestamp?: string;
  };
}

/** QueryActivesResponse is the response for the Query/Actives rpc method */
export interface KiichainOracleV1Beta1QueryActivesResponse {
  actives?: string[];
}

/** QueryExchangeRateResponse is the response for the Query/ExchangeRate rpc method */
export interface KiichainOracleV1Beta1QueryExchangeRateResponse {
  /**
   * Data type that stores the final calculated exchange rate after all votes were
   * aggregated to that single exchange, record the last block height and timestamp when rate was updated
   */
  oracle_exchange_rate?: {
    exchange_rate?: string;
    last_update?: string;
    /** @format int64 */
    last_update_timestamp?: string;
  };
}

/**
 * QueryExchangeRatesResponse is the response for the Query/ExchangeRatess rpc method
 * DenomOracleExchangeRatePairs is the alias of the element denom_oracle_exchange_rate after generating the code
 */
export interface KiichainOracleV1Beta1QueryExchangeRatesResponse {
  denom_oracle_exchange_rate?: {
    denom?: string;
    /**
     * Data type that stores the final calculated exchange rate after all votes were
     * aggregated to that single exchange, record the last block height and timestamp when rate was updated
     */
    oracle_exchange_rate?: {
      exchange_rate?: string;
      last_update?: string;
      /** @format int64 */
      last_update_timestamp?: string;
    };
  }[];
}

/** QueryFeederDelegationResponse is the response for the Query/FeederDelegation rpc method */
export interface KiichainOracleV1Beta1QueryFeederDelegationResponse {
  /** delegated address */
  feed_addr?: string;
}

/** QueryParamsResponse is the response for the Query/Params rpc method */
export interface KiichainOracleV1Beta1QueryParamsResponse {
  /** return the params module's params */
  params?: {
    /**
     * The number of blocks per voting
     * @format uint64
     */
    vote_period?: string;
    /**
     * Minimum percentage of validators required to approve a price. For instance, if vote_threshold = "0.5" at least 50% of validators must submit votes
     * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
     */
    vote_threshold?: string;
    /**
     * Acceptable deviation from the media price (higher and lower)
     * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
     */
    reward_band?: string;
    /**
     * List of allowed assets
     * DenomList is a custom data type, defined on x/oracle/types/denom.go
     */
    whitelist?: {
      /** Stores the name of a token pair, e.g: "BTC/USD" */
      name?: string;
    }[];
    /**
     * How much stake is slashed if a validator fails to submit votes
     * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
     */
    slash_fraction?: string;
    /**
     * Define the window (in blocks) to vote, if not receive penalties due to bad performance
     * @format uint64
     */
    slash_window?: string;
    /**
     * Minimum percentage of voting on windows to avoid slashing. For instance, if min_valid_per_window = 0.8, then a validator must submit votes in 80% of windows to avoid slashing
     * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
     */
    min_valid_per_window?: string;
    /**
     * How far back (in blocks) the module can compute historical price metrics
     * @format uint64
     */
    lookback_duration?: string;
  };
}

/**
 * QueryPriceSnapshotHistoryResponse is the response for the Query/PriceSnapshotHistory rpc method
 * PriceSnapshots is the alias of the price_snapshot element
 */
export interface KiichainOracleV1Beta1QueryPriceSnapshotHistoryResponse {
  price_snapshot?: {
    /** @format int64 */
    snapshot_timestamp?: string;
    price_snapshot_items?: {
      denom?: string;
      /**
       * Data type that stores the final calculated exchange rate after all votes were
       * aggregated to that single exchange, record the last block height and timestamp when rate was updated
       */
      oracle_exchange_rate?: {
        exchange_rate?: string;
        last_update?: string;
        /** @format int64 */
        last_update_timestamp?: string;
      };
    }[];
  }[];
}

/** QuerySlashWindowResponse is the response for the Query/SlashWindow rpc */
export interface KiichainOracleV1Beta1QuerySlashWindowResponse {
  /**
   * window_progress defines the number of voting periods
   * @format uint64
   */
  window_progress?: string;
}

/**
 * QueryTwapsRequest is the response for the Query/Twaps rpc method
 * OracleTwaps is the alias of the oracle_twap array element
 */
export interface KiichainOracleV1Beta1QueryTwapsResponse {
  /**
   * Twap = Time-weighted average price
   * oracle_twap is the average price over an specific period of time and denom
   */
  oracle_twap?: {
    denom?: string;
    twap?: string;
    /** @format int64 */
    lookback_seconds?: string;
  }[];
}

/** QueryVotePenaltyCounterResponse is the response for the Query/VotePenaltyCounter rpc */
export interface KiichainOracleV1Beta1QueryVotePenaltyCounterResponse {
  /** Returns the voting behavior per validator */
  vote_penalty_counter?: {
    /** @format uint64 */
    miss_count?: string;
    /** @format uint64 */
    abstain_count?: string;
    /** @format uint64 */
    success_count?: string;
  };
}

/** QueryVoteTargetsRequest is the response for the Query/VoteTargets rpc method */
export interface KiichainOracleV1Beta1QueryVoteTargetsResponse {
  vote_targets?: string[];
}

/** Data type that tracks the voting behavior per validator */
export interface KiichainOracleV1Beta1VotePenaltyCounter {
  /** @format uint64 */
  miss_count?: string;
  /** @format uint64 */
  abstain_count?: string;
  /** @format uint64 */
  success_count?: string;
}

/**
 * DecCoin defines a token with a denomination and a decimal amount.
 *
 * NOTE: The amount field is an Dec which implements the custom method
 * signatures required by gogoproto.
 */
export interface CosmosBaseV1Beta1DecCoin {
  denom?: string;
  amount?: string;
}

/** Params defines the parameters for the rewards module. */
export interface KiichainRewardsV1Beta1Params {
  /** Denom used */
  token_denom?: string;
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface KiichainRewardsV1Beta1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /** Denom used */
    token_denom?: string;
  };
}

/**
 * QueryReleaseScheduleResponse defines the response structure for the
 * ReleaseSchedule gRPC query.
 */
export interface KiichainRewardsV1Beta1QueryReleaseScheduleResponse {
  /** ReleaseSchedule defines information related to reward distribution */
  release_schedule?: {
    /**
     * Total amount to be rewarded
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    total_amount?: {
      denom?: string;
      amount?: string;
    };
    /**
     * Amount released
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    released_amount?: {
      denom?: string;
      amount?: string;
    };
    /**
     * Timestamp of end of release
     * @format date-time
     */
    end_time?: string;
    /**
     * Last height released
     * @format date-time
     */
    last_release_time?: string;
    /** If reward pool is active */
    active?: boolean;
  };
}

/**
 * QueryRewardPoolResponse defines the response structure for the
 * RewardPool gRPC query.
 */
export interface KiichainRewardsV1Beta1QueryRewardPoolResponse {
  /** RewardPool is the global fee pool for distribution. */
  reward_pool?: {
    community_pool?: {
      denom?: string;
      amount?: string;
    }[];
  };
}

/** ReleaseSchedule defines information related to reward distribution */
export interface KiichainRewardsV1Beta1ReleaseSchedule {
  /**
   * Total amount to be rewarded
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  total_amount?: {
    denom?: string;
    amount?: string;
  };
  /**
   * Amount released
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  released_amount?: {
    denom?: string;
    amount?: string;
  };
  /**
   * Timestamp of end of release
   * @format date-time
   */
  end_time?: string;
  /**
   * Last height released
   * @format date-time
   */
  last_release_time?: string;
  /** If reward pool is active */
  active?: boolean;
}

/** RewardPool is the global fee pool for distribution. */
export interface KiichainRewardsV1Beta1RewardPool {
  community_pool?: {
    denom?: string;
    amount?: string;
  }[];
}

/** FeeTokenMetadata defines the metadata for a fee token */
export interface KiichainFeeabstractionV1Beta1FeeTokenMetadata {
  /** Denom is the token denom */
  denom?: string;
  /** Identifier on the oracle module */
  oracle_denom?: string;
  /**
   * Decimals is the number of decimals for the token
   * @format int64
   */
  decimals?: number;
  /**
   * Price is the price of the token in the native denom
   * This price is paired against the native denom
   * So, this equals to the token/native denom
   */
  price?: string;
  /** Enabled indicates if the token is enabled for fee abstraction */
  enabled?: boolean;
}

/** Defines a collection of fee token metadata */
export interface KiichainFeeabstractionV1Beta1FeeTokenMetadataCollection {
  /** Items is a repeated field of FeeTokenMetadata */
  items?: {
    /** Denom is the token denom */
    denom?: string;
    /** Identifier on the oracle module */
    oracle_denom?: string;
    /**
     * Decimals is the number of decimals for the token
     * @format int64
     */
    decimals?: number;
    /**
     * Price is the price of the token in the native denom
     * This price is paired against the native denom
     * So, this equals to the token/native denom
     */
    price?: string;
    /** Enabled indicates if the token is enabled for fee abstraction */
    enabled?: boolean;
  }[];
}

/** Params defines the parameters for the fee abstraction module */
export interface KiichainFeeabstractionV1Beta1Params {
  /** Native denom */
  native_denom?: string;
  /** Oracle module identifier */
  native_oracle_denom?: string;
  /** Enabled indicates if the fee abstraction module is enabled */
  enabled?: boolean;
  /** ClampFactor is the factor to clamp the price deviation */
  clamp_factor?: string;
  /**
   * TwapLookbackWindow is the lookback window for calculating TWAPs
   * @format uint64
   */
  twap_lookback_window?: string;
  /**
   * FallbackNativePrice is the fallback price for the native token if the
   * oracle price is not available (in USD)
   */
  fallback_native_price?: string;
}

/**
 * QueryFeeTokensResponse is the response type for the Query/FeeTokens RPC
 * method
 */
export interface KiichainFeeabstractionV1Beta1QueryFeeTokensResponse {
  /**
   * Defines a collection of fee token metadata
   * fee_tokens defines the fee tokens registered in the module.
   */
  fee_tokens?: {
    /** Items is a repeated field of FeeTokenMetadata */
    items?: {
      /** Denom is the token denom */
      denom?: string;
      /** Identifier on the oracle module */
      oracle_denom?: string;
      /**
       * Decimals is the number of decimals for the token
       * @format int64
       */
      decimals?: number;
      /**
       * Price is the price of the token in the native denom
       * This price is paired against the native denom
       * So, this equals to the token/native denom
       */
      price?: string;
      /** Enabled indicates if the token is enabled for fee abstraction */
      enabled?: boolean;
    }[];
  };
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface KiichainFeeabstractionV1Beta1QueryParamsResponse {
  /**
   * Params defines the parameters for the fee abstraction module
   * params defines the parameters of the module.
   */
  params?: {
    /** Native denom */
    native_denom?: string;
    /** Oracle module identifier */
    native_oracle_denom?: string;
    /** Enabled indicates if the fee abstraction module is enabled */
    enabled?: boolean;
    /** ClampFactor is the factor to clamp the price deviation */
    clamp_factor?: string;
    /**
     * TwapLookbackWindow is the lookback window for calculating TWAPs
     * @format uint64
     */
    twap_lookback_window?: string;
    /**
     * FallbackNativePrice is the fallback price for the native token if the
     * oracle price is not available (in USD)
     */
    fallback_native_price?: string;
  };
}

/**
 * DenomOwner defines structure representing an account that owns or holds a
 * particular denominated token. It contains the account address and account
 * balance of the denominated token.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosBankV1Beta1DenomOwner {
  /** address defines the address that owns a particular denomination. */
  address?: string;
  /**
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  balance?: {
    denom?: string;
    amount?: string;
  };
}

/**
 * DenomUnit represents a struct that describes a given
 * denomination unit of the basic token.
 */
export interface CosmosBankV1Beta1DenomUnit {
  /** denom represents the string name of the given denom unit (e.g uatom). */
  denom?: string;
  /**
   * exponent represents power of 10 exponent that one must
   * raise the base_denom to in order to equal the given DenomUnit's denom
   * 1 denom = 10^exponent base_denom
   * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
   * exponent = 6, thus: 1 atom = 10^6 uatom).
   * @format int64
   */
  exponent?: number;
  /** aliases is a list of string aliases for the given denom */
  aliases?: string[];
}

/**
 * Metadata represents a struct that describes
 * a basic token.
 */
export interface CosmosBankV1Beta1Metadata {
  description?: string;
  /** denom_units represents the list of DenomUnit's for a given coin */
  denom_units?: {
    /** denom represents the string name of the given denom unit (e.g uatom). */
    denom?: string;
    /**
     * exponent represents power of 10 exponent that one must
     * raise the base_denom to in order to equal the given DenomUnit's denom
     * 1 denom = 10^exponent base_denom
     * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
     * exponent = 6, thus: 1 atom = 10^6 uatom).
     * @format int64
     */
    exponent?: number;
    /** aliases is a list of string aliases for the given denom */
    aliases?: string[];
  }[];
  /** base represents the base denom (should be the DenomUnit with exponent = 0). */
  base?: string;
  /**
   * display indicates the suggested denom that should be
   * displayed in clients.
   */
  display?: string;
  /**
   * name defines the name of the token (eg: Cosmos Atom)
   * Since: cosmos-sdk 0.43
   */
  name?: string;
  /**
   * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
   * be the same as the display.
   *
   * Since: cosmos-sdk 0.43
   */
  symbol?: string;
  /**
   * URI to a document (on or off-chain) that contains additional information. Optional.
   *
   * Since: cosmos-sdk 0.46
   */
  uri?: string;
  /**
   * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
   * the document didn't change. Optional.
   *
   * Since: cosmos-sdk 0.46
   */
  uri_hash?: string;
}

/** Params defines the parameters for the bank module. */
export interface CosmosBankV1Beta1Params {
  /**
   * Deprecated: Use of SendEnabled in params is deprecated.
   * For genesis, use the newly added send_enabled field in the genesis object.
   * Storage, lookup, and manipulation of this information is now in the keeper.
   *
   * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
   */
  send_enabled?: {
    denom?: string;
    enabled?: boolean;
  }[];
  default_send_enabled?: boolean;
}

/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 */
export interface CosmosBankV1Beta1QueryAllBalancesResponse {
  /** balances is the balances of all the coins. */
  balances?: {
    denom?: string;
    amount?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface CosmosBankV1Beta1QueryBalanceResponse {
  /**
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  balance?: {
    denom?: string;
    amount?: string;
  };
}

/**
 * QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC
 * method. Identical with QueryDenomMetadataResponse but receives denom as query string in request.
 */
export interface CosmosBankV1Beta1QueryDenomMetadataByQueryStringResponse {
  /**
   * Metadata represents a struct that describes
   * a basic token.
   */
  metadata?: {
    description?: string;
    /** denom_units represents the list of DenomUnit's for a given coin */
    denom_units?: {
      /** denom represents the string name of the given denom unit (e.g uatom). */
      denom?: string;
      /**
       * exponent represents power of 10 exponent that one must
       * raise the base_denom to in order to equal the given DenomUnit's denom
       * 1 denom = 10^exponent base_denom
       * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
       * exponent = 6, thus: 1 atom = 10^6 uatom).
       * @format int64
       */
      exponent?: number;
      /** aliases is a list of string aliases for the given denom */
      aliases?: string[];
    }[];
    /** base represents the base denom (should be the DenomUnit with exponent = 0). */
    base?: string;
    /**
     * display indicates the suggested denom that should be
     * displayed in clients.
     */
    display?: string;
    /**
     * name defines the name of the token (eg: Cosmos Atom)
     * Since: cosmos-sdk 0.43
     */
    name?: string;
    /**
     * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
     * be the same as the display.
     *
     * Since: cosmos-sdk 0.43
     */
    symbol?: string;
    /**
     * URI to a document (on or off-chain) that contains additional information. Optional.
     *
     * Since: cosmos-sdk 0.46
     */
    uri?: string;
    /**
     * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
     * the document didn't change. Optional.
     *
     * Since: cosmos-sdk 0.46
     */
    uri_hash?: string;
  };
}

/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
 * method.
 */
export interface CosmosBankV1Beta1QueryDenomMetadataResponse {
  /**
   * Metadata represents a struct that describes
   * a basic token.
   */
  metadata?: {
    description?: string;
    /** denom_units represents the list of DenomUnit's for a given coin */
    denom_units?: {
      /** denom represents the string name of the given denom unit (e.g uatom). */
      denom?: string;
      /**
       * exponent represents power of 10 exponent that one must
       * raise the base_denom to in order to equal the given DenomUnit's denom
       * 1 denom = 10^exponent base_denom
       * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
       * exponent = 6, thus: 1 atom = 10^6 uatom).
       * @format int64
       */
      exponent?: number;
      /** aliases is a list of string aliases for the given denom */
      aliases?: string[];
    }[];
    /** base represents the base denom (should be the DenomUnit with exponent = 0). */
    base?: string;
    /**
     * display indicates the suggested denom that should be
     * displayed in clients.
     */
    display?: string;
    /**
     * name defines the name of the token (eg: Cosmos Atom)
     * Since: cosmos-sdk 0.43
     */
    name?: string;
    /**
     * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
     * be the same as the display.
     *
     * Since: cosmos-sdk 0.43
     */
    symbol?: string;
    /**
     * URI to a document (on or off-chain) that contains additional information. Optional.
     *
     * Since: cosmos-sdk 0.46
     */
    uri?: string;
    /**
     * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
     * the document didn't change. Optional.
     *
     * Since: cosmos-sdk 0.46
     */
    uri_hash?: string;
  };
}

/**
 * QueryDenomOwnersByQueryResponse defines the RPC response of a DenomOwnersByQuery RPC query.
 *
 * Since: cosmos-sdk 0.50.3
 */
export interface CosmosBankV1Beta1QueryDenomOwnersByQueryResponse {
  denom_owners?: {
    /** address defines the address that owns a particular denomination. */
    address?: string;
    /**
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    balance?: {
      denom?: string;
      amount?: string;
    };
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosBankV1Beta1QueryDenomOwnersResponse {
  denom_owners?: {
    /** address defines the address that owns a particular denomination. */
    address?: string;
    /**
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    balance?: {
      denom?: string;
      amount?: string;
    };
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 */
export interface CosmosBankV1Beta1QueryDenomsMetadataResponse {
  /** metadata provides the client information for all the registered tokens. */
  metadatas?: {
    description?: string;
    /** denom_units represents the list of DenomUnit's for a given coin */
    denom_units?: {
      /** denom represents the string name of the given denom unit (e.g uatom). */
      denom?: string;
      /**
       * exponent represents power of 10 exponent that one must
       * raise the base_denom to in order to equal the given DenomUnit's denom
       * 1 denom = 10^exponent base_denom
       * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
       * exponent = 6, thus: 1 atom = 10^6 uatom).
       * @format int64
       */
      exponent?: number;
      /** aliases is a list of string aliases for the given denom */
      aliases?: string[];
    }[];
    /** base represents the base denom (should be the DenomUnit with exponent = 0). */
    base?: string;
    /**
     * display indicates the suggested denom that should be
     * displayed in clients.
     */
    display?: string;
    /**
     * name defines the name of the token (eg: Cosmos Atom)
     * Since: cosmos-sdk 0.43
     */
    name?: string;
    /**
     * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
     * be the same as the display.
     *
     * Since: cosmos-sdk 0.43
     */
    symbol?: string;
    /**
     * URI to a document (on or off-chain) that contains additional information. Optional.
     *
     * Since: cosmos-sdk 0.46
     */
    uri?: string;
    /**
     * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
     * the document didn't change. Optional.
     *
     * Since: cosmos-sdk 0.46
     */
    uri_hash?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryParamsResponse defines the response type for querying x/bank parameters. */
export interface CosmosBankV1Beta1QueryParamsResponse {
  /** params provides the parameters of the bank module. */
  params?: {
    /**
     * Deprecated: Use of SendEnabled in params is deprecated.
     * For genesis, use the newly added send_enabled field in the genesis object.
     * Storage, lookup, and manipulation of this information is now in the keeper.
     *
     * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
     */
    send_enabled?: {
      denom?: string;
      enabled?: boolean;
    }[];
    default_send_enabled?: boolean;
  };
}

/**
 * QuerySendEnabledResponse defines the RPC response of a SendEnable query.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosBankV1Beta1QuerySendEnabledResponse {
  send_enabled?: {
    denom?: string;
    enabled?: boolean;
  }[];
  /**
   * pagination defines the pagination in the response. This field is only
   * populated if the denoms field in the request is empty.
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QuerySpendableBalanceByDenomResponse defines the gRPC response structure for
 * querying an account's spendable balance for a specific denom.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosBankV1Beta1QuerySpendableBalanceByDenomResponse {
  /**
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  balance?: {
    denom?: string;
    amount?: string;
  };
}

/**
 * QuerySpendableBalancesResponse defines the gRPC response structure for querying
 * an account's spendable balances.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosBankV1Beta1QuerySpendableBalancesResponse {
  /** balances is the spendable balances of all the coins. */
  balances?: {
    denom?: string;
    amount?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
export interface CosmosBankV1Beta1QuerySupplyOfResponse {
  /**
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  amount?: {
    denom?: string;
    amount?: string;
  };
}

/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 */
export interface CosmosBankV1Beta1QueryTotalSupplyResponse {
  /** supply is the supply of the coins */
  supply?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * pagination defines the pagination in the response.
   *
   * Since: cosmos-sdk 0.43
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is
 * sendable).
 */
export interface CosmosBankV1Beta1SendEnabled {
  denom?: string;
  enabled?: boolean;
}

/**
 * Grant gives permissions to execute
 * the provide method with expiration time.
 */
export interface CosmosAuthzV1Beta1Grant {
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  authorization?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * time when the grant will expire and will be pruned. If null, then the grant
   * doesn't have a time expiration (other conditions  in `authorization`
   * may apply to invalidate the grant)
   * @format date-time
   */
  expiration?: string;
}

/**
 * GrantAuthorization extends a grant with both the addresses of the grantee and granter.
 * It is used in genesis.proto and query.proto
 */
export interface CosmosAuthzV1Beta1GrantAuthorization {
  granter?: string;
  grantee?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  authorization?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /** @format date-time */
  expiration?: string;
}

/** QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
export interface CosmosAuthzV1Beta1QueryGranteeGrantsResponse {
  /** grants is a list of grants granted to the grantee. */
  grants?: {
    granter?: string;
    grantee?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    authorization?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** @format date-time */
    expiration?: string;
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
export interface CosmosAuthzV1Beta1QueryGranterGrantsResponse {
  /** grants is a list of grants granted by the granter. */
  grants?: {
    granter?: string;
    grantee?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    authorization?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** @format date-time */
    expiration?: string;
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
export interface CosmosAuthzV1Beta1QueryGrantsResponse {
  /** authorizations is a list of grants granted for grantee by granter. */
  grants?: {
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    authorization?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /**
     * time when the grant will expire and will be pruned. If null, then the grant
     * doesn't have a time expiration (other conditions  in `authorization`
     * may apply to invalidate the grant)
     * @format date-time
     */
    expiration?: string;
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** Commission defines commission parameters for a given validator. */
export interface CosmosStakingV1Beta1Commission {
  /** commission_rates defines the initial commission rates to be used for creating a validator. */
  commission_rates?: {
    /** rate is the commission rate charged to delegators, as a fraction. */
    rate?: string;
    /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
    max_rate?: string;
    /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
    max_change_rate?: string;
  };
  /**
   * update_time is the last time the commission rate was changed.
   * @format date-time
   */
  update_time?: string;
}

/**
 * CommissionRates defines the initial commission rates to be used for creating
 * a validator.
 */
export interface CosmosStakingV1Beta1CommissionRates {
  /** rate is the commission rate charged to delegators, as a fraction. */
  rate?: string;
  /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
  max_rate?: string;
  /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
  max_change_rate?: string;
}

/**
 * Delegation represents the bond with tokens held by an account. It is
 * owned by one delegator, and is associated with the voting power of one
 * validator.
 */
export interface CosmosStakingV1Beta1Delegation {
  /** delegator_address is the encoded address of the delegator. */
  delegator_address?: string;
  /** validator_address is the encoded address of the validator. */
  validator_address?: string;
  /** shares define the delegation shares received. */
  shares?: string;
}

/**
 * DelegationResponse is equivalent to Delegation except that it contains a
 * balance in addition to shares which is more suitable for client responses.
 */
export interface CosmosStakingV1Beta1DelegationResponse {
  /**
   * Delegation represents the bond with tokens held by an account. It is
   * owned by one delegator, and is associated with the voting power of one
   * validator.
   */
  delegation?: {
    /** delegator_address is the encoded address of the delegator. */
    delegator_address?: string;
    /** validator_address is the encoded address of the validator. */
    validator_address?: string;
    /** shares define the delegation shares received. */
    shares?: string;
  };
  /**
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  balance?: {
    denom?: string;
    amount?: string;
  };
}

/** Description defines a validator description. */
export interface CosmosStakingV1Beta1Description {
  /** moniker defines a human-readable name for the validator. */
  moniker?: string;
  /** identity defines an optional identity signature (ex. UPort or Keybase). */
  identity?: string;
  /** website defines an optional website link. */
  website?: string;
  /** security_contact defines an optional email for security contact. */
  security_contact?: string;
  /** details define other optional details. */
  details?: string;
}

/**
 * HistoricalInfo contains header and validator information for a given block.
 * It is stored as part of staking module's state, which persists the `n` most
 * recent HistoricalInfo
 * (`n` is set by the staking module's `historical_entries` parameter).
 */
export interface CosmosStakingV1Beta1HistoricalInfo {
  /** Header defines the structure of a block header. */
  header?: {
    /**
     * basic block info
     * Consensus captures the consensus rules for processing a block in the blockchain,
     * including all blockchain data structures and the rules of the application's
     * state transition machine.
     */
    version?: {
      /** @format uint64 */
      block?: string;
      /** @format uint64 */
      app?: string;
    };
    chain_id?: string;
    /** @format int64 */
    height?: string;
    /** @format date-time */
    time?: string;
    /** prev block info */
    last_block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    /**
     * hashes of block data
     * @format byte
     */
    last_commit_hash?: string;
    /** @format byte */
    data_hash?: string;
    /**
     * hashes from the app output from the prev block
     * @format byte
     */
    validators_hash?: string;
    /** @format byte */
    next_validators_hash?: string;
    /** @format byte */
    consensus_hash?: string;
    /** @format byte */
    app_hash?: string;
    /** @format byte */
    last_results_hash?: string;
    /**
     * consensus info
     * @format byte
     */
    evidence_hash?: string;
    /** @format byte */
    proposer_address?: string;
  };
  valset?: {
    /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
    operator_address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    consensus_pubkey?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** jailed defined whether the validator has been jailed from bonded status or not. */
    jailed?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @default "BOND_STATUS_UNSPECIFIED"
     */
    status?:
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** tokens define the delegated tokens (incl. self-delegation). */
    tokens?: string;
    /** delegator_shares defines total shares issued to a validator's delegators. */
    delegator_shares?: string;
    /** description defines the description terms for the validator. */
    description?: {
      /** moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** website defines an optional website link. */
      website?: string;
      /** security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** details define other optional details. */
      details?: string;
    };
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @format int64
     */
    unbonding_height?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @format date-time
     */
    unbonding_time?: string;
    /** commission defines the commission parameters. */
    commission?: {
      /** commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * update_time is the last time the commission rate was changed.
       * @format date-time
       */
      update_time?: string;
    };
    /**
     * min_self_delegation is the validator's self declared minimum self delegation.
     *
     * Since: cosmos-sdk 0.46
     */
    min_self_delegation?: string;
    /**
     * strictly positive if this validator's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
    /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
    unbonding_ids?: string[];
  }[];
}

/** Params defines the parameters for the x/staking module. */
export interface CosmosStakingV1Beta1Params {
  /** unbonding_time is the time duration of unbonding. */
  unbonding_time?: string;
  /**
   * max_validators is the maximum number of validators.
   * @format int64
   */
  max_validators?: number;
  /**
   * max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
   * @format int64
   */
  max_entries?: number;
  /**
   * historical_entries is the number of historical entries to persist.
   * @format int64
   */
  historical_entries?: number;
  /** bond_denom defines the bondable coin denomination. */
  bond_denom?: string;
  /** min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators */
  min_commission_rate?: string;
}

/**
 * Pool is used for tracking bonded and not-bonded token supply of the bond
 * denomination.
 */
export interface CosmosStakingV1Beta1Pool {
  not_bonded_tokens?: string;
  bonded_tokens?: string;
}

/** QueryDelegationResponse is response type for the Query/Delegation RPC method. */
export interface CosmosStakingV1Beta1QueryDelegationResponse {
  /**
   * DelegationResponse is equivalent to Delegation except that it contains a
   * balance in addition to shares which is more suitable for client responses.
   */
  delegation_response?: {
    /**
     * Delegation represents the bond with tokens held by an account. It is
     * owned by one delegator, and is associated with the voting power of one
     * validator.
     */
    delegation?: {
      /** delegator_address is the encoded address of the delegator. */
      delegator_address?: string;
      /** validator_address is the encoded address of the validator. */
      validator_address?: string;
      /** shares define the delegation shares received. */
      shares?: string;
    };
    /**
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    balance?: {
      denom?: string;
      amount?: string;
    };
  };
}

/**
 * QueryDelegatorDelegationsResponse is response type for the
 * Query/DelegatorDelegations RPC method.
 */
export interface CosmosStakingV1Beta1QueryDelegatorDelegationsResponse {
  /** delegation_responses defines all the delegations' info of a delegator. */
  delegation_responses?: {
    /**
     * Delegation represents the bond with tokens held by an account. It is
     * owned by one delegator, and is associated with the voting power of one
     * validator.
     */
    delegation?: {
      /** delegator_address is the encoded address of the delegator. */
      delegator_address?: string;
      /** validator_address is the encoded address of the validator. */
      validator_address?: string;
      /** shares define the delegation shares received. */
      shares?: string;
    };
    /**
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    balance?: {
      denom?: string;
      amount?: string;
    };
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the
 * Query/UnbondingDelegatorDelegations RPC method.
 */
export interface CosmosStakingV1Beta1QueryDelegatorUnbondingDelegationsResponse {
  unbonding_responses?: {
    /** delegator_address is the encoded address of the delegator. */
    delegator_address?: string;
    /** validator_address is the encoded address of the validator. */
    validator_address?: string;
    /** entries are the unbonding delegation entries. */
    entries?: {
      /**
       * creation_height is the height which the unbonding took place.
       * @format int64
       */
      creation_height?: string;
      /**
       * completion_time is the unix time for unbonding completion.
       * @format date-time
       */
      completion_time?: string;
      /** initial_balance defines the tokens initially scheduled to receive at completion. */
      initial_balance?: string;
      /** balance defines the tokens to receive at completion. */
      balance?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * @format uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * @format int64
       */
      unbonding_on_hold_ref_count?: string;
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryDelegatorValidatorResponse response type for the
 * Query/DelegatorValidator RPC method.
 */
export interface CosmosStakingV1Beta1QueryDelegatorValidatorResponse {
  /**
   * Validator defines a validator, together with the total amount of the
   * Validator's bond shares and their exchange rate to coins. Slashing results in
   * a decrease in the exchange rate, allowing correct calculation of future
   * undelegations without iterating over delegators. When coins are delegated to
   * this validator, the validator is credited with a delegation whose number of
   * bond shares is based on the amount of coins delegated divided by the current
   * exchange rate. Voting power can be calculated as total bonded shares
   * multiplied by exchange rate.
   */
  validator?: {
    /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
    operator_address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    consensus_pubkey?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** jailed defined whether the validator has been jailed from bonded status or not. */
    jailed?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @default "BOND_STATUS_UNSPECIFIED"
     */
    status?:
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** tokens define the delegated tokens (incl. self-delegation). */
    tokens?: string;
    /** delegator_shares defines total shares issued to a validator's delegators. */
    delegator_shares?: string;
    /** description defines the description terms for the validator. */
    description?: {
      /** moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** website defines an optional website link. */
      website?: string;
      /** security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** details define other optional details. */
      details?: string;
    };
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @format int64
     */
    unbonding_height?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @format date-time
     */
    unbonding_time?: string;
    /** commission defines the commission parameters. */
    commission?: {
      /** commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * update_time is the last time the commission rate was changed.
       * @format date-time
       */
      update_time?: string;
    };
    /**
     * min_self_delegation is the validator's self declared minimum self delegation.
     *
     * Since: cosmos-sdk 0.46
     */
    min_self_delegation?: string;
    /**
     * strictly positive if this validator's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
    /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
    unbonding_ids?: string[];
  };
}

/**
 * QueryDelegatorValidatorsResponse is response type for the
 * Query/DelegatorValidators RPC method.
 */
export interface CosmosStakingV1Beta1QueryDelegatorValidatorsResponse {
  /** validators defines the validators' info of a delegator. */
  validators?: {
    /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
    operator_address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    consensus_pubkey?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** jailed defined whether the validator has been jailed from bonded status or not. */
    jailed?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @default "BOND_STATUS_UNSPECIFIED"
     */
    status?:
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** tokens define the delegated tokens (incl. self-delegation). */
    tokens?: string;
    /** delegator_shares defines total shares issued to a validator's delegators. */
    delegator_shares?: string;
    /** description defines the description terms for the validator. */
    description?: {
      /** moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** website defines an optional website link. */
      website?: string;
      /** security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** details define other optional details. */
      details?: string;
    };
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @format int64
     */
    unbonding_height?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @format date-time
     */
    unbonding_time?: string;
    /** commission defines the commission parameters. */
    commission?: {
      /** commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * update_time is the last time the commission rate was changed.
       * @format date-time
       */
      update_time?: string;
    };
    /**
     * min_self_delegation is the validator's self declared minimum self delegation.
     *
     * Since: cosmos-sdk 0.46
     */
    min_self_delegation?: string;
    /**
     * strictly positive if this validator's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
    /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
    unbonding_ids?: string[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
 * method.
 */
export interface CosmosStakingV1Beta1QueryHistoricalInfoResponse {
  /** hist defines the historical info at the given height. */
  hist?: {
    /** Header defines the structure of a block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** prev block info */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /** @format byte */
      proposer_address?: string;
    };
    valset?: {
      /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
      operator_address?: string;
      /**
       * `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *     // or ...
       *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
       *       foo = any.unpack(Foo.getDefaultInstance());
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      consensus_pubkey?: {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Must be a valid serialized protocol buffer of the above specified type.
         * @format byte
         */
        value?: string;
      };
      /** jailed defined whether the validator has been jailed from bonded status or not. */
      jailed?: boolean;
      /**
       * status is the validator status (bonded/unbonding/unbonded).
       * @default "BOND_STATUS_UNSPECIFIED"
       */
      status?:
        | "BOND_STATUS_UNSPECIFIED"
        | "BOND_STATUS_UNBONDED"
        | "BOND_STATUS_UNBONDING"
        | "BOND_STATUS_BONDED";
      /** tokens define the delegated tokens (incl. self-delegation). */
      tokens?: string;
      /** delegator_shares defines total shares issued to a validator's delegators. */
      delegator_shares?: string;
      /** description defines the description terms for the validator. */
      description?: {
        /** moniker defines a human-readable name for the validator. */
        moniker?: string;
        /** identity defines an optional identity signature (ex. UPort or Keybase). */
        identity?: string;
        /** website defines an optional website link. */
        website?: string;
        /** security_contact defines an optional email for security contact. */
        security_contact?: string;
        /** details define other optional details. */
        details?: string;
      };
      /**
       * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
       * @format int64
       */
      unbonding_height?: string;
      /**
       * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
       * @format date-time
       */
      unbonding_time?: string;
      /** commission defines the commission parameters. */
      commission?: {
        /** commission_rates defines the initial commission rates to be used for creating a validator. */
        commission_rates?: {
          /** rate is the commission rate charged to delegators, as a fraction. */
          rate?: string;
          /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
          max_rate?: string;
          /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
          max_change_rate?: string;
        };
        /**
         * update_time is the last time the commission rate was changed.
         * @format date-time
         */
        update_time?: string;
      };
      /**
       * min_self_delegation is the validator's self declared minimum self delegation.
       *
       * Since: cosmos-sdk 0.46
       */
      min_self_delegation?: string;
      /**
       * strictly positive if this validator's unbonding has been stopped by external modules
       * @format int64
       */
      unbonding_on_hold_ref_count?: string;
      /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
      unbonding_ids?: string[];
    }[];
  };
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface CosmosStakingV1Beta1QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params?: {
    /** unbonding_time is the time duration of unbonding. */
    unbonding_time?: string;
    /**
     * max_validators is the maximum number of validators.
     * @format int64
     */
    max_validators?: number;
    /**
     * max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
     * @format int64
     */
    max_entries?: number;
    /**
     * historical_entries is the number of historical entries to persist.
     * @format int64
     */
    historical_entries?: number;
    /** bond_denom defines the bondable coin denomination. */
    bond_denom?: string;
    /** min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators */
    min_commission_rate?: string;
  };
}

/** QueryPoolResponse is response type for the Query/Pool RPC method. */
export interface CosmosStakingV1Beta1QueryPoolResponse {
  /** pool defines the pool info. */
  pool?: {
    not_bonded_tokens?: string;
    bonded_tokens?: string;
  };
}

/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC
 * method.
 */
export interface CosmosStakingV1Beta1QueryRedelegationsResponse {
  redelegation_responses?: {
    /**
     * Redelegation contains the list of a particular delegator's redelegating bonds
     * from a particular source validator to a particular destination validator.
     */
    redelegation?: {
      /** delegator_address is the bech32-encoded address of the delegator. */
      delegator_address?: string;
      /** validator_src_address is the validator redelegation source operator address. */
      validator_src_address?: string;
      /** validator_dst_address is the validator redelegation destination operator address. */
      validator_dst_address?: string;
      /** entries are the redelegation entries. */
      entries?: {
        /**
         * creation_height  defines the height which the redelegation took place.
         * @format int64
         */
        creation_height?: string;
        /**
         * completion_time defines the unix time for redelegation completion.
         * @format date-time
         */
        completion_time?: string;
        /** initial_balance defines the initial balance when redelegation started. */
        initial_balance?: string;
        /** shares_dst is the amount of destination-validator shares created by redelegation. */
        shares_dst?: string;
        /**
         * Incrementing id that uniquely identifies this entry
         * @format uint64
         */
        unbonding_id?: string;
        /**
         * Strictly positive if this entry's unbonding has been stopped by external modules
         * @format int64
         */
        unbonding_on_hold_ref_count?: string;
      }[];
    };
    entries?: {
      /** RedelegationEntry defines a redelegation object with relevant metadata. */
      redelegation_entry?: {
        /**
         * creation_height  defines the height which the redelegation took place.
         * @format int64
         */
        creation_height?: string;
        /**
         * completion_time defines the unix time for redelegation completion.
         * @format date-time
         */
        completion_time?: string;
        /** initial_balance defines the initial balance when redelegation started. */
        initial_balance?: string;
        /** shares_dst is the amount of destination-validator shares created by redelegation. */
        shares_dst?: string;
        /**
         * Incrementing id that uniquely identifies this entry
         * @format uint64
         */
        unbonding_id?: string;
        /**
         * Strictly positive if this entry's unbonding has been stopped by external modules
         * @format int64
         */
        unbonding_on_hold_ref_count?: string;
      };
      balance?: string;
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation
 * RPC method.
 */
export interface CosmosStakingV1Beta1QueryUnbondingDelegationResponse {
  /**
   * UnbondingDelegation stores all of a single delegator's unbonding bonds
   * for a single validator in an time-ordered list.
   */
  unbond?: {
    /** delegator_address is the encoded address of the delegator. */
    delegator_address?: string;
    /** validator_address is the encoded address of the validator. */
    validator_address?: string;
    /** entries are the unbonding delegation entries. */
    entries?: {
      /**
       * creation_height is the height which the unbonding took place.
       * @format int64
       */
      creation_height?: string;
      /**
       * completion_time is the unix time for unbonding completion.
       * @format date-time
       */
      completion_time?: string;
      /** initial_balance defines the tokens initially scheduled to receive at completion. */
      initial_balance?: string;
      /** balance defines the tokens to receive at completion. */
      balance?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * @format uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * @format int64
       */
      unbonding_on_hold_ref_count?: string;
    }[];
  };
}

/**
 * QueryValidatorDelegationsResponse is response type for the
 * Query/ValidatorDelegations RPC method
 */
export interface CosmosStakingV1Beta1QueryValidatorDelegationsResponse {
  delegation_responses?: {
    /**
     * Delegation represents the bond with tokens held by an account. It is
     * owned by one delegator, and is associated with the voting power of one
     * validator.
     */
    delegation?: {
      /** delegator_address is the encoded address of the delegator. */
      delegator_address?: string;
      /** validator_address is the encoded address of the validator. */
      validator_address?: string;
      /** shares define the delegation shares received. */
      shares?: string;
    };
    /**
     * Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    balance?: {
      denom?: string;
      amount?: string;
    };
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryValidatorResponse is response type for the Query/Validator RPC method */
export interface CosmosStakingV1Beta1QueryValidatorResponse {
  /**
   * Validator defines a validator, together with the total amount of the
   * Validator's bond shares and their exchange rate to coins. Slashing results in
   * a decrease in the exchange rate, allowing correct calculation of future
   * undelegations without iterating over delegators. When coins are delegated to
   * this validator, the validator is credited with a delegation whose number of
   * bond shares is based on the amount of coins delegated divided by the current
   * exchange rate. Voting power can be calculated as total bonded shares
   * multiplied by exchange rate.
   */
  validator?: {
    /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
    operator_address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    consensus_pubkey?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** jailed defined whether the validator has been jailed from bonded status or not. */
    jailed?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @default "BOND_STATUS_UNSPECIFIED"
     */
    status?:
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** tokens define the delegated tokens (incl. self-delegation). */
    tokens?: string;
    /** delegator_shares defines total shares issued to a validator's delegators. */
    delegator_shares?: string;
    /** description defines the description terms for the validator. */
    description?: {
      /** moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** website defines an optional website link. */
      website?: string;
      /** security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** details define other optional details. */
      details?: string;
    };
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @format int64
     */
    unbonding_height?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @format date-time
     */
    unbonding_time?: string;
    /** commission defines the commission parameters. */
    commission?: {
      /** commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * update_time is the last time the commission rate was changed.
       * @format date-time
       */
      update_time?: string;
    };
    /**
     * min_self_delegation is the validator's self declared minimum self delegation.
     *
     * Since: cosmos-sdk 0.46
     */
    min_self_delegation?: string;
    /**
     * strictly positive if this validator's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
    /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
    unbonding_ids?: string[];
  };
}

/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the
 * Query/ValidatorUnbondingDelegations RPC method.
 */
export interface CosmosStakingV1Beta1QueryValidatorUnbondingDelegationsResponse {
  unbonding_responses?: {
    /** delegator_address is the encoded address of the delegator. */
    delegator_address?: string;
    /** validator_address is the encoded address of the validator. */
    validator_address?: string;
    /** entries are the unbonding delegation entries. */
    entries?: {
      /**
       * creation_height is the height which the unbonding took place.
       * @format int64
       */
      creation_height?: string;
      /**
       * completion_time is the unix time for unbonding completion.
       * @format date-time
       */
      completion_time?: string;
      /** initial_balance defines the tokens initially scheduled to receive at completion. */
      initial_balance?: string;
      /** balance defines the tokens to receive at completion. */
      balance?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * @format uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * @format int64
       */
      unbonding_on_hold_ref_count?: string;
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryValidatorsResponse is response type for the Query/Validators RPC method */
export interface CosmosStakingV1Beta1QueryValidatorsResponse {
  /** validators contains all the queried validators. */
  validators?: {
    /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
    operator_address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    consensus_pubkey?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** jailed defined whether the validator has been jailed from bonded status or not. */
    jailed?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @default "BOND_STATUS_UNSPECIFIED"
     */
    status?:
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** tokens define the delegated tokens (incl. self-delegation). */
    tokens?: string;
    /** delegator_shares defines total shares issued to a validator's delegators. */
    delegator_shares?: string;
    /** description defines the description terms for the validator. */
    description?: {
      /** moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** website defines an optional website link. */
      website?: string;
      /** security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** details define other optional details. */
      details?: string;
    };
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @format int64
     */
    unbonding_height?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @format date-time
     */
    unbonding_time?: string;
    /** commission defines the commission parameters. */
    commission?: {
      /** commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * update_time is the last time the commission rate was changed.
       * @format date-time
       */
      update_time?: string;
    };
    /**
     * min_self_delegation is the validator's self declared minimum self delegation.
     *
     * Since: cosmos-sdk 0.46
     */
    min_self_delegation?: string;
    /**
     * strictly positive if this validator's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
    /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
    unbonding_ids?: string[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * Redelegation contains the list of a particular delegator's redelegating bonds
 * from a particular source validator to a particular destination validator.
 */
export interface CosmosStakingV1Beta1Redelegation {
  /** delegator_address is the bech32-encoded address of the delegator. */
  delegator_address?: string;
  /** validator_src_address is the validator redelegation source operator address. */
  validator_src_address?: string;
  /** validator_dst_address is the validator redelegation destination operator address. */
  validator_dst_address?: string;
  /** entries are the redelegation entries. */
  entries?: {
    /**
     * creation_height  defines the height which the redelegation took place.
     * @format int64
     */
    creation_height?: string;
    /**
     * completion_time defines the unix time for redelegation completion.
     * @format date-time
     */
    completion_time?: string;
    /** initial_balance defines the initial balance when redelegation started. */
    initial_balance?: string;
    /** shares_dst is the amount of destination-validator shares created by redelegation. */
    shares_dst?: string;
    /**
     * Incrementing id that uniquely identifies this entry
     * @format uint64
     */
    unbonding_id?: string;
    /**
     * Strictly positive if this entry's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
  }[];
}

/** RedelegationEntry defines a redelegation object with relevant metadata. */
export interface CosmosStakingV1Beta1RedelegationEntry {
  /**
   * creation_height  defines the height which the redelegation took place.
   * @format int64
   */
  creation_height?: string;
  /**
   * completion_time defines the unix time for redelegation completion.
   * @format date-time
   */
  completion_time?: string;
  /** initial_balance defines the initial balance when redelegation started. */
  initial_balance?: string;
  /** shares_dst is the amount of destination-validator shares created by redelegation. */
  shares_dst?: string;
  /**
   * Incrementing id that uniquely identifies this entry
   * @format uint64
   */
  unbonding_id?: string;
  /**
   * Strictly positive if this entry's unbonding has been stopped by external modules
   * @format int64
   */
  unbonding_on_hold_ref_count?: string;
}

/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
 * contains a balance in addition to shares which is more suitable for client
 * responses.
 */
export interface CosmosStakingV1Beta1RedelegationEntryResponse {
  /** RedelegationEntry defines a redelegation object with relevant metadata. */
  redelegation_entry?: {
    /**
     * creation_height  defines the height which the redelegation took place.
     * @format int64
     */
    creation_height?: string;
    /**
     * completion_time defines the unix time for redelegation completion.
     * @format date-time
     */
    completion_time?: string;
    /** initial_balance defines the initial balance when redelegation started. */
    initial_balance?: string;
    /** shares_dst is the amount of destination-validator shares created by redelegation. */
    shares_dst?: string;
    /**
     * Incrementing id that uniquely identifies this entry
     * @format uint64
     */
    unbonding_id?: string;
    /**
     * Strictly positive if this entry's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
  };
  balance?: string;
}

/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries
 * contain a balance in addition to shares which is more suitable for client
 * responses.
 */
export interface CosmosStakingV1Beta1RedelegationResponse {
  /**
   * Redelegation contains the list of a particular delegator's redelegating bonds
   * from a particular source validator to a particular destination validator.
   */
  redelegation?: {
    /** delegator_address is the bech32-encoded address of the delegator. */
    delegator_address?: string;
    /** validator_src_address is the validator redelegation source operator address. */
    validator_src_address?: string;
    /** validator_dst_address is the validator redelegation destination operator address. */
    validator_dst_address?: string;
    /** entries are the redelegation entries. */
    entries?: {
      /**
       * creation_height  defines the height which the redelegation took place.
       * @format int64
       */
      creation_height?: string;
      /**
       * completion_time defines the unix time for redelegation completion.
       * @format date-time
       */
      completion_time?: string;
      /** initial_balance defines the initial balance when redelegation started. */
      initial_balance?: string;
      /** shares_dst is the amount of destination-validator shares created by redelegation. */
      shares_dst?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * @format uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * @format int64
       */
      unbonding_on_hold_ref_count?: string;
    }[];
  };
  entries?: {
    /** RedelegationEntry defines a redelegation object with relevant metadata. */
    redelegation_entry?: {
      /**
       * creation_height  defines the height which the redelegation took place.
       * @format int64
       */
      creation_height?: string;
      /**
       * completion_time defines the unix time for redelegation completion.
       * @format date-time
       */
      completion_time?: string;
      /** initial_balance defines the initial balance when redelegation started. */
      initial_balance?: string;
      /** shares_dst is the amount of destination-validator shares created by redelegation. */
      shares_dst?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * @format uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * @format int64
       */
      unbonding_on_hold_ref_count?: string;
    };
    balance?: string;
  }[];
}

/**
 * UnbondingDelegation stores all of a single delegator's unbonding bonds
 * for a single validator in an time-ordered list.
 */
export interface CosmosStakingV1Beta1UnbondingDelegation {
  /** delegator_address is the encoded address of the delegator. */
  delegator_address?: string;
  /** validator_address is the encoded address of the validator. */
  validator_address?: string;
  /** entries are the unbonding delegation entries. */
  entries?: {
    /**
     * creation_height is the height which the unbonding took place.
     * @format int64
     */
    creation_height?: string;
    /**
     * completion_time is the unix time for unbonding completion.
     * @format date-time
     */
    completion_time?: string;
    /** initial_balance defines the tokens initially scheduled to receive at completion. */
    initial_balance?: string;
    /** balance defines the tokens to receive at completion. */
    balance?: string;
    /**
     * Incrementing id that uniquely identifies this entry
     * @format uint64
     */
    unbonding_id?: string;
    /**
     * Strictly positive if this entry's unbonding has been stopped by external modules
     * @format int64
     */
    unbonding_on_hold_ref_count?: string;
  }[];
}

/** UnbondingDelegationEntry defines an unbonding object with relevant metadata. */
export interface CosmosStakingV1Beta1UnbondingDelegationEntry {
  /**
   * creation_height is the height which the unbonding took place.
   * @format int64
   */
  creation_height?: string;
  /**
   * completion_time is the unix time for unbonding completion.
   * @format date-time
   */
  completion_time?: string;
  /** initial_balance defines the tokens initially scheduled to receive at completion. */
  initial_balance?: string;
  /** balance defines the tokens to receive at completion. */
  balance?: string;
  /**
   * Incrementing id that uniquely identifies this entry
   * @format uint64
   */
  unbonding_id?: string;
  /**
   * Strictly positive if this entry's unbonding has been stopped by external modules
   * @format int64
   */
  unbonding_on_hold_ref_count?: string;
}

/**
 * Validator defines a validator, together with the total amount of the
 * Validator's bond shares and their exchange rate to coins. Slashing results in
 * a decrease in the exchange rate, allowing correct calculation of future
 * undelegations without iterating over delegators. When coins are delegated to
 * this validator, the validator is credited with a delegation whose number of
 * bond shares is based on the amount of coins delegated divided by the current
 * exchange rate. Voting power can be calculated as total bonded shares
 * multiplied by exchange rate.
 */
export interface CosmosStakingV1Beta1Validator {
  /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
  operator_address?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  consensus_pubkey?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /** jailed defined whether the validator has been jailed from bonded status or not. */
  jailed?: boolean;
  /**
   * status is the validator status (bonded/unbonding/unbonded).
   * @default "BOND_STATUS_UNSPECIFIED"
   */
  status?:
    | "BOND_STATUS_UNSPECIFIED"
    | "BOND_STATUS_UNBONDED"
    | "BOND_STATUS_UNBONDING"
    | "BOND_STATUS_BONDED";
  /** tokens define the delegated tokens (incl. self-delegation). */
  tokens?: string;
  /** delegator_shares defines total shares issued to a validator's delegators. */
  delegator_shares?: string;
  /** description defines the description terms for the validator. */
  description?: {
    /** moniker defines a human-readable name for the validator. */
    moniker?: string;
    /** identity defines an optional identity signature (ex. UPort or Keybase). */
    identity?: string;
    /** website defines an optional website link. */
    website?: string;
    /** security_contact defines an optional email for security contact. */
    security_contact?: string;
    /** details define other optional details. */
    details?: string;
  };
  /**
   * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
   * @format int64
   */
  unbonding_height?: string;
  /**
   * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
   * @format date-time
   */
  unbonding_time?: string;
  /** commission defines the commission parameters. */
  commission?: {
    /** commission_rates defines the initial commission rates to be used for creating a validator. */
    commission_rates?: {
      /** rate is the commission rate charged to delegators, as a fraction. */
      rate?: string;
      /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
      max_rate?: string;
      /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
      max_change_rate?: string;
    };
    /**
     * update_time is the last time the commission rate was changed.
     * @format date-time
     */
    update_time?: string;
  };
  /**
   * min_self_delegation is the validator's self declared minimum self delegation.
   *
   * Since: cosmos-sdk 0.46
   */
  min_self_delegation?: string;
  /**
   * strictly positive if this validator's unbonding has been stopped by external modules
   * @format int64
   */
  unbonding_on_hold_ref_count?: string;
  /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
  unbonding_ids?: string[];
}

/** BlockID */
export interface TendermintTypesBlockID {
  /** @format byte */
  hash?: string;
  /** PartsetHeader */
  part_set_header?: {
    /** @format int64 */
    total?: number;
    /** @format byte */
    hash?: string;
  };
}

/** Header defines the structure of a block header. */
export interface TendermintTypesHeader {
  /**
   * basic block info
   * Consensus captures the consensus rules for processing a block in the blockchain,
   * including all blockchain data structures and the rules of the application's
   * state transition machine.
   */
  version?: {
    /** @format uint64 */
    block?: string;
    /** @format uint64 */
    app?: string;
  };
  chain_id?: string;
  /** @format int64 */
  height?: string;
  /** @format date-time */
  time?: string;
  /** prev block info */
  last_block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  /**
   * hashes of block data
   * @format byte
   */
  last_commit_hash?: string;
  /** @format byte */
  data_hash?: string;
  /**
   * hashes from the app output from the prev block
   * @format byte
   */
  validators_hash?: string;
  /** @format byte */
  next_validators_hash?: string;
  /** @format byte */
  consensus_hash?: string;
  /** @format byte */
  app_hash?: string;
  /** @format byte */
  last_results_hash?: string;
  /**
   * consensus info
   * @format byte
   */
  evidence_hash?: string;
  /** @format byte */
  proposer_address?: string;
}

/** PartsetHeader */
export interface TendermintTypesPartSetHeader {
  /** @format int64 */
  total?: number;
  /** @format byte */
  hash?: string;
}

/**
 * Consensus captures the consensus rules for processing a block in the blockchain,
 * including all blockchain data structures and the rules of the application's
 * state transition machine.
 */
export interface TendermintVersionConsensus {
  /** @format uint64 */
  block?: string;
  /** @format uint64 */
  app?: string;
}

/**
 * ModuleVersion specifies a module and its consensus version.
 *
 * Since: cosmos-sdk 0.43
 */
export interface CosmosUpgradeV1Beta1ModuleVersion {
  /** name of the app module */
  name?: string;
  /**
   * consensus version of the app module
   * @format uint64
   */
  version?: string;
}

/** Plan specifies information about a planned upgrade and when it should occur. */
export interface CosmosUpgradeV1Beta1Plan {
  /**
   * Sets the name for the upgrade. This name will be used by the upgraded
   * version of the software to apply any special "on-upgrade" commands during
   * the first BeginBlock method after the upgrade is applied. It is also used
   * to detect whether a software version can handle a given upgrade. If no
   * upgrade handler with this name has been set in the software, it will be
   * assumed that the software is out-of-date when the upgrade Time or Height is
   * reached and the software will exit.
   */
  name?: string;
  /**
   * Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
   * has been removed from the SDK.
   * If this field is not empty, an error will be thrown.
   * @format date-time
   */
  time?: string;
  /**
   * The height at which the upgrade must be performed.
   * @format int64
   */
  height?: string;
  /**
   * Any application specific upgrade info to be included on-chain
   * such as a git commit that validators could automatically upgrade to
   */
  info?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  upgraded_client_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/**
 * QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC
 * method.
 */
export interface CosmosUpgradeV1Beta1QueryAppliedPlanResponse {
  /**
   * height is the block height at which the plan was applied.
   * @format int64
   */
  height?: string;
}

/**
 * QueryAuthorityResponse is the response type for Query/Authority
 * Since: cosmos-sdk 0.46
 */
export interface CosmosUpgradeV1Beta1QueryAuthorityResponse {
  address?: string;
}

/**
 * QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC
 * method.
 */
export interface CosmosUpgradeV1Beta1QueryCurrentPlanResponse {
  /** plan is the current upgrade plan. */
  plan?: {
    /**
     * Sets the name for the upgrade. This name will be used by the upgraded
     * version of the software to apply any special "on-upgrade" commands during
     * the first BeginBlock method after the upgrade is applied. It is also used
     * to detect whether a software version can handle a given upgrade. If no
     * upgrade handler with this name has been set in the software, it will be
     * assumed that the software is out-of-date when the upgrade Time or Height is
     * reached and the software will exit.
     */
    name?: string;
    /**
     * Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
     * has been removed from the SDK.
     * If this field is not empty, an error will be thrown.
     * @format date-time
     */
    time?: string;
    /**
     * The height at which the upgrade must be performed.
     * @format int64
     */
    height?: string;
    /**
     * Any application specific upgrade info to be included on-chain
     * such as a git commit that validators could automatically upgrade to
     */
    info?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    upgraded_client_state?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  };
}

/**
 * QueryModuleVersionsResponse is the response type for the Query/ModuleVersions
 * RPC method.
 *
 * Since: cosmos-sdk 0.43
 */
export interface CosmosUpgradeV1Beta1QueryModuleVersionsResponse {
  /** module_versions is a list of module names with their consensus versions. */
  module_versions?: {
    /** name of the app module */
    name?: string;
    /**
     * consensus version of the app module
     * @format uint64
     */
    version?: string;
  }[];
}

/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState
 * RPC method.
 */
export interface CosmosUpgradeV1Beta1QueryUpgradedConsensusStateResponse {
  /**
   * Since: cosmos-sdk 0.43
   * @format byte
   */
  upgraded_consensus_state?: string;
}

/**
 * ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.
 *
 * Note: This type is a duplicate of the ResponseQuery proto type defined in
 * Tendermint.
 */
export interface CosmosBaseTendermintV1Beta1ABCIQueryResponse {
  /** @format int64 */
  code?: number;
  log?: string;
  info?: string;
  /** @format int64 */
  index?: string;
  /** @format byte */
  key?: string;
  /** @format byte */
  value?: string;
  /**
   * ProofOps is Merkle proof defined by the list of ProofOps.
   *
   * Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
   */
  proof_ops?: {
    ops?: {
      type?: string;
      /** @format byte */
      key?: string;
      /** @format byte */
      data?: string;
    }[];
  };
  /** @format int64 */
  height?: string;
  codespace?: string;
}

/**
 * Block is tendermint type Block, with the Header proposer address
 * field converted to bech32 string.
 */
export interface CosmosBaseTendermintV1Beta1Block {
  /** Header defines the structure of a Tendermint block header. */
  header?: {
    /**
     * basic block info
     * Consensus captures the consensus rules for processing a block in the blockchain,
     * including all blockchain data structures and the rules of the application's
     * state transition machine.
     */
    version?: {
      /** @format uint64 */
      block?: string;
      /** @format uint64 */
      app?: string;
    };
    chain_id?: string;
    /** @format int64 */
    height?: string;
    /** @format date-time */
    time?: string;
    /** BlockID */
    last_block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    /**
     * hashes of block data
     * @format byte
     */
    last_commit_hash?: string;
    /** @format byte */
    data_hash?: string;
    /**
     * hashes from the app output from the prev block
     * @format byte
     */
    validators_hash?: string;
    /** @format byte */
    next_validators_hash?: string;
    /** @format byte */
    consensus_hash?: string;
    /** @format byte */
    app_hash?: string;
    /** @format byte */
    last_results_hash?: string;
    /**
     * consensus info
     * @format byte
     */
    evidence_hash?: string;
    /**
     * proposer_address is the original block proposer address, formatted as a Bech32 string.
     * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
     * for better UX.
     */
    proposer_address?: string;
  };
  /** Data contains the set of transactions included in the block */
  data?: {
    /**
     * Txs that will be applied by state @ block.Height+1.
     * NOTE: not all txs here are valid.  We're just agreeing on the order first.
     * This means that block.AppHash does not include these txs.
     */
    txs?: string[];
  };
  evidence?: {
    evidence?: {
      /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
      duplicate_vote_evidence?: {
        /**
         * Vote represents a prevote or precommit vote from validators for
         * consensus.
         */
        vote_a?: {
          /**
           * SignedMsgType is a type of signed message in the consensus.
           *
           *  - SIGNED_MSG_TYPE_PREVOTE: Votes
           *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default "SIGNED_MSG_TYPE_UNKNOWN"
           */
          type?:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** @format int64 */
          height?: string;
          /** @format int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /** @format date-time */
          timestamp?: string;
          /** @format byte */
          validator_address?: string;
          /** @format int32 */
          validator_index?: number;
          /**
           * Vote signature by the validator if they participated in consensus for the
           * associated block.
           * @format byte
           */
          signature?: string;
          /**
           * Vote extension provided by the application. Only valid for precommit
           * messages.
           * @format byte
           */
          extension?: string;
          /**
           * Vote extension signature by the validator if they participated in
           * consensus for the associated block.
           * Only valid for precommit messages.
           * @format byte
           */
          extension_signature?: string;
        };
        /**
         * Vote represents a prevote or precommit vote from validators for
         * consensus.
         */
        vote_b?: {
          /**
           * SignedMsgType is a type of signed message in the consensus.
           *
           *  - SIGNED_MSG_TYPE_PREVOTE: Votes
           *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default "SIGNED_MSG_TYPE_UNKNOWN"
           */
          type?:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** @format int64 */
          height?: string;
          /** @format int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /** @format date-time */
          timestamp?: string;
          /** @format byte */
          validator_address?: string;
          /** @format int32 */
          validator_index?: number;
          /**
           * Vote signature by the validator if they participated in consensus for the
           * associated block.
           * @format byte
           */
          signature?: string;
          /**
           * Vote extension provided by the application. Only valid for precommit
           * messages.
           * @format byte
           */
          extension?: string;
          /**
           * Vote extension signature by the validator if they participated in
           * consensus for the associated block.
           * Only valid for precommit messages.
           * @format byte
           */
          extension_signature?: string;
        };
        /** @format int64 */
        total_voting_power?: string;
        /** @format int64 */
        validator_power?: string;
        /** @format date-time */
        timestamp?: string;
      };
      /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
      light_client_attack_evidence?: {
        conflicting_block?: {
          signed_header?: {
            /** Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /** @format byte */
              proposer_address?: string;
            };
            /** Commit contains the evidence that a block was committed by a set of validators. */
            commit?: {
              /** @format int64 */
              height?: string;
              /** @format int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default "BLOCK_ID_FLAG_UNKNOWN"
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** @format byte */
                validator_address?: string;
                /** @format date-time */
                timestamp?: string;
                /** @format byte */
                signature?: string;
              }[];
            };
          };
          validator_set?: {
            validators?: {
              /** @format byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** @format byte */
                ed25519?: string;
                /** @format byte */
                secp256k1?: string;
              };
              /** @format int64 */
              voting_power?: string;
              /** @format int64 */
              proposer_priority?: string;
            }[];
            proposer?: {
              /** @format byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** @format byte */
                ed25519?: string;
                /** @format byte */
                secp256k1?: string;
              };
              /** @format int64 */
              voting_power?: string;
              /** @format int64 */
              proposer_priority?: string;
            };
            /** @format int64 */
            total_voting_power?: string;
          };
        };
        /** @format int64 */
        common_height?: string;
        byzantine_validators?: {
          /** @format byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** @format byte */
            ed25519?: string;
            /** @format byte */
            secp256k1?: string;
          };
          /** @format int64 */
          voting_power?: string;
          /** @format int64 */
          proposer_priority?: string;
        }[];
        /** @format int64 */
        total_voting_power?: string;
        /** @format date-time */
        timestamp?: string;
      };
    }[];
  };
  /** Commit contains the evidence that a block was committed by a set of validators. */
  last_commit?: {
    /** @format int64 */
    height?: string;
    /** @format int32 */
    round?: number;
    /** BlockID */
    block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    signatures?: {
      /**
       * BlockIdFlag indicates which BlockID the signature is for
       * @default "BLOCK_ID_FLAG_UNKNOWN"
       */
      block_id_flag?:
        | "BLOCK_ID_FLAG_UNKNOWN"
        | "BLOCK_ID_FLAG_ABSENT"
        | "BLOCK_ID_FLAG_COMMIT"
        | "BLOCK_ID_FLAG_NIL";
      /** @format byte */
      validator_address?: string;
      /** @format date-time */
      timestamp?: string;
      /** @format byte */
      signature?: string;
    }[];
  };
}

/** GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method. */
export interface CosmosBaseTendermintV1Beta1GetBlockByHeightResponse {
  /** BlockID */
  block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  /** Deprecated: please use `sdk_block` instead */
  block?: {
    /** Header defines the structure of a block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /** @format byte */
      proposer_address?: string;
    };
    /** Data contains the set of transactions included in the block */
    data?: {
      /**
       * Txs that will be applied by state @ block.Height+1.
       * NOTE: not all txs here are valid.  We're just agreeing on the order first.
       * This means that block.AppHash does not include these txs.
       */
      txs?: string[];
    };
    evidence?: {
      evidence?: {
        /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_a?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_b?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /** @format int64 */
          total_voting_power?: string;
          /** @format int64 */
          validator_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
        /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** @format uint64 */
                  block?: string;
                  /** @format uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** @format int64 */
                height?: string;
                /** @format date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * @format byte
                 */
                last_commit_hash?: string;
                /** @format byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * @format byte
                 */
                validators_hash?: string;
                /** @format byte */
                next_validators_hash?: string;
                /** @format byte */
                consensus_hash?: string;
                /** @format byte */
                app_hash?: string;
                /** @format byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * @format byte
                 */
                evidence_hash?: string;
                /** @format byte */
                proposer_address?: string;
              };
              /** Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** @format int64 */
                height?: string;
                /** @format int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default "BLOCK_ID_FLAG_UNKNOWN"
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** @format byte */
                  validator_address?: string;
                  /** @format date-time */
                  timestamp?: string;
                  /** @format byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              };
              /** @format int64 */
              total_voting_power?: string;
            };
          };
          /** @format int64 */
          common_height?: string;
          byzantine_validators?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** @format int64 */
          total_voting_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
      }[];
    };
    /** Commit contains the evidence that a block was committed by a set of validators. */
    last_commit?: {
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default "BLOCK_ID_FLAG_UNKNOWN"
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** @format byte */
        validator_address?: string;
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        signature?: string;
      }[];
    };
  };
  /**
   * Since: cosmos-sdk 0.47
   * Block is tendermint type Block, with the Header proposer address
   * field converted to bech32 string.
   */
  sdk_block?: {
    /** Header defines the structure of a Tendermint block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /**
       * proposer_address is the original block proposer address, formatted as a Bech32 string.
       * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
       * for better UX.
       */
      proposer_address?: string;
    };
    /** Data contains the set of transactions included in the block */
    data?: {
      /**
       * Txs that will be applied by state @ block.Height+1.
       * NOTE: not all txs here are valid.  We're just agreeing on the order first.
       * This means that block.AppHash does not include these txs.
       */
      txs?: string[];
    };
    evidence?: {
      evidence?: {
        /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_a?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_b?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /** @format int64 */
          total_voting_power?: string;
          /** @format int64 */
          validator_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
        /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** @format uint64 */
                  block?: string;
                  /** @format uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** @format int64 */
                height?: string;
                /** @format date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * @format byte
                 */
                last_commit_hash?: string;
                /** @format byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * @format byte
                 */
                validators_hash?: string;
                /** @format byte */
                next_validators_hash?: string;
                /** @format byte */
                consensus_hash?: string;
                /** @format byte */
                app_hash?: string;
                /** @format byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * @format byte
                 */
                evidence_hash?: string;
                /** @format byte */
                proposer_address?: string;
              };
              /** Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** @format int64 */
                height?: string;
                /** @format int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default "BLOCK_ID_FLAG_UNKNOWN"
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** @format byte */
                  validator_address?: string;
                  /** @format date-time */
                  timestamp?: string;
                  /** @format byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              };
              /** @format int64 */
              total_voting_power?: string;
            };
          };
          /** @format int64 */
          common_height?: string;
          byzantine_validators?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** @format int64 */
          total_voting_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
      }[];
    };
    /** Commit contains the evidence that a block was committed by a set of validators. */
    last_commit?: {
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default "BLOCK_ID_FLAG_UNKNOWN"
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** @format byte */
        validator_address?: string;
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        signature?: string;
      }[];
    };
  };
}

/** GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method. */
export interface CosmosBaseTendermintV1Beta1GetLatestBlockResponse {
  /** BlockID */
  block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  /** Deprecated: please use `sdk_block` instead */
  block?: {
    /** Header defines the structure of a block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /** @format byte */
      proposer_address?: string;
    };
    /** Data contains the set of transactions included in the block */
    data?: {
      /**
       * Txs that will be applied by state @ block.Height+1.
       * NOTE: not all txs here are valid.  We're just agreeing on the order first.
       * This means that block.AppHash does not include these txs.
       */
      txs?: string[];
    };
    evidence?: {
      evidence?: {
        /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_a?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_b?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /** @format int64 */
          total_voting_power?: string;
          /** @format int64 */
          validator_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
        /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** @format uint64 */
                  block?: string;
                  /** @format uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** @format int64 */
                height?: string;
                /** @format date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * @format byte
                 */
                last_commit_hash?: string;
                /** @format byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * @format byte
                 */
                validators_hash?: string;
                /** @format byte */
                next_validators_hash?: string;
                /** @format byte */
                consensus_hash?: string;
                /** @format byte */
                app_hash?: string;
                /** @format byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * @format byte
                 */
                evidence_hash?: string;
                /** @format byte */
                proposer_address?: string;
              };
              /** Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** @format int64 */
                height?: string;
                /** @format int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default "BLOCK_ID_FLAG_UNKNOWN"
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** @format byte */
                  validator_address?: string;
                  /** @format date-time */
                  timestamp?: string;
                  /** @format byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              };
              /** @format int64 */
              total_voting_power?: string;
            };
          };
          /** @format int64 */
          common_height?: string;
          byzantine_validators?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** @format int64 */
          total_voting_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
      }[];
    };
    /** Commit contains the evidence that a block was committed by a set of validators. */
    last_commit?: {
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default "BLOCK_ID_FLAG_UNKNOWN"
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** @format byte */
        validator_address?: string;
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        signature?: string;
      }[];
    };
  };
  /**
   * Since: cosmos-sdk 0.47
   * Block is tendermint type Block, with the Header proposer address
   * field converted to bech32 string.
   */
  sdk_block?: {
    /** Header defines the structure of a Tendermint block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /**
       * proposer_address is the original block proposer address, formatted as a Bech32 string.
       * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
       * for better UX.
       */
      proposer_address?: string;
    };
    /** Data contains the set of transactions included in the block */
    data?: {
      /**
       * Txs that will be applied by state @ block.Height+1.
       * NOTE: not all txs here are valid.  We're just agreeing on the order first.
       * This means that block.AppHash does not include these txs.
       */
      txs?: string[];
    };
    evidence?: {
      evidence?: {
        /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_a?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_b?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /** @format int64 */
          total_voting_power?: string;
          /** @format int64 */
          validator_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
        /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** @format uint64 */
                  block?: string;
                  /** @format uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** @format int64 */
                height?: string;
                /** @format date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * @format byte
                 */
                last_commit_hash?: string;
                /** @format byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * @format byte
                 */
                validators_hash?: string;
                /** @format byte */
                next_validators_hash?: string;
                /** @format byte */
                consensus_hash?: string;
                /** @format byte */
                app_hash?: string;
                /** @format byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * @format byte
                 */
                evidence_hash?: string;
                /** @format byte */
                proposer_address?: string;
              };
              /** Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** @format int64 */
                height?: string;
                /** @format int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default "BLOCK_ID_FLAG_UNKNOWN"
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** @format byte */
                  validator_address?: string;
                  /** @format date-time */
                  timestamp?: string;
                  /** @format byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              };
              /** @format int64 */
              total_voting_power?: string;
            };
          };
          /** @format int64 */
          common_height?: string;
          byzantine_validators?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** @format int64 */
          total_voting_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
      }[];
    };
    /** Commit contains the evidence that a block was committed by a set of validators. */
    last_commit?: {
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default "BLOCK_ID_FLAG_UNKNOWN"
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** @format byte */
        validator_address?: string;
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        signature?: string;
      }[];
    };
  };
}

/** GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
export interface CosmosBaseTendermintV1Beta1GetLatestValidatorSetResponse {
  /** @format int64 */
  block_height?: string;
  validators?: {
    address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    pub_key?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** @format int64 */
    voting_power?: string;
    /** @format int64 */
    proposer_priority?: string;
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method. */
export interface CosmosBaseTendermintV1Beta1GetNodeInfoResponse {
  default_node_info?: {
    protocol_version?: {
      /** @format uint64 */
      p2p?: string;
      /** @format uint64 */
      block?: string;
      /** @format uint64 */
      app?: string;
    };
    default_node_id?: string;
    listen_addr?: string;
    network?: string;
    version?: string;
    /** @format byte */
    channels?: string;
    moniker?: string;
    other?: {
      tx_index?: string;
      rpc_address?: string;
    };
  };
  /** VersionInfo is the type for the GetNodeInfoResponse message. */
  application_version?: {
    name?: string;
    app_name?: string;
    version?: string;
    git_commit?: string;
    build_tags?: string;
    go_version?: string;
    build_deps?: {
      /** module path */
      path?: string;
      /** module version */
      version?: string;
      /** checksum */
      sum?: string;
    }[];
    /** Since: cosmos-sdk 0.43 */
    cosmos_sdk_version?: string;
  };
}

/** GetSyncingResponse is the response type for the Query/GetSyncing RPC method. */
export interface CosmosBaseTendermintV1Beta1GetSyncingResponse {
  syncing?: boolean;
}

/** GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
export interface CosmosBaseTendermintV1Beta1GetValidatorSetByHeightResponse {
  /** @format int64 */
  block_height?: string;
  validators?: {
    address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    pub_key?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** @format int64 */
    voting_power?: string;
    /** @format int64 */
    proposer_priority?: string;
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** Header defines the structure of a Tendermint block header. */
export interface CosmosBaseTendermintV1Beta1Header {
  /**
   * basic block info
   * Consensus captures the consensus rules for processing a block in the blockchain,
   * including all blockchain data structures and the rules of the application's
   * state transition machine.
   */
  version?: {
    /** @format uint64 */
    block?: string;
    /** @format uint64 */
    app?: string;
  };
  chain_id?: string;
  /** @format int64 */
  height?: string;
  /** @format date-time */
  time?: string;
  /** BlockID */
  last_block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  /**
   * hashes of block data
   * @format byte
   */
  last_commit_hash?: string;
  /** @format byte */
  data_hash?: string;
  /**
   * hashes from the app output from the prev block
   * @format byte
   */
  validators_hash?: string;
  /** @format byte */
  next_validators_hash?: string;
  /** @format byte */
  consensus_hash?: string;
  /** @format byte */
  app_hash?: string;
  /** @format byte */
  last_results_hash?: string;
  /**
   * consensus info
   * @format byte
   */
  evidence_hash?: string;
  /**
   * proposer_address is the original block proposer address, formatted as a Bech32 string.
   * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
   * for better UX.
   */
  proposer_address?: string;
}

/** Module is the type for VersionInfo */
export interface CosmosBaseTendermintV1Beta1Module {
  /** module path */
  path?: string;
  /** module version */
  version?: string;
  /** checksum */
  sum?: string;
}

/**
 * ProofOp defines an operation used for calculating Merkle root. The data could
 * be arbitrary format, providing necessary data for example neighbouring node
 * hash.
 *
 * Note: This type is a duplicate of the ProofOp proto type defined in Tendermint.
 */
export interface CosmosBaseTendermintV1Beta1ProofOp {
  type?: string;
  /** @format byte */
  key?: string;
  /** @format byte */
  data?: string;
}

/**
 * ProofOps is Merkle proof defined by the list of ProofOps.
 *
 * Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
 */
export interface CosmosBaseTendermintV1Beta1ProofOps {
  ops?: {
    type?: string;
    /** @format byte */
    key?: string;
    /** @format byte */
    data?: string;
  }[];
}

/** Validator is the type for the validator-set. */
export interface CosmosBaseTendermintV1Beta1Validator {
  address?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  pub_key?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /** @format int64 */
  voting_power?: string;
  /** @format int64 */
  proposer_priority?: string;
}

/** VersionInfo is the type for the GetNodeInfoResponse message. */
export interface CosmosBaseTendermintV1Beta1VersionInfo {
  name?: string;
  app_name?: string;
  version?: string;
  git_commit?: string;
  build_tags?: string;
  go_version?: string;
  build_deps?: {
    /** module path */
    path?: string;
    /** module version */
    version?: string;
    /** checksum */
    sum?: string;
  }[];
  /** Since: cosmos-sdk 0.43 */
  cosmos_sdk_version?: string;
}

/** PublicKey defines the keys available for use with Validators */
export interface TendermintCryptoPublicKey {
  /** @format byte */
  ed25519?: string;
  /** @format byte */
  secp256k1?: string;
}

export interface TendermintP2PDefaultNodeInfo {
  protocol_version?: {
    /** @format uint64 */
    p2p?: string;
    /** @format uint64 */
    block?: string;
    /** @format uint64 */
    app?: string;
  };
  default_node_id?: string;
  listen_addr?: string;
  network?: string;
  version?: string;
  /** @format byte */
  channels?: string;
  moniker?: string;
  other?: {
    tx_index?: string;
    rpc_address?: string;
  };
}

export interface TendermintP2PDefaultNodeInfoOther {
  tx_index?: string;
  rpc_address?: string;
}

export interface TendermintP2PProtocolVersion {
  /** @format uint64 */
  p2p?: string;
  /** @format uint64 */
  block?: string;
  /** @format uint64 */
  app?: string;
}

export interface TendermintTypesBlock {
  /** Header defines the structure of a block header. */
  header?: {
    /**
     * basic block info
     * Consensus captures the consensus rules for processing a block in the blockchain,
     * including all blockchain data structures and the rules of the application's
     * state transition machine.
     */
    version?: {
      /** @format uint64 */
      block?: string;
      /** @format uint64 */
      app?: string;
    };
    chain_id?: string;
    /** @format int64 */
    height?: string;
    /** @format date-time */
    time?: string;
    /** BlockID */
    last_block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    /**
     * hashes of block data
     * @format byte
     */
    last_commit_hash?: string;
    /** @format byte */
    data_hash?: string;
    /**
     * hashes from the app output from the prev block
     * @format byte
     */
    validators_hash?: string;
    /** @format byte */
    next_validators_hash?: string;
    /** @format byte */
    consensus_hash?: string;
    /** @format byte */
    app_hash?: string;
    /** @format byte */
    last_results_hash?: string;
    /**
     * consensus info
     * @format byte
     */
    evidence_hash?: string;
    /** @format byte */
    proposer_address?: string;
  };
  /** Data contains the set of transactions included in the block */
  data?: {
    /**
     * Txs that will be applied by state @ block.Height+1.
     * NOTE: not all txs here are valid.  We're just agreeing on the order first.
     * This means that block.AppHash does not include these txs.
     */
    txs?: string[];
  };
  evidence?: {
    evidence?: {
      /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
      duplicate_vote_evidence?: {
        /**
         * Vote represents a prevote or precommit vote from validators for
         * consensus.
         */
        vote_a?: {
          /**
           * SignedMsgType is a type of signed message in the consensus.
           *
           *  - SIGNED_MSG_TYPE_PREVOTE: Votes
           *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default "SIGNED_MSG_TYPE_UNKNOWN"
           */
          type?:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** @format int64 */
          height?: string;
          /** @format int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /** @format date-time */
          timestamp?: string;
          /** @format byte */
          validator_address?: string;
          /** @format int32 */
          validator_index?: number;
          /**
           * Vote signature by the validator if they participated in consensus for the
           * associated block.
           * @format byte
           */
          signature?: string;
          /**
           * Vote extension provided by the application. Only valid for precommit
           * messages.
           * @format byte
           */
          extension?: string;
          /**
           * Vote extension signature by the validator if they participated in
           * consensus for the associated block.
           * Only valid for precommit messages.
           * @format byte
           */
          extension_signature?: string;
        };
        /**
         * Vote represents a prevote or precommit vote from validators for
         * consensus.
         */
        vote_b?: {
          /**
           * SignedMsgType is a type of signed message in the consensus.
           *
           *  - SIGNED_MSG_TYPE_PREVOTE: Votes
           *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default "SIGNED_MSG_TYPE_UNKNOWN"
           */
          type?:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** @format int64 */
          height?: string;
          /** @format int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /** @format date-time */
          timestamp?: string;
          /** @format byte */
          validator_address?: string;
          /** @format int32 */
          validator_index?: number;
          /**
           * Vote signature by the validator if they participated in consensus for the
           * associated block.
           * @format byte
           */
          signature?: string;
          /**
           * Vote extension provided by the application. Only valid for precommit
           * messages.
           * @format byte
           */
          extension?: string;
          /**
           * Vote extension signature by the validator if they participated in
           * consensus for the associated block.
           * Only valid for precommit messages.
           * @format byte
           */
          extension_signature?: string;
        };
        /** @format int64 */
        total_voting_power?: string;
        /** @format int64 */
        validator_power?: string;
        /** @format date-time */
        timestamp?: string;
      };
      /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
      light_client_attack_evidence?: {
        conflicting_block?: {
          signed_header?: {
            /** Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /** @format byte */
              proposer_address?: string;
            };
            /** Commit contains the evidence that a block was committed by a set of validators. */
            commit?: {
              /** @format int64 */
              height?: string;
              /** @format int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default "BLOCK_ID_FLAG_UNKNOWN"
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** @format byte */
                validator_address?: string;
                /** @format date-time */
                timestamp?: string;
                /** @format byte */
                signature?: string;
              }[];
            };
          };
          validator_set?: {
            validators?: {
              /** @format byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** @format byte */
                ed25519?: string;
                /** @format byte */
                secp256k1?: string;
              };
              /** @format int64 */
              voting_power?: string;
              /** @format int64 */
              proposer_priority?: string;
            }[];
            proposer?: {
              /** @format byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** @format byte */
                ed25519?: string;
                /** @format byte */
                secp256k1?: string;
              };
              /** @format int64 */
              voting_power?: string;
              /** @format int64 */
              proposer_priority?: string;
            };
            /** @format int64 */
            total_voting_power?: string;
          };
        };
        /** @format int64 */
        common_height?: string;
        byzantine_validators?: {
          /** @format byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** @format byte */
            ed25519?: string;
            /** @format byte */
            secp256k1?: string;
          };
          /** @format int64 */
          voting_power?: string;
          /** @format int64 */
          proposer_priority?: string;
        }[];
        /** @format int64 */
        total_voting_power?: string;
        /** @format date-time */
        timestamp?: string;
      };
    }[];
  };
  /** Commit contains the evidence that a block was committed by a set of validators. */
  last_commit?: {
    /** @format int64 */
    height?: string;
    /** @format int32 */
    round?: number;
    /** BlockID */
    block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    signatures?: {
      /**
       * BlockIdFlag indicates which BlockID the signature is for
       * @default "BLOCK_ID_FLAG_UNKNOWN"
       */
      block_id_flag?:
        | "BLOCK_ID_FLAG_UNKNOWN"
        | "BLOCK_ID_FLAG_ABSENT"
        | "BLOCK_ID_FLAG_COMMIT"
        | "BLOCK_ID_FLAG_NIL";
      /** @format byte */
      validator_address?: string;
      /** @format date-time */
      timestamp?: string;
      /** @format byte */
      signature?: string;
    }[];
  };
}

/** Commit contains the evidence that a block was committed by a set of validators. */
export interface TendermintTypesCommit {
  /** @format int64 */
  height?: string;
  /** @format int32 */
  round?: number;
  /** BlockID */
  block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  signatures?: {
    /**
     * BlockIdFlag indicates which BlockID the signature is for
     * @default "BLOCK_ID_FLAG_UNKNOWN"
     */
    block_id_flag?:
      | "BLOCK_ID_FLAG_UNKNOWN"
      | "BLOCK_ID_FLAG_ABSENT"
      | "BLOCK_ID_FLAG_COMMIT"
      | "BLOCK_ID_FLAG_NIL";
    /** @format byte */
    validator_address?: string;
    /** @format date-time */
    timestamp?: string;
    /** @format byte */
    signature?: string;
  }[];
}

/** CommitSig is a part of the Vote included in a Commit. */
export interface TendermintTypesCommitSig {
  /**
   * BlockIdFlag indicates which BlockID the signature is for
   * @default "BLOCK_ID_FLAG_UNKNOWN"
   */
  block_id_flag?:
    | "BLOCK_ID_FLAG_UNKNOWN"
    | "BLOCK_ID_FLAG_ABSENT"
    | "BLOCK_ID_FLAG_COMMIT"
    | "BLOCK_ID_FLAG_NIL";
  /** @format byte */
  validator_address?: string;
  /** @format date-time */
  timestamp?: string;
  /** @format byte */
  signature?: string;
}

/** Data contains the set of transactions included in the block */
export interface TendermintTypesData {
  /**
   * Txs that will be applied by state @ block.Height+1.
   * NOTE: not all txs here are valid.  We're just agreeing on the order first.
   * This means that block.AppHash does not include these txs.
   */
  txs?: string[];
}

/** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
export interface TendermintTypesDuplicateVoteEvidence {
  /**
   * Vote represents a prevote or precommit vote from validators for
   * consensus.
   */
  vote_a?: {
    /**
     * SignedMsgType is a type of signed message in the consensus.
     *
     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @default "SIGNED_MSG_TYPE_UNKNOWN"
     */
    type?:
      | "SIGNED_MSG_TYPE_UNKNOWN"
      | "SIGNED_MSG_TYPE_PREVOTE"
      | "SIGNED_MSG_TYPE_PRECOMMIT"
      | "SIGNED_MSG_TYPE_PROPOSAL";
    /** @format int64 */
    height?: string;
    /** @format int32 */
    round?: number;
    /** BlockID */
    block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    /** @format date-time */
    timestamp?: string;
    /** @format byte */
    validator_address?: string;
    /** @format int32 */
    validator_index?: number;
    /**
     * Vote signature by the validator if they participated in consensus for the
     * associated block.
     * @format byte
     */
    signature?: string;
    /**
     * Vote extension provided by the application. Only valid for precommit
     * messages.
     * @format byte
     */
    extension?: string;
    /**
     * Vote extension signature by the validator if they participated in
     * consensus for the associated block.
     * Only valid for precommit messages.
     * @format byte
     */
    extension_signature?: string;
  };
  /**
   * Vote represents a prevote or precommit vote from validators for
   * consensus.
   */
  vote_b?: {
    /**
     * SignedMsgType is a type of signed message in the consensus.
     *
     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @default "SIGNED_MSG_TYPE_UNKNOWN"
     */
    type?:
      | "SIGNED_MSG_TYPE_UNKNOWN"
      | "SIGNED_MSG_TYPE_PREVOTE"
      | "SIGNED_MSG_TYPE_PRECOMMIT"
      | "SIGNED_MSG_TYPE_PROPOSAL";
    /** @format int64 */
    height?: string;
    /** @format int32 */
    round?: number;
    /** BlockID */
    block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    /** @format date-time */
    timestamp?: string;
    /** @format byte */
    validator_address?: string;
    /** @format int32 */
    validator_index?: number;
    /**
     * Vote signature by the validator if they participated in consensus for the
     * associated block.
     * @format byte
     */
    signature?: string;
    /**
     * Vote extension provided by the application. Only valid for precommit
     * messages.
     * @format byte
     */
    extension?: string;
    /**
     * Vote extension signature by the validator if they participated in
     * consensus for the associated block.
     * Only valid for precommit messages.
     * @format byte
     */
    extension_signature?: string;
  };
  /** @format int64 */
  total_voting_power?: string;
  /** @format int64 */
  validator_power?: string;
  /** @format date-time */
  timestamp?: string;
}

export interface TendermintTypesEvidence {
  /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
  duplicate_vote_evidence?: {
    /**
     * Vote represents a prevote or precommit vote from validators for
     * consensus.
     */
    vote_a?: {
      /**
       * SignedMsgType is a type of signed message in the consensus.
       *
       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
       * @default "SIGNED_MSG_TYPE_UNKNOWN"
       */
      type?:
        | "SIGNED_MSG_TYPE_UNKNOWN"
        | "SIGNED_MSG_TYPE_PREVOTE"
        | "SIGNED_MSG_TYPE_PRECOMMIT"
        | "SIGNED_MSG_TYPE_PROPOSAL";
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /** @format date-time */
      timestamp?: string;
      /** @format byte */
      validator_address?: string;
      /** @format int32 */
      validator_index?: number;
      /**
       * Vote signature by the validator if they participated in consensus for the
       * associated block.
       * @format byte
       */
      signature?: string;
      /**
       * Vote extension provided by the application. Only valid for precommit
       * messages.
       * @format byte
       */
      extension?: string;
      /**
       * Vote extension signature by the validator if they participated in
       * consensus for the associated block.
       * Only valid for precommit messages.
       * @format byte
       */
      extension_signature?: string;
    };
    /**
     * Vote represents a prevote or precommit vote from validators for
     * consensus.
     */
    vote_b?: {
      /**
       * SignedMsgType is a type of signed message in the consensus.
       *
       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
       * @default "SIGNED_MSG_TYPE_UNKNOWN"
       */
      type?:
        | "SIGNED_MSG_TYPE_UNKNOWN"
        | "SIGNED_MSG_TYPE_PREVOTE"
        | "SIGNED_MSG_TYPE_PRECOMMIT"
        | "SIGNED_MSG_TYPE_PROPOSAL";
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /** @format date-time */
      timestamp?: string;
      /** @format byte */
      validator_address?: string;
      /** @format int32 */
      validator_index?: number;
      /**
       * Vote signature by the validator if they participated in consensus for the
       * associated block.
       * @format byte
       */
      signature?: string;
      /**
       * Vote extension provided by the application. Only valid for precommit
       * messages.
       * @format byte
       */
      extension?: string;
      /**
       * Vote extension signature by the validator if they participated in
       * consensus for the associated block.
       * Only valid for precommit messages.
       * @format byte
       */
      extension_signature?: string;
    };
    /** @format int64 */
    total_voting_power?: string;
    /** @format int64 */
    validator_power?: string;
    /** @format date-time */
    timestamp?: string;
  };
  /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
  light_client_attack_evidence?: {
    conflicting_block?: {
      signed_header?: {
        /** Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** @format uint64 */
            block?: string;
            /** @format uint64 */
            app?: string;
          };
          chain_id?: string;
          /** @format int64 */
          height?: string;
          /** @format date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * @format byte
           */
          last_commit_hash?: string;
          /** @format byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * @format byte
           */
          validators_hash?: string;
          /** @format byte */
          next_validators_hash?: string;
          /** @format byte */
          consensus_hash?: string;
          /** @format byte */
          app_hash?: string;
          /** @format byte */
          last_results_hash?: string;
          /**
           * consensus info
           * @format byte
           */
          evidence_hash?: string;
          /** @format byte */
          proposer_address?: string;
        };
        /** Commit contains the evidence that a block was committed by a set of validators. */
        commit?: {
          /** @format int64 */
          height?: string;
          /** @format int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default "BLOCK_ID_FLAG_UNKNOWN"
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** @format byte */
            validator_address?: string;
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            signature?: string;
          }[];
        };
      };
      validator_set?: {
        validators?: {
          /** @format byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** @format byte */
            ed25519?: string;
            /** @format byte */
            secp256k1?: string;
          };
          /** @format int64 */
          voting_power?: string;
          /** @format int64 */
          proposer_priority?: string;
        }[];
        proposer?: {
          /** @format byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** @format byte */
            ed25519?: string;
            /** @format byte */
            secp256k1?: string;
          };
          /** @format int64 */
          voting_power?: string;
          /** @format int64 */
          proposer_priority?: string;
        };
        /** @format int64 */
        total_voting_power?: string;
      };
    };
    /** @format int64 */
    common_height?: string;
    byzantine_validators?: {
      /** @format byte */
      address?: string;
      /** PublicKey defines the keys available for use with Validators */
      pub_key?: {
        /** @format byte */
        ed25519?: string;
        /** @format byte */
        secp256k1?: string;
      };
      /** @format int64 */
      voting_power?: string;
      /** @format int64 */
      proposer_priority?: string;
    }[];
    /** @format int64 */
    total_voting_power?: string;
    /** @format date-time */
    timestamp?: string;
  };
}

export interface TendermintTypesEvidenceList {
  evidence?: {
    /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
    duplicate_vote_evidence?: {
      /**
       * Vote represents a prevote or precommit vote from validators for
       * consensus.
       */
      vote_a?: {
        /**
         * SignedMsgType is a type of signed message in the consensus.
         *
         *  - SIGNED_MSG_TYPE_PREVOTE: Votes
         *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
         * @default "SIGNED_MSG_TYPE_UNKNOWN"
         */
        type?:
          | "SIGNED_MSG_TYPE_UNKNOWN"
          | "SIGNED_MSG_TYPE_PREVOTE"
          | "SIGNED_MSG_TYPE_PRECOMMIT"
          | "SIGNED_MSG_TYPE_PROPOSAL";
        /** @format int64 */
        height?: string;
        /** @format int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** @format byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** @format int64 */
            total?: number;
            /** @format byte */
            hash?: string;
          };
        };
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        validator_address?: string;
        /** @format int32 */
        validator_index?: number;
        /**
         * Vote signature by the validator if they participated in consensus for the
         * associated block.
         * @format byte
         */
        signature?: string;
        /**
         * Vote extension provided by the application. Only valid for precommit
         * messages.
         * @format byte
         */
        extension?: string;
        /**
         * Vote extension signature by the validator if they participated in
         * consensus for the associated block.
         * Only valid for precommit messages.
         * @format byte
         */
        extension_signature?: string;
      };
      /**
       * Vote represents a prevote or precommit vote from validators for
       * consensus.
       */
      vote_b?: {
        /**
         * SignedMsgType is a type of signed message in the consensus.
         *
         *  - SIGNED_MSG_TYPE_PREVOTE: Votes
         *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
         * @default "SIGNED_MSG_TYPE_UNKNOWN"
         */
        type?:
          | "SIGNED_MSG_TYPE_UNKNOWN"
          | "SIGNED_MSG_TYPE_PREVOTE"
          | "SIGNED_MSG_TYPE_PRECOMMIT"
          | "SIGNED_MSG_TYPE_PROPOSAL";
        /** @format int64 */
        height?: string;
        /** @format int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** @format byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** @format int64 */
            total?: number;
            /** @format byte */
            hash?: string;
          };
        };
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        validator_address?: string;
        /** @format int32 */
        validator_index?: number;
        /**
         * Vote signature by the validator if they participated in consensus for the
         * associated block.
         * @format byte
         */
        signature?: string;
        /**
         * Vote extension provided by the application. Only valid for precommit
         * messages.
         * @format byte
         */
        extension?: string;
        /**
         * Vote extension signature by the validator if they participated in
         * consensus for the associated block.
         * Only valid for precommit messages.
         * @format byte
         */
        extension_signature?: string;
      };
      /** @format int64 */
      total_voting_power?: string;
      /** @format int64 */
      validator_power?: string;
      /** @format date-time */
      timestamp?: string;
    };
    /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
    light_client_attack_evidence?: {
      conflicting_block?: {
        signed_header?: {
          /** Header defines the structure of a block header. */
          header?: {
            /**
             * basic block info
             * Consensus captures the consensus rules for processing a block in the blockchain,
             * including all blockchain data structures and the rules of the application's
             * state transition machine.
             */
            version?: {
              /** @format uint64 */
              block?: string;
              /** @format uint64 */
              app?: string;
            };
            chain_id?: string;
            /** @format int64 */
            height?: string;
            /** @format date-time */
            time?: string;
            /** BlockID */
            last_block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /**
             * hashes of block data
             * @format byte
             */
            last_commit_hash?: string;
            /** @format byte */
            data_hash?: string;
            /**
             * hashes from the app output from the prev block
             * @format byte
             */
            validators_hash?: string;
            /** @format byte */
            next_validators_hash?: string;
            /** @format byte */
            consensus_hash?: string;
            /** @format byte */
            app_hash?: string;
            /** @format byte */
            last_results_hash?: string;
            /**
             * consensus info
             * @format byte
             */
            evidence_hash?: string;
            /** @format byte */
            proposer_address?: string;
          };
          /** Commit contains the evidence that a block was committed by a set of validators. */
          commit?: {
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            signatures?: {
              /**
               * BlockIdFlag indicates which BlockID the signature is for
               * @default "BLOCK_ID_FLAG_UNKNOWN"
               */
              block_id_flag?:
                | "BLOCK_ID_FLAG_UNKNOWN"
                | "BLOCK_ID_FLAG_ABSENT"
                | "BLOCK_ID_FLAG_COMMIT"
                | "BLOCK_ID_FLAG_NIL";
              /** @format byte */
              validator_address?: string;
              /** @format date-time */
              timestamp?: string;
              /** @format byte */
              signature?: string;
            }[];
          };
        };
        validator_set?: {
          validators?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          proposer?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          };
          /** @format int64 */
          total_voting_power?: string;
        };
      };
      /** @format int64 */
      common_height?: string;
      byzantine_validators?: {
        /** @format byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** @format byte */
          ed25519?: string;
          /** @format byte */
          secp256k1?: string;
        };
        /** @format int64 */
        voting_power?: string;
        /** @format int64 */
        proposer_priority?: string;
      }[];
      /** @format int64 */
      total_voting_power?: string;
      /** @format date-time */
      timestamp?: string;
    };
  }[];
}

export interface TendermintTypesLightBlock {
  signed_header?: {
    /** Header defines the structure of a block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /** @format byte */
      proposer_address?: string;
    };
    /** Commit contains the evidence that a block was committed by a set of validators. */
    commit?: {
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default "BLOCK_ID_FLAG_UNKNOWN"
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** @format byte */
        validator_address?: string;
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        signature?: string;
      }[];
    };
  };
  validator_set?: {
    validators?: {
      /** @format byte */
      address?: string;
      /** PublicKey defines the keys available for use with Validators */
      pub_key?: {
        /** @format byte */
        ed25519?: string;
        /** @format byte */
        secp256k1?: string;
      };
      /** @format int64 */
      voting_power?: string;
      /** @format int64 */
      proposer_priority?: string;
    }[];
    proposer?: {
      /** @format byte */
      address?: string;
      /** PublicKey defines the keys available for use with Validators */
      pub_key?: {
        /** @format byte */
        ed25519?: string;
        /** @format byte */
        secp256k1?: string;
      };
      /** @format int64 */
      voting_power?: string;
      /** @format int64 */
      proposer_priority?: string;
    };
    /** @format int64 */
    total_voting_power?: string;
  };
}

/** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
export interface TendermintTypesLightClientAttackEvidence {
  conflicting_block?: {
    signed_header?: {
      /** Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * Consensus captures the consensus rules for processing a block in the blockchain,
         * including all blockchain data structures and the rules of the application's
         * state transition machine.
         */
        version?: {
          /** @format uint64 */
          block?: string;
          /** @format uint64 */
          app?: string;
        };
        chain_id?: string;
        /** @format int64 */
        height?: string;
        /** @format date-time */
        time?: string;
        /** BlockID */
        last_block_id?: {
          /** @format byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** @format int64 */
            total?: number;
            /** @format byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * @format byte
         */
        last_commit_hash?: string;
        /** @format byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * @format byte
         */
        validators_hash?: string;
        /** @format byte */
        next_validators_hash?: string;
        /** @format byte */
        consensus_hash?: string;
        /** @format byte */
        app_hash?: string;
        /** @format byte */
        last_results_hash?: string;
        /**
         * consensus info
         * @format byte
         */
        evidence_hash?: string;
        /** @format byte */
        proposer_address?: string;
      };
      /** Commit contains the evidence that a block was committed by a set of validators. */
      commit?: {
        /** @format int64 */
        height?: string;
        /** @format int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** @format byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** @format int64 */
            total?: number;
            /** @format byte */
            hash?: string;
          };
        };
        signatures?: {
          /**
           * BlockIdFlag indicates which BlockID the signature is for
           * @default "BLOCK_ID_FLAG_UNKNOWN"
           */
          block_id_flag?:
            | "BLOCK_ID_FLAG_UNKNOWN"
            | "BLOCK_ID_FLAG_ABSENT"
            | "BLOCK_ID_FLAG_COMMIT"
            | "BLOCK_ID_FLAG_NIL";
          /** @format byte */
          validator_address?: string;
          /** @format date-time */
          timestamp?: string;
          /** @format byte */
          signature?: string;
        }[];
      };
    };
    validator_set?: {
      validators?: {
        /** @format byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** @format byte */
          ed25519?: string;
          /** @format byte */
          secp256k1?: string;
        };
        /** @format int64 */
        voting_power?: string;
        /** @format int64 */
        proposer_priority?: string;
      }[];
      proposer?: {
        /** @format byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** @format byte */
          ed25519?: string;
          /** @format byte */
          secp256k1?: string;
        };
        /** @format int64 */
        voting_power?: string;
        /** @format int64 */
        proposer_priority?: string;
      };
      /** @format int64 */
      total_voting_power?: string;
    };
  };
  /** @format int64 */
  common_height?: string;
  byzantine_validators?: {
    /** @format byte */
    address?: string;
    /** PublicKey defines the keys available for use with Validators */
    pub_key?: {
      /** @format byte */
      ed25519?: string;
      /** @format byte */
      secp256k1?: string;
    };
    /** @format int64 */
    voting_power?: string;
    /** @format int64 */
    proposer_priority?: string;
  }[];
  /** @format int64 */
  total_voting_power?: string;
  /** @format date-time */
  timestamp?: string;
}

export interface TendermintTypesSignedHeader {
  /** Header defines the structure of a block header. */
  header?: {
    /**
     * basic block info
     * Consensus captures the consensus rules for processing a block in the blockchain,
     * including all blockchain data structures and the rules of the application's
     * state transition machine.
     */
    version?: {
      /** @format uint64 */
      block?: string;
      /** @format uint64 */
      app?: string;
    };
    chain_id?: string;
    /** @format int64 */
    height?: string;
    /** @format date-time */
    time?: string;
    /** BlockID */
    last_block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    /**
     * hashes of block data
     * @format byte
     */
    last_commit_hash?: string;
    /** @format byte */
    data_hash?: string;
    /**
     * hashes from the app output from the prev block
     * @format byte
     */
    validators_hash?: string;
    /** @format byte */
    next_validators_hash?: string;
    /** @format byte */
    consensus_hash?: string;
    /** @format byte */
    app_hash?: string;
    /** @format byte */
    last_results_hash?: string;
    /**
     * consensus info
     * @format byte
     */
    evidence_hash?: string;
    /** @format byte */
    proposer_address?: string;
  };
  /** Commit contains the evidence that a block was committed by a set of validators. */
  commit?: {
    /** @format int64 */
    height?: string;
    /** @format int32 */
    round?: number;
    /** BlockID */
    block_id?: {
      /** @format byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** @format int64 */
        total?: number;
        /** @format byte */
        hash?: string;
      };
    };
    signatures?: {
      /**
       * BlockIdFlag indicates which BlockID the signature is for
       * @default "BLOCK_ID_FLAG_UNKNOWN"
       */
      block_id_flag?:
        | "BLOCK_ID_FLAG_UNKNOWN"
        | "BLOCK_ID_FLAG_ABSENT"
        | "BLOCK_ID_FLAG_COMMIT"
        | "BLOCK_ID_FLAG_NIL";
      /** @format byte */
      validator_address?: string;
      /** @format date-time */
      timestamp?: string;
      /** @format byte */
      signature?: string;
    }[];
  };
}

export interface TendermintTypesValidator {
  /** @format byte */
  address?: string;
  /** PublicKey defines the keys available for use with Validators */
  pub_key?: {
    /** @format byte */
    ed25519?: string;
    /** @format byte */
    secp256k1?: string;
  };
  /** @format int64 */
  voting_power?: string;
  /** @format int64 */
  proposer_priority?: string;
}

export interface TendermintTypesValidatorSet {
  validators?: {
    /** @format byte */
    address?: string;
    /** PublicKey defines the keys available for use with Validators */
    pub_key?: {
      /** @format byte */
      ed25519?: string;
      /** @format byte */
      secp256k1?: string;
    };
    /** @format int64 */
    voting_power?: string;
    /** @format int64 */
    proposer_priority?: string;
  }[];
  proposer?: {
    /** @format byte */
    address?: string;
    /** PublicKey defines the keys available for use with Validators */
    pub_key?: {
      /** @format byte */
      ed25519?: string;
      /** @format byte */
      secp256k1?: string;
    };
    /** @format int64 */
    voting_power?: string;
    /** @format int64 */
    proposer_priority?: string;
  };
  /** @format int64 */
  total_voting_power?: string;
}

/**
 * Vote represents a prevote or precommit vote from validators for
 * consensus.
 */
export interface TendermintTypesVote {
  /**
   * SignedMsgType is a type of signed message in the consensus.
   *
   *  - SIGNED_MSG_TYPE_PREVOTE: Votes
   *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
   * @default "SIGNED_MSG_TYPE_UNKNOWN"
   */
  type?:
    | "SIGNED_MSG_TYPE_UNKNOWN"
    | "SIGNED_MSG_TYPE_PREVOTE"
    | "SIGNED_MSG_TYPE_PRECOMMIT"
    | "SIGNED_MSG_TYPE_PROPOSAL";
  /** @format int64 */
  height?: string;
  /** @format int32 */
  round?: number;
  /** BlockID */
  block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  /** @format date-time */
  timestamp?: string;
  /** @format byte */
  validator_address?: string;
  /** @format int32 */
  validator_index?: number;
  /**
   * Vote signature by the validator if they participated in consensus for the
   * associated block.
   * @format byte
   */
  signature?: string;
  /**
   * Vote extension provided by the application. Only valid for precommit
   * messages.
   * @format byte
   */
  extension?: string;
  /**
   * Vote extension signature by the validator if they participated in
   * consensus for the associated block.
   * Only valid for precommit messages.
   * @format byte
   */
  extension_signature?: string;
}

/** ConfigResponse defines the response structure for the Config gRPC query. */
export interface CosmosBaseNodeV1Beta1ConfigResponse {
  minimum_gas_price?: string;
  pruning_keep_recent?: string;
  pruning_interval?: string;
  /** @format uint64 */
  halt_height?: string;
}

/** StateResponse defines the response structure for the status of a node. */
export interface CosmosBaseNodeV1Beta1StatusResponse {
  /** @format uint64 */
  earliest_store_height?: string;
  /** @format uint64 */
  height?: string;
  /** @format date-time */
  timestamp?: string;
  /** @format byte */
  app_hash?: string;
  /** @format byte */
  validator_hash?: string;
}

/** QueryParamsResponse defines the response type for querying x/consensus parameters. */
export interface CosmosConsensusV1QueryParamsResponse {
  /**
   * params are the tendermint consensus params stored in the consensus module.
   * Please note that `params.version` is not populated in this response, it is
   * tracked separately in the x/upgrade module.
   */
  params?: {
    /** BlockParams contains limits on the block size. */
    block?: {
      /**
       * Max block size, in bytes.
       * Note: must be greater than 0
       * @format int64
       */
      max_bytes?: string;
      /**
       * Max gas per block.
       * Note: must be greater or equal to -1
       * @format int64
       */
      max_gas?: string;
    };
    /** EvidenceParams determine how we handle evidence of malfeasance. */
    evidence?: {
      /**
       * Max age of evidence, in blocks.
       *
       * The basic formula for calculating this is: MaxAgeDuration / {average block
       * time}.
       * @format int64
       */
      max_age_num_blocks?: string;
      /**
       * Max age of evidence, in time.
       *
       * It should correspond with an app's "unbonding period" or other similar
       * mechanism for handling [Nothing-At-Stake
       * attacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed).
       */
      max_age_duration?: string;
      /**
       * This sets the maximum size of total evidence in bytes that can be committed in a single block.
       * and should fall comfortably under the max block bytes.
       * Default is 1048576 or 1MB
       * @format int64
       */
      max_bytes?: string;
    };
    /**
     * ValidatorParams restrict the public key types validators can use.
     * NOTE: uses ABCI pubkey naming, not Amino names.
     */
    validator?: {
      pub_key_types?: string[];
    };
    /** VersionParams contains the ABCI application version. */
    version?: {
      /** @format uint64 */
      app?: string;
    };
    /** ABCIParams configure functionality specific to the Application Blockchain Interface. */
    abci?: {
      /**
       * vote_extensions_enable_height configures the first height during which
       * vote extensions will be enabled. During this specified height, and for all
       * subsequent heights, precommit messages that do not contain valid extension data
       * will be considered invalid. Prior to this height, vote extensions will not
       * be used or accepted by validators on the network.
       *
       * Once enabled, vote extensions will be created by the application in ExtendVote,
       * passed to the application for validation in VerifyVoteExtension and given
       * to the application to use when proposing a block during PrepareProposal.
       * @format int64
       */
      vote_extensions_enable_height?: string;
    };
  };
}

/** ABCIParams configure functionality specific to the Application Blockchain Interface. */
export interface TendermintTypesABCIParams {
  /**
   * vote_extensions_enable_height configures the first height during which
   * vote extensions will be enabled. During this specified height, and for all
   * subsequent heights, precommit messages that do not contain valid extension data
   * will be considered invalid. Prior to this height, vote extensions will not
   * be used or accepted by validators on the network.
   *
   * Once enabled, vote extensions will be created by the application in ExtendVote,
   * passed to the application for validation in VerifyVoteExtension and given
   * to the application to use when proposing a block during PrepareProposal.
   * @format int64
   */
  vote_extensions_enable_height?: string;
}

/** BlockParams contains limits on the block size. */
export interface TendermintTypesBlockParams {
  /**
   * Max block size, in bytes.
   * Note: must be greater than 0
   * @format int64
   */
  max_bytes?: string;
  /**
   * Max gas per block.
   * Note: must be greater or equal to -1
   * @format int64
   */
  max_gas?: string;
}

/**
 * ConsensusParams contains consensus critical parameters that determine the
 * validity of blocks.
 */
export interface TendermintTypesConsensusParams {
  /** BlockParams contains limits on the block size. */
  block?: {
    /**
     * Max block size, in bytes.
     * Note: must be greater than 0
     * @format int64
     */
    max_bytes?: string;
    /**
     * Max gas per block.
     * Note: must be greater or equal to -1
     * @format int64
     */
    max_gas?: string;
  };
  /** EvidenceParams determine how we handle evidence of malfeasance. */
  evidence?: {
    /**
     * Max age of evidence, in blocks.
     *
     * The basic formula for calculating this is: MaxAgeDuration / {average block
     * time}.
     * @format int64
     */
    max_age_num_blocks?: string;
    /**
     * Max age of evidence, in time.
     *
     * It should correspond with an app's "unbonding period" or other similar
     * mechanism for handling [Nothing-At-Stake
     * attacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed).
     */
    max_age_duration?: string;
    /**
     * This sets the maximum size of total evidence in bytes that can be committed in a single block.
     * and should fall comfortably under the max block bytes.
     * Default is 1048576 or 1MB
     * @format int64
     */
    max_bytes?: string;
  };
  /**
   * ValidatorParams restrict the public key types validators can use.
   * NOTE: uses ABCI pubkey naming, not Amino names.
   */
  validator?: {
    pub_key_types?: string[];
  };
  /** VersionParams contains the ABCI application version. */
  version?: {
    /** @format uint64 */
    app?: string;
  };
  /** ABCIParams configure functionality specific to the Application Blockchain Interface. */
  abci?: {
    /**
     * vote_extensions_enable_height configures the first height during which
     * vote extensions will be enabled. During this specified height, and for all
     * subsequent heights, precommit messages that do not contain valid extension data
     * will be considered invalid. Prior to this height, vote extensions will not
     * be used or accepted by validators on the network.
     *
     * Once enabled, vote extensions will be created by the application in ExtendVote,
     * passed to the application for validation in VerifyVoteExtension and given
     * to the application to use when proposing a block during PrepareProposal.
     * @format int64
     */
    vote_extensions_enable_height?: string;
  };
}

/** EvidenceParams determine how we handle evidence of malfeasance. */
export interface TendermintTypesEvidenceParams {
  /**
   * Max age of evidence, in blocks.
   *
   * The basic formula for calculating this is: MaxAgeDuration / {average block
   * time}.
   * @format int64
   */
  max_age_num_blocks?: string;
  /**
   * Max age of evidence, in time.
   *
   * It should correspond with an app's "unbonding period" or other similar
   * mechanism for handling [Nothing-At-Stake
   * attacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed).
   */
  max_age_duration?: string;
  /**
   * This sets the maximum size of total evidence in bytes that can be committed in a single block.
   * and should fall comfortably under the max block bytes.
   * Default is 1048576 or 1MB
   * @format int64
   */
  max_bytes?: string;
}

/**
 * ValidatorParams restrict the public key types validators can use.
 * NOTE: uses ABCI pubkey naming, not Amino names.
 */
export interface TendermintTypesValidatorParams {
  pub_key_types?: string[];
}

/** VersionParams contains the ABCI application version. */
export interface TendermintTypesVersionParams {
  /** @format uint64 */
  app?: string;
}

/** Grant is stored in the KVStore to record a grant with full context */
export interface CosmosFeegrantV1Beta1Grant {
  /** granter is the address of the user granting an allowance of their funds. */
  granter?: string;
  /** grantee is the address of the user being granted an allowance of another user's funds. */
  grantee?: string;
  /** allowance can be any of basic, periodic, allowed fee allowance. */
  allowance?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/** QueryAllowanceResponse is the response type for the Query/Allowance RPC method. */
export interface CosmosFeegrantV1Beta1QueryAllowanceResponse {
  /**
   * Grant is stored in the KVStore to record a grant with full context
   * allowance is a allowance granted for grantee by granter.
   */
  allowance?: {
    /** granter is the address of the user granting an allowance of their funds. */
    granter?: string;
    /** grantee is the address of the user being granted an allowance of another user's funds. */
    grantee?: string;
    /** allowance can be any of basic, periodic, allowed fee allowance. */
    allowance?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  };
}

/**
 * QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosFeegrantV1Beta1QueryAllowancesByGranterResponse {
  /** allowances that have been issued by the granter. */
  allowances?: {
    /** granter is the address of the user granting an allowance of their funds. */
    granter?: string;
    /** grantee is the address of the user being granted an allowance of another user's funds. */
    grantee?: string;
    /** allowance can be any of basic, periodic, allowed fee allowance. */
    allowance?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryAllowancesResponse is the response type for the Query/Allowances RPC method. */
export interface CosmosFeegrantV1Beta1QueryAllowancesResponse {
  /** allowances are allowance's granted for grantee by granter. */
  allowances?: {
    /** granter is the address of the user granting an allowance of their funds. */
    granter?: string;
    /** grantee is the address of the user being granted an allowance of another user's funds. */
    grantee?: string;
    /** allowance can be any of basic, periodic, allowed fee allowance. */
    allowance?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  }[];
  /** pagination defines an pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** Params defines the erc20 module params */
export interface CosmosEvmErc20V1Params {
  /**
   * enable_erc20 is the parameter to enable the conversion of Cosmos coins <-->
   * ERC20 tokens.
   */
  enable_erc20?: boolean;
  /**
   * native_precompiles defines the slice of hex addresses of the
   * active precompiles that are used to interact with native staking coins as
   * ERC20s
   */
  native_precompiles?: string[];
  /**
   * dynamic_precompiles defines the slice of hex addresses of the
   * active precompiles that are used to interact with Bank coins as ERC20s
   */
  dynamic_precompiles?: string[];
}

/**
 * QueryParamsResponse is the response type for the Query/Params RPC
 * method.
 */
export interface CosmosEvmErc20V1QueryParamsResponse {
  /** params are the erc20 module parameters */
  params?: {
    /**
     * enable_erc20 is the parameter to enable the conversion of Cosmos coins <-->
     * ERC20 tokens.
     */
    enable_erc20?: boolean;
    /**
     * native_precompiles defines the slice of hex addresses of the
     * active precompiles that are used to interact with native staking coins as
     * ERC20s
     */
    native_precompiles?: string[];
    /**
     * dynamic_precompiles defines the slice of hex addresses of the
     * active precompiles that are used to interact with Bank coins as ERC20s
     */
    dynamic_precompiles?: string[];
  };
}

/**
 * QueryTokenPairResponse is the response type for the Query/TokenPair RPC
 * method.
 */
export interface CosmosEvmErc20V1QueryTokenPairResponse {
  /**
   * token_pairs returns the info about a registered token pair for the erc20
   * module
   * TokenPair defines an instance that records a pairing consisting of a native
   * Cosmos Coin and an ERC20 token address.
   */
  token_pair?: {
    /** erc20_address is the hex address of ERC20 contract token */
    erc20_address?: string;
    /** denom defines the cosmos base denomination to be mapped to */
    denom?: string;
    /** enabled defines the token mapping enable status */
    enabled?: boolean;
    /**
     * contract_owner is the an ENUM specifying the type of ERC20 owner (0
     * invalid, 1 ModuleAccount, 2 external address)
     * Owner enumerates the ownership of a ERC20 contract.
     *
     *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
     *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
     *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
     * @default "OWNER_UNSPECIFIED"
     */
    contract_owner?: "OWNER_UNSPECIFIED" | "OWNER_MODULE" | "OWNER_EXTERNAL";
  };
}

/**
 * QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
 * method.
 */
export interface CosmosEvmErc20V1QueryTokenPairsResponse {
  /** token_pairs is a slice of registered token pairs for the erc20 module */
  token_pairs?: {
    /** erc20_address is the hex address of ERC20 contract token */
    erc20_address?: string;
    /** denom defines the cosmos base denomination to be mapped to */
    denom?: string;
    /** enabled defines the token mapping enable status */
    enabled?: boolean;
    /**
     * contract_owner is the an ENUM specifying the type of ERC20 owner (0
     * invalid, 1 ModuleAccount, 2 external address)
     * Owner enumerates the ownership of a ERC20 contract.
     *
     *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
     *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
     *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
     * @default "OWNER_UNSPECIFIED"
     */
    contract_owner?: "OWNER_UNSPECIFIED" | "OWNER_MODULE" | "OWNER_EXTERNAL";
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * TokenPair defines an instance that records a pairing consisting of a native
 * Cosmos Coin and an ERC20 token address.
 */
export interface CosmosEvmErc20V1TokenPair {
  /** erc20_address is the hex address of ERC20 contract token */
  erc20_address?: string;
  /** denom defines the cosmos base denomination to be mapped to */
  denom?: string;
  /** enabled defines the token mapping enable status */
  enabled?: boolean;
  /**
   * contract_owner is the an ENUM specifying the type of ERC20 owner (0
   * invalid, 1 ModuleAccount, 2 external address)
   * Owner enumerates the ownership of a ERC20 contract.
   *
   *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
   *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
   *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
   * @default "OWNER_UNSPECIFIED"
   */
  contract_owner?: "OWNER_UNSPECIFIED" | "OWNER_MODULE" | "OWNER_EXTERNAL";
}

/**
 * AccessControl defines the permission policy of the EVM
 * for creating and calling contracts
 */
export interface CosmosEvmVmV1AccessControl {
  /** create defines the permission policy for creating contracts */
  create?: {
    /**
     * access_type defines which type of permission is required for the operation
     * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
     *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
     *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
     * @default "ACCESS_TYPE_PERMISSIONLESS"
     */
    access_type?:
      | "ACCESS_TYPE_PERMISSIONLESS"
      | "ACCESS_TYPE_RESTRICTED"
      | "ACCESS_TYPE_PERMISSIONED";
    /**
     * access_control_list defines defines different things depending on the
     * AccessType:
     * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
     * performing the operation
     * - ACCESS_TYPE_RESTRICTED: ignored
     * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
     * the operation
     */
    access_control_list?: string[];
  };
  /** call defines the permission policy for calling contracts */
  call?: {
    /**
     * access_type defines which type of permission is required for the operation
     * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
     *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
     *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
     * @default "ACCESS_TYPE_PERMISSIONLESS"
     */
    access_type?:
      | "ACCESS_TYPE_PERMISSIONLESS"
      | "ACCESS_TYPE_RESTRICTED"
      | "ACCESS_TYPE_PERMISSIONED";
    /**
     * access_control_list defines defines different things depending on the
     * AccessType:
     * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
     * performing the operation
     * - ACCESS_TYPE_RESTRICTED: ignored
     * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
     * the operation
     */
    access_control_list?: string[];
  };
}

/** AccessControlType defines the permission type for policies */
export interface CosmosEvmVmV1AccessControlType {
  /**
   * access_type defines which type of permission is required for the operation
   * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
   *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
   *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
   * @default "ACCESS_TYPE_PERMISSIONLESS"
   */
  access_type?:
    | "ACCESS_TYPE_PERMISSIONLESS"
    | "ACCESS_TYPE_RESTRICTED"
    | "ACCESS_TYPE_PERMISSIONED";
  /**
   * access_control_list defines defines different things depending on the
   * AccessType:
   * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
   * performing the operation
   * - ACCESS_TYPE_RESTRICTED: ignored
   * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
   * the operation
   */
  access_control_list?: string[];
}

/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
 * instead of *big.Int.
 */
export interface CosmosEvmVmV1ChainConfig {
  /** homestead_block switch (nil no fork, 0 = already homestead) */
  homestead_block?: string;
  /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
  dao_fork_block?: string;
  /**
   * dao_fork_support defines whether the nodes supports or opposes the DAO
   * hard-fork
   */
  dao_fork_support?: boolean;
  /**
   * eip150_block: EIP150 implements the Gas price changes
   * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
   */
  eip150_block?: string;
  /**
   * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
   * pricing changed)
   */
  eip150_hash?: string;
  /** eip155_block: EIP155Block HF block */
  eip155_block?: string;
  /** eip158_block: EIP158 HF block */
  eip158_block?: string;
  /**
   * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
   * byzantium)
   */
  byzantium_block?: string;
  /**
   * constantinople_block: Constantinople switch block (nil no fork, 0 = already
   * activated)
   */
  constantinople_block?: string;
  /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
  petersburg_block?: string;
  /**
   * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
   * istanbul)
   */
  istanbul_block?: string;
  /**
   * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
   * already activated)
   */
  muir_glacier_block?: string;
  /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
  berlin_block?: string;
  /** london_block: London switch block (nil = no fork, 0 = already on london) */
  london_block?: string;
  /**
   * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
   * already activated)
   */
  arrow_glacier_block?: string;
  /**
   * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
   * already activated)
   */
  gray_glacier_block?: string;
  /**
   * merge_netsplit_block: Virtual fork after The Merge to use as a network
   * splitter
   */
  merge_netsplit_block?: string;
  /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
  shanghai_block?: string;
  /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
  cancun_block?: string;
  /**
   * chain_id is the id of the chain (EIP-155)
   * @format uint64
   */
  chain_id?: string;
  /** denom is the denomination used on the EVM */
  denom?: string;
  /**
   * decimals is the real decimal precision of the denomination used on the EVM
   * @format uint64
   */
  decimals?: string;
}

/** EstimateGasResponse defines EstimateGas response */
export interface CosmosEvmVmV1EstimateGasResponse {
  /**
   * gas returns the estimated gas
   * @format uint64
   */
  gas?: string;
  /**
   * ret is the returned data from evm function (result or data supplied with
   * revert opcode)
   * @format byte
   */
  ret?: string;
  /** vm_error is the error returned by vm execution */
  vm_error?: string;
}

/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * NOTE: address, topics and data are consensus fields. The rest of the fields
 * are derived, i.e. filled in by the nodes, but not secured by consensus.
 */
export interface CosmosEvmVmV1Log {
  /** address of the contract that generated the event */
  address?: string;
  /** topics is a list of topics provided by the contract. */
  topics?: string[];
  /**
   * data which is supplied by the contract, usually ABI-encoded
   * @format byte
   */
  data?: string;
  /**
   * block_number of the block in which the transaction was included
   * @format uint64
   */
  block_number?: string;
  /** tx_hash is the transaction hash */
  tx_hash?: string;
  /**
   * tx_index of the transaction in the block
   * @format uint64
   */
  tx_index?: string;
  /** block_hash of the block in which the transaction was included */
  block_hash?: string;
  /**
   * index of the log in the block
   * @format uint64
   */
  index?: string;
  /**
   * removed is true if this log was reverted due to a chain
   * reorganisation. You must pay attention to this field if you receive logs
   * through a filter query.
   */
  removed?: boolean;
}

/** MsgEthereumTx encapsulates an Ethereum transaction as an SDK message. */
export interface CosmosEvmVmV1MsgEthereumTx {
  /**
   * data is inner transaction data of the Ethereum transaction
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  data?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * size is the encoded storage size of the transaction (DEPRECATED)
   * @format double
   */
  size?: number;
  /** hash of the transaction in hex format */
  hash?: string;
  /**
   * from is the ethereum signer address in hex format. This address value is
   * checked against the address derived from the signature (V, R, S) using the
   * secp256k1 elliptic curve
   */
  from?: string;
}

/** MsgEthereumTxResponse defines the Msg/EthereumTx response type. */
export interface CosmosEvmVmV1MsgEthereumTxResponse {
  /**
   * hash of the ethereum transaction in hex format. This hash differs from the
   * Tendermint sha256 hash of the transaction bytes. See
   * https://github.com/tendermint/tendermint/issues/6539 for reference
   */
  hash?: string;
  /**
   * logs contains the transaction hash and the proto-compatible ethereum
   * logs.
   */
  logs?: {
    /** address of the contract that generated the event */
    address?: string;
    /** topics is a list of topics provided by the contract. */
    topics?: string[];
    /**
     * data which is supplied by the contract, usually ABI-encoded
     * @format byte
     */
    data?: string;
    /**
     * block_number of the block in which the transaction was included
     * @format uint64
     */
    block_number?: string;
    /** tx_hash is the transaction hash */
    tx_hash?: string;
    /**
     * tx_index of the transaction in the block
     * @format uint64
     */
    tx_index?: string;
    /** block_hash of the block in which the transaction was included */
    block_hash?: string;
    /**
     * index of the log in the block
     * @format uint64
     */
    index?: string;
    /**
     * removed is true if this log was reverted due to a chain
     * reorganisation. You must pay attention to this field if you receive logs
     * through a filter query.
     */
    removed?: boolean;
  }[];
  /**
   * ret is the returned data from evm function (result or data supplied with
   * revert opcode)
   * @format byte
   */
  ret?: string;
  /** vm_error is the error returned by vm execution */
  vm_error?: string;
  /**
   * gas_used specifies how much gas was consumed by the transaction
   * @format uint64
   */
  gas_used?: string;
}

/** Params defines the EVM module parameters */
export interface CosmosEvmVmV1Params {
  /**
   * evm_denom represents the token denomination used to run the EVM state
   * transitions.
   */
  evm_denom?: string;
  /** extra_eips defines the additional EIPs for the vm.Config */
  extra_eips?: string[];
  /**
   * chain_config defines the EVM chain configuration parameters
   * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
   * instead of *big.Int.
   */
  chain_config?: {
    /** homestead_block switch (nil no fork, 0 = already homestead) */
    homestead_block?: string;
    /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
    dao_fork_block?: string;
    /**
     * dao_fork_support defines whether the nodes supports or opposes the DAO
     * hard-fork
     */
    dao_fork_support?: boolean;
    /**
     * eip150_block: EIP150 implements the Gas price changes
     * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
     */
    eip150_block?: string;
    /**
     * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
     * pricing changed)
     */
    eip150_hash?: string;
    /** eip155_block: EIP155Block HF block */
    eip155_block?: string;
    /** eip158_block: EIP158 HF block */
    eip158_block?: string;
    /**
     * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
     * byzantium)
     */
    byzantium_block?: string;
    /**
     * constantinople_block: Constantinople switch block (nil no fork, 0 = already
     * activated)
     */
    constantinople_block?: string;
    /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
    petersburg_block?: string;
    /**
     * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
     * istanbul)
     */
    istanbul_block?: string;
    /**
     * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
     * already activated)
     */
    muir_glacier_block?: string;
    /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
    berlin_block?: string;
    /** london_block: London switch block (nil = no fork, 0 = already on london) */
    london_block?: string;
    /**
     * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    arrow_glacier_block?: string;
    /**
     * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    gray_glacier_block?: string;
    /**
     * merge_netsplit_block: Virtual fork after The Merge to use as a network
     * splitter
     */
    merge_netsplit_block?: string;
    /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
    shanghai_block?: string;
    /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
    cancun_block?: string;
    /**
     * chain_id is the id of the chain (EIP-155)
     * @format uint64
     */
    chain_id?: string;
    /** denom is the denomination used on the EVM */
    denom?: string;
    /**
     * decimals is the real decimal precision of the denomination used on the EVM
     * @format uint64
     */
    decimals?: string;
  };
  /**
   * allow_unprotected_txs defines if replay-protected (i.e non EIP155
   * signed) transactions can be executed on the state machine.
   */
  allow_unprotected_txs?: boolean;
  /** evm_channels is the list of channel identifiers from EVM compatible chains */
  evm_channels?: string[];
  /** access_control defines the permission policy of the EVM */
  access_control?: {
    /** create defines the permission policy for creating contracts */
    create?: {
      /**
       * access_type defines which type of permission is required for the operation
       * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
       *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
       *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
       * @default "ACCESS_TYPE_PERMISSIONLESS"
       */
      access_type?:
        | "ACCESS_TYPE_PERMISSIONLESS"
        | "ACCESS_TYPE_RESTRICTED"
        | "ACCESS_TYPE_PERMISSIONED";
      /**
       * access_control_list defines defines different things depending on the
       * AccessType:
       * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
       * performing the operation
       * - ACCESS_TYPE_RESTRICTED: ignored
       * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
       * the operation
       */
      access_control_list?: string[];
    };
    /** call defines the permission policy for calling contracts */
    call?: {
      /**
       * access_type defines which type of permission is required for the operation
       * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
       *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
       *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
       * @default "ACCESS_TYPE_PERMISSIONLESS"
       */
      access_type?:
        | "ACCESS_TYPE_PERMISSIONLESS"
        | "ACCESS_TYPE_RESTRICTED"
        | "ACCESS_TYPE_PERMISSIONED";
      /**
       * access_control_list defines defines different things depending on the
       * AccessType:
       * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
       * performing the operation
       * - ACCESS_TYPE_RESTRICTED: ignored
       * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
       * the operation
       */
      access_control_list?: string[];
    };
  };
  /**
   * active_static_precompiles defines the slice of hex addresses of the
   * precompiled contracts that are active
   */
  active_static_precompiles?: string[];
}

/** QueryAccountResponse is the response type for the Query/Account RPC method. */
export interface CosmosEvmVmV1QueryAccountResponse {
  /** balance is the balance of the EVM denomination. */
  balance?: string;
  /** code_hash is the hex-formatted code bytes from the EOA. */
  code_hash?: string;
  /**
   * nonce is the account's sequence number.
   * @format uint64
   */
  nonce?: string;
}

/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface CosmosEvmVmV1QueryBalanceResponse {
  /** balance is the balance of the EVM denomination. */
  balance?: string;
}

/** QueryBaseFeeResponse returns the EIP1559 base fee. */
export interface CosmosEvmVmV1QueryBaseFeeResponse {
  /** base_fee is the EIP1559 base fee */
  base_fee?: string;
}

/**
 * QueryCodeResponse is the response type for the Query/Code RPC
 * method.
 */
export interface CosmosEvmVmV1QueryCodeResponse {
  /**
   * code represents the code bytes from an ethereum address.
   * @format byte
   */
  code?: string;
}

/** QueryConfigResponse returns the EVM config. */
export interface CosmosEvmVmV1QueryConfigResponse {
  /**
   * config is the evm configuration
   * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
   * instead of *big.Int.
   */
  config?: {
    /** homestead_block switch (nil no fork, 0 = already homestead) */
    homestead_block?: string;
    /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
    dao_fork_block?: string;
    /**
     * dao_fork_support defines whether the nodes supports or opposes the DAO
     * hard-fork
     */
    dao_fork_support?: boolean;
    /**
     * eip150_block: EIP150 implements the Gas price changes
     * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
     */
    eip150_block?: string;
    /**
     * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
     * pricing changed)
     */
    eip150_hash?: string;
    /** eip155_block: EIP155Block HF block */
    eip155_block?: string;
    /** eip158_block: EIP158 HF block */
    eip158_block?: string;
    /**
     * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
     * byzantium)
     */
    byzantium_block?: string;
    /**
     * constantinople_block: Constantinople switch block (nil no fork, 0 = already
     * activated)
     */
    constantinople_block?: string;
    /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
    petersburg_block?: string;
    /**
     * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
     * istanbul)
     */
    istanbul_block?: string;
    /**
     * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
     * already activated)
     */
    muir_glacier_block?: string;
    /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
    berlin_block?: string;
    /** london_block: London switch block (nil = no fork, 0 = already on london) */
    london_block?: string;
    /**
     * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    arrow_glacier_block?: string;
    /**
     * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    gray_glacier_block?: string;
    /**
     * merge_netsplit_block: Virtual fork after The Merge to use as a network
     * splitter
     */
    merge_netsplit_block?: string;
    /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
    shanghai_block?: string;
    /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
    cancun_block?: string;
    /**
     * chain_id is the id of the chain (EIP-155)
     * @format uint64
     */
    chain_id?: string;
    /** denom is the denomination used on the EVM */
    denom?: string;
    /**
     * decimals is the real decimal precision of the denomination used on the EVM
     * @format uint64
     */
    decimals?: string;
  };
}

/**
 * QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
 * RPC method.
 */
export interface CosmosEvmVmV1QueryCosmosAccountResponse {
  /** cosmos_address is the cosmos address of the account. */
  cosmos_address?: string;
  /**
   * sequence is the account's sequence number.
   * @format uint64
   */
  sequence?: string;
  /**
   * account_number is the account number
   * @format uint64
   */
  account_number?: string;
}

/** QueryGlobalMinGasPriceResponse returns the GlobalMinGasPrice */
export interface CosmosEvmVmV1QueryGlobalMinGasPriceResponse {
  /** min_gas_price is the feemarket's min_gas_price */
  min_gas_price?: string;
}

/** QueryParamsResponse defines the response type for querying x/vm parameters. */
export interface CosmosEvmVmV1QueryParamsResponse {
  /**
   * Params defines the EVM module parameters
   * params define the evm module parameters.
   */
  params?: {
    /**
     * evm_denom represents the token denomination used to run the EVM state
     * transitions.
     */
    evm_denom?: string;
    /** extra_eips defines the additional EIPs for the vm.Config */
    extra_eips?: string[];
    /**
     * chain_config defines the EVM chain configuration parameters
     * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
     * instead of *big.Int.
     */
    chain_config?: {
      /** homestead_block switch (nil no fork, 0 = already homestead) */
      homestead_block?: string;
      /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
      dao_fork_block?: string;
      /**
       * dao_fork_support defines whether the nodes supports or opposes the DAO
       * hard-fork
       */
      dao_fork_support?: boolean;
      /**
       * eip150_block: EIP150 implements the Gas price changes
       * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
       */
      eip150_block?: string;
      /**
       * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
       * pricing changed)
       */
      eip150_hash?: string;
      /** eip155_block: EIP155Block HF block */
      eip155_block?: string;
      /** eip158_block: EIP158 HF block */
      eip158_block?: string;
      /**
       * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
       * byzantium)
       */
      byzantium_block?: string;
      /**
       * constantinople_block: Constantinople switch block (nil no fork, 0 = already
       * activated)
       */
      constantinople_block?: string;
      /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
      petersburg_block?: string;
      /**
       * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
       * istanbul)
       */
      istanbul_block?: string;
      /**
       * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
       * already activated)
       */
      muir_glacier_block?: string;
      /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
      berlin_block?: string;
      /** london_block: London switch block (nil = no fork, 0 = already on london) */
      london_block?: string;
      /**
       * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
       * already activated)
       */
      arrow_glacier_block?: string;
      /**
       * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
       * already activated)
       */
      gray_glacier_block?: string;
      /**
       * merge_netsplit_block: Virtual fork after The Merge to use as a network
       * splitter
       */
      merge_netsplit_block?: string;
      /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
      shanghai_block?: string;
      /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
      cancun_block?: string;
      /**
       * chain_id is the id of the chain (EIP-155)
       * @format uint64
       */
      chain_id?: string;
      /** denom is the denomination used on the EVM */
      denom?: string;
      /**
       * decimals is the real decimal precision of the denomination used on the EVM
       * @format uint64
       */
      decimals?: string;
    };
    /**
     * allow_unprotected_txs defines if replay-protected (i.e non EIP155
     * signed) transactions can be executed on the state machine.
     */
    allow_unprotected_txs?: boolean;
    /** evm_channels is the list of channel identifiers from EVM compatible chains */
    evm_channels?: string[];
    /** access_control defines the permission policy of the EVM */
    access_control?: {
      /** create defines the permission policy for creating contracts */
      create?: {
        /**
         * access_type defines which type of permission is required for the operation
         * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
         *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
         *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
         * @default "ACCESS_TYPE_PERMISSIONLESS"
         */
        access_type?:
          | "ACCESS_TYPE_PERMISSIONLESS"
          | "ACCESS_TYPE_RESTRICTED"
          | "ACCESS_TYPE_PERMISSIONED";
        /**
         * access_control_list defines defines different things depending on the
         * AccessType:
         * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
         * performing the operation
         * - ACCESS_TYPE_RESTRICTED: ignored
         * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
         * the operation
         */
        access_control_list?: string[];
      };
      /** call defines the permission policy for calling contracts */
      call?: {
        /**
         * access_type defines which type of permission is required for the operation
         * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
         *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
         *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
         * @default "ACCESS_TYPE_PERMISSIONLESS"
         */
        access_type?:
          | "ACCESS_TYPE_PERMISSIONLESS"
          | "ACCESS_TYPE_RESTRICTED"
          | "ACCESS_TYPE_PERMISSIONED";
        /**
         * access_control_list defines defines different things depending on the
         * AccessType:
         * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
         * performing the operation
         * - ACCESS_TYPE_RESTRICTED: ignored
         * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
         * the operation
         */
        access_control_list?: string[];
      };
    };
    /**
     * active_static_precompiles defines the slice of hex addresses of the
     * precompiled contracts that are active
     */
    active_static_precompiles?: string[];
  };
}

/**
 * QueryStorageResponse is the response type for the Query/Storage RPC
 * method.
 */
export interface CosmosEvmVmV1QueryStorageResponse {
  /** value defines the storage state value hash associated with the given key. */
  value?: string;
}

/** QueryTraceBlockResponse defines TraceBlock response */
export interface CosmosEvmVmV1QueryTraceBlockResponse {
  /**
   * data is the response serialized in bytes
   * @format byte
   */
  data?: string;
}

/** QueryTraceTxResponse defines TraceTx response */
export interface CosmosEvmVmV1QueryTraceTxResponse {
  /**
   * data is the response serialized in bytes
   * @format byte
   */
  data?: string;
}

/**
 * QueryValidatorAccountResponse is the response type for the
 * Query/ValidatorAccount RPC method.
 */
export interface CosmosEvmVmV1QueryValidatorAccountResponse {
  /** account_address is the cosmos address of the account in bech32 format. */
  account_address?: string;
  /**
   * sequence is the account's sequence number.
   * @format uint64
   */
  sequence?: string;
  /**
   * account_number is the account number
   * @format uint64
   */
  account_number?: string;
}

/** TraceConfig holds extra parameters to trace functions. */
export interface CosmosEvmVmV1TraceConfig {
  /** tracer is a custom javascript tracer */
  tracer?: string;
  /**
   * timeout overrides the default timeout of 5 seconds for JavaScript-based
   * tracing calls
   */
  timeout?: string;
  /**
   * reexec defines the number of blocks the tracer is willing to go back
   * @format uint64
   */
  reexec?: string;
  /** disable_stack switches stack capture */
  disable_stack?: boolean;
  /** disable_storage switches storage capture */
  disable_storage?: boolean;
  /** debug can be used to print output during capture end */
  debug?: boolean;
  /**
   * limit defines the maximum length of output, but zero means unlimited
   * @format int32
   */
  limit?: number;
  /**
   * overrides can be used to execute a trace using future fork rules
   * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
   * instead of *big.Int.
   */
  overrides?: {
    /** homestead_block switch (nil no fork, 0 = already homestead) */
    homestead_block?: string;
    /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
    dao_fork_block?: string;
    /**
     * dao_fork_support defines whether the nodes supports or opposes the DAO
     * hard-fork
     */
    dao_fork_support?: boolean;
    /**
     * eip150_block: EIP150 implements the Gas price changes
     * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
     */
    eip150_block?: string;
    /**
     * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
     * pricing changed)
     */
    eip150_hash?: string;
    /** eip155_block: EIP155Block HF block */
    eip155_block?: string;
    /** eip158_block: EIP158 HF block */
    eip158_block?: string;
    /**
     * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
     * byzantium)
     */
    byzantium_block?: string;
    /**
     * constantinople_block: Constantinople switch block (nil no fork, 0 = already
     * activated)
     */
    constantinople_block?: string;
    /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
    petersburg_block?: string;
    /**
     * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
     * istanbul)
     */
    istanbul_block?: string;
    /**
     * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
     * already activated)
     */
    muir_glacier_block?: string;
    /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
    berlin_block?: string;
    /** london_block: London switch block (nil = no fork, 0 = already on london) */
    london_block?: string;
    /**
     * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    arrow_glacier_block?: string;
    /**
     * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    gray_glacier_block?: string;
    /**
     * merge_netsplit_block: Virtual fork after The Merge to use as a network
     * splitter
     */
    merge_netsplit_block?: string;
    /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
    shanghai_block?: string;
    /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
    cancun_block?: string;
    /**
     * chain_id is the id of the chain (EIP-155)
     * @format uint64
     */
    chain_id?: string;
    /** denom is the denomination used on the EVM */
    denom?: string;
    /**
     * decimals is the real decimal precision of the denomination used on the EVM
     * @format uint64
     */
    decimals?: string;
  };
  /** enable_memory switches memory capture */
  enable_memory?: boolean;
  /** enable_return_data switches the capture of return data */
  enable_return_data?: boolean;
  /** tracer_json_config configures the tracer using a JSON string */
  tracer_json_config?: string;
}

/** Params defines the EVM module parameters */
export interface CosmosEvmFeemarketV1Params {
  /** no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
  no_base_fee?: boolean;
  /**
   * base_fee_change_denominator bounds the amount the base fee can change
   * between blocks.
   * @format int64
   */
  base_fee_change_denominator?: number;
  /**
   * elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may
   * have.
   * @format int64
   */
  elasticity_multiplier?: number;
  /**
   * enable_height defines at which block height the base fee calculation is
   * enabled.
   * @format int64
   */
  enable_height?: string;
  /** base_fee for EIP-1559 blocks. */
  base_fee?: string;
  /**
   * min_gas_price defines the minimum gas price value for cosmos and eth
   * transactions
   */
  min_gas_price?: string;
  /**
   * min_gas_multiplier bounds the minimum gas used to be charged
   * to senders based on gas limit
   */
  min_gas_multiplier?: string;
}

/** QueryBaseFeeResponse returns the EIP1559 base fee. */
export interface CosmosEvmFeemarketV1QueryBaseFeeResponse {
  /** base_fee is the EIP1559 base fee */
  base_fee?: string;
}

/** QueryBlockGasResponse returns block gas used for a given height. */
export interface CosmosEvmFeemarketV1QueryBlockGasResponse {
  /**
   * gas is the returned block gas
   * @format int64
   */
  gas?: string;
}

/** QueryParamsResponse defines the response type for querying x/vm parameters. */
export interface CosmosEvmFeemarketV1QueryParamsResponse {
  /**
   * Params defines the EVM module parameters
   * params define the evm module parameters.
   */
  params?: {
    /** no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
    no_base_fee?: boolean;
    /**
     * base_fee_change_denominator bounds the amount the base fee can change
     * between blocks.
     * @format int64
     */
    base_fee_change_denominator?: number;
    /**
     * elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may
     * have.
     * @format int64
     */
    elasticity_multiplier?: number;
    /**
     * enable_height defines at which block height the base fee calculation is
     * enabled.
     * @format int64
     */
    enable_height?: string;
    /** base_fee for EIP-1559 blocks. */
    base_fee?: string;
    /**
     * min_gas_price defines the minimum gas price value for cosmos and eth
     * transactions
     */
    min_gas_price?: string;
    /**
     * min_gas_multiplier bounds the minimum gas used to be charged
     * to senders based on gas limit
     */
    min_gas_multiplier?: string;
  };
}

/**
 * AddressBytesToStringResponse is the response type for AddressString rpc method.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosAuthV1Beta1AddressBytesToStringResponse {
  address_string?: string;
}

/**
 * AddressStringToBytesResponse is the response type for AddressBytes rpc method.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosAuthV1Beta1AddressStringToBytesResponse {
  /** @format byte */
  address_bytes?: string;
}

/**
 * BaseAccount defines a base account type. It contains all the necessary fields
 * for basic account functionality. Any custom account type should extend this
 * type for additional functionality (e.g. vesting).
 */
export interface CosmosAuthV1Beta1BaseAccount {
  address?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  pub_key?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /** @format uint64 */
  account_number?: string;
  /** @format uint64 */
  sequence?: string;
}

/**
 * Bech32PrefixResponse is the response type for Bech32Prefix rpc method.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosAuthV1Beta1Bech32PrefixResponse {
  bech32_prefix?: string;
}

/** Params defines the parameters for the auth module. */
export interface CosmosAuthV1Beta1Params {
  /** @format uint64 */
  max_memo_characters?: string;
  /** @format uint64 */
  tx_sig_limit?: string;
  /** @format uint64 */
  tx_size_cost_per_byte?: string;
  /** @format uint64 */
  sig_verify_cost_ed25519?: string;
  /** @format uint64 */
  sig_verify_cost_secp256k1?: string;
}

/**
 * QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method
 * Since: cosmos-sdk 0.46.2
 */
export interface CosmosAuthV1Beta1QueryAccountAddressByIDResponse {
  account_address?: string;
}

/**
 * QueryAccountInfoResponse is the Query/AccountInfo response type.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosAuthV1Beta1QueryAccountInfoResponse {
  /** info is the account info which is represented by BaseAccount. */
  info?: {
    address?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    pub_key?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /** @format uint64 */
    account_number?: string;
    /** @format uint64 */
    sequence?: string;
  };
}

/** QueryAccountResponse is the response type for the Query/Account RPC method. */
export interface CosmosAuthV1Beta1QueryAccountResponse {
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  account?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/**
 * QueryAccountsResponse is the response type for the Query/Accounts RPC method.
 *
 * Since: cosmos-sdk 0.43
 */
export interface CosmosAuthV1Beta1QueryAccountsResponse {
  /** accounts are the existing accounts */
  accounts?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method. */
export interface CosmosAuthV1Beta1QueryModuleAccountByNameResponse {
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  account?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/**
 * QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosAuthV1Beta1QueryModuleAccountsResponse {
  accounts?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface CosmosAuthV1Beta1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /** @format uint64 */
    max_memo_characters?: string;
    /** @format uint64 */
    tx_sig_limit?: string;
    /** @format uint64 */
    tx_size_cost_per_byte?: string;
    /** @format uint64 */
    sig_verify_cost_ed25519?: string;
    /** @format uint64 */
    sig_verify_cost_secp256k1?: string;
  };
}

/**
 * DelegationDelegatorReward represents the properties
 * of a delegator's delegation reward.
 */
export interface CosmosDistributionV1Beta1DelegationDelegatorReward {
  validator_address?: string;
  reward?: {
    denom?: string;
    amount?: string;
  }[];
}

/** Params defines the set of params for the distribution module. */
export interface CosmosDistributionV1Beta1Params {
  community_tax?: string;
  /**
   * Deprecated: The base_proposer_reward field is deprecated and is no longer used
   * in the x/distribution module's reward mechanism.
   */
  base_proposer_reward?: string;
  /**
   * Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
   * in the x/distribution module's reward mechanism.
   */
  bonus_proposer_reward?: string;
  withdraw_addr_enabled?: boolean;
}

/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool
 * RPC method.
 */
export interface CosmosDistributionV1Beta1QueryCommunityPoolResponse {
  /** pool defines community pool's coins. */
  pool?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * QueryDelegationRewardsResponse is the response type for the
 * Query/DelegationRewards RPC method.
 */
export interface CosmosDistributionV1Beta1QueryDelegationRewardsResponse {
  /** rewards defines the rewards accrued by a delegation. */
  rewards?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * QueryDelegationTotalRewardsResponse is the response type for the
 * Query/DelegationTotalRewards RPC method.
 */
export interface CosmosDistributionV1Beta1QueryDelegationTotalRewardsResponse {
  /** rewards defines all the rewards accrued by a delegator. */
  rewards?: {
    validator_address?: string;
    reward?: {
      denom?: string;
      amount?: string;
    }[];
  }[];
  /** total defines the sum of all the rewards. */
  total?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * QueryDelegatorValidatorsResponse is the response type for the
 * Query/DelegatorValidators RPC method.
 */
export interface CosmosDistributionV1Beta1QueryDelegatorValidatorsResponse {
  /** validators defines the validators a delegator is delegating for. */
  validators?: string[];
}

/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the
 * Query/DelegatorWithdrawAddress RPC method.
 */
export interface CosmosDistributionV1Beta1QueryDelegatorWithdrawAddressResponse {
  /** withdraw_address defines the delegator address to query for. */
  withdraw_address?: string;
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface CosmosDistributionV1Beta1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    community_tax?: string;
    /**
     * Deprecated: The base_proposer_reward field is deprecated and is no longer used
     * in the x/distribution module's reward mechanism.
     */
    base_proposer_reward?: string;
    /**
     * Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
     * in the x/distribution module's reward mechanism.
     */
    bonus_proposer_reward?: string;
    withdraw_addr_enabled?: boolean;
  };
}

/**
 * QueryValidatorCommissionResponse is the response type for the
 * Query/ValidatorCommission RPC method
 */
export interface CosmosDistributionV1Beta1QueryValidatorCommissionResponse {
  /** commission defines the commission the validator received. */
  commission?: {
    commission?: {
      denom?: string;
      amount?: string;
    }[];
  };
}

/** QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method. */
export interface CosmosDistributionV1Beta1QueryValidatorDistributionInfoResponse {
  /** operator_address defines the validator operator address. */
  operator_address?: string;
  /** self_bond_rewards defines the self delegations rewards. */
  self_bond_rewards?: {
    denom?: string;
    amount?: string;
  }[];
  /** commission defines the commission the validator received. */
  commission?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the
 * Query/ValidatorOutstandingRewards RPC method.
 */
export interface CosmosDistributionV1Beta1QueryValidatorOutstandingRewardsResponse {
  /**
   * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
   * for a validator inexpensive to track, allows simple sanity checks.
   */
  rewards?: {
    rewards?: {
      denom?: string;
      amount?: string;
    }[];
  };
}

/**
 * QueryValidatorSlashesResponse is the response type for the
 * Query/ValidatorSlashes RPC method.
 */
export interface CosmosDistributionV1Beta1QueryValidatorSlashesResponse {
  /** slashes defines the slashes the validator received. */
  slashes?: {
    /** @format uint64 */
    validator_period?: string;
    fraction?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * ValidatorAccumulatedCommission represents accumulated commission
 * for a validator kept as a running counter, can be withdrawn at any time.
 */
export interface CosmosDistributionV1Beta1ValidatorAccumulatedCommission {
  commission?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
 * for a validator inexpensive to track, allows simple sanity checks.
 */
export interface CosmosDistributionV1Beta1ValidatorOutstandingRewards {
  rewards?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * ValidatorSlashEvent represents a validator slash event.
 * Height is implicit within the store key.
 * This is needed to calculate appropriate amount of staking tokens
 * for delegations which are withdrawn after a slash has occurred.
 */
export interface CosmosDistributionV1Beta1ValidatorSlashEvent {
  /** @format uint64 */
  validator_period?: string;
  fraction?: string;
}

/**
 * QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
 * method.
 */
export interface CosmosEvidenceV1Beta1QueryAllEvidenceResponse {
  /** evidence returns all evidences. */
  evidence?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryEvidenceResponse is the response type for the Query/Evidence RPC method. */
export interface CosmosEvidenceV1Beta1QueryEvidenceResponse {
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  evidence?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/**
 * Deposit defines an amount deposited by an account address to an active
 * proposal.
 */
export interface CosmosGovV1Beta1Deposit {
  /**
   * proposal_id defines the unique id of the proposal.
   * @format uint64
   */
  proposal_id?: string;
  /** depositor defines the deposit addresses from the proposals. */
  depositor?: string;
  /** amount to be deposited by depositor. */
  amount?: {
    denom?: string;
    amount?: string;
  }[];
}

/** DepositParams defines the params for deposits on governance proposals. */
export interface CosmosGovV1Beta1DepositParams {
  /** Minimum deposit for a proposal to enter voting period. */
  min_deposit?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
   * months.
   */
  max_deposit_period?: string;
}

/** Proposal defines the core field members of a governance proposal. */
export interface CosmosGovV1Beta1Proposal {
  /**
   * proposal_id defines the unique id of the proposal.
   * @format uint64
   */
  proposal_id?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  content?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * status defines the proposal status.
   * @default "PROPOSAL_STATUS_UNSPECIFIED"
   */
  status?:
    | "PROPOSAL_STATUS_UNSPECIFIED"
    | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
    | "PROPOSAL_STATUS_VOTING_PERIOD"
    | "PROPOSAL_STATUS_PASSED"
    | "PROPOSAL_STATUS_REJECTED"
    | "PROPOSAL_STATUS_FAILED";
  /**
   * final_tally_result is the final tally result of the proposal. When
   * querying a proposal via gRPC, this field is not populated until the
   * proposal's voting period has ended.
   */
  final_tally_result?: {
    /** yes is the number of yes votes on a proposal. */
    yes?: string;
    /** abstain is the number of abstain votes on a proposal. */
    abstain?: string;
    /** no is the number of no votes on a proposal. */
    no?: string;
    /** no_with_veto is the number of no with veto votes on a proposal. */
    no_with_veto?: string;
  };
  /**
   * submit_time is the time of proposal submission.
   * @format date-time
   */
  submit_time?: string;
  /**
   * deposit_end_time is the end time for deposition.
   * @format date-time
   */
  deposit_end_time?: string;
  /** total_deposit is the total deposit on the proposal. */
  total_deposit?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * voting_start_time is the starting time to vote on a proposal.
   * @format date-time
   */
  voting_start_time?: string;
  /**
   * voting_end_time is the end time of voting on a proposal.
   * @format date-time
   */
  voting_end_time?: string;
}

/** QueryDepositResponse is the response type for the Query/Deposit RPC method. */
export interface CosmosGovV1Beta1QueryDepositResponse {
  /**
   * Deposit defines an amount deposited by an account address to an active
   * proposal.
   */
  deposit?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** depositor defines the deposit addresses from the proposals. */
    depositor?: string;
    /** amount to be deposited by depositor. */
    amount?: {
      denom?: string;
      amount?: string;
    }[];
  };
}

/** QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
export interface CosmosGovV1Beta1QueryDepositsResponse {
  /** deposits defines the requested deposits. */
  deposits?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** depositor defines the deposit addresses from the proposals. */
    depositor?: string;
    /** amount to be deposited by depositor. */
    amount?: {
      denom?: string;
      amount?: string;
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface CosmosGovV1Beta1QueryParamsResponse {
  /** voting_params defines the parameters related to voting. */
  voting_params?: {
    /** Duration of the voting period. */
    voting_period?: string;
  };
  /** deposit_params defines the parameters related to deposit. */
  deposit_params?: {
    /** Minimum deposit for a proposal to enter voting period. */
    min_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
     * months.
     */
    max_deposit_period?: string;
  };
  /** tally_params defines the parameters related to tally. */
  tally_params?: {
    /**
     * Minimum percentage of total stake needed to vote for a result to be
     * considered valid.
     * @format byte
     */
    quorum?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @format byte
     */
    threshold?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be
     * vetoed. Default value: 1/3.
     * @format byte
     */
    veto_threshold?: string;
  };
}

/** QueryProposalResponse is the response type for the Query/Proposal RPC method. */
export interface CosmosGovV1Beta1QueryProposalResponse {
  /** Proposal defines the core field members of a governance proposal. */
  proposal?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    content?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /**
     * status defines the proposal status.
     * @default "PROPOSAL_STATUS_UNSPECIFIED"
     */
    status?:
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /**
     * final_tally_result is the final tally result of the proposal. When
     * querying a proposal via gRPC, this field is not populated until the
     * proposal's voting period has ended.
     */
    final_tally_result?: {
      /** yes is the number of yes votes on a proposal. */
      yes?: string;
      /** abstain is the number of abstain votes on a proposal. */
      abstain?: string;
      /** no is the number of no votes on a proposal. */
      no?: string;
      /** no_with_veto is the number of no with veto votes on a proposal. */
      no_with_veto?: string;
    };
    /**
     * submit_time is the time of proposal submission.
     * @format date-time
     */
    submit_time?: string;
    /**
     * deposit_end_time is the end time for deposition.
     * @format date-time
     */
    deposit_end_time?: string;
    /** total_deposit is the total deposit on the proposal. */
    total_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * voting_start_time is the starting time to vote on a proposal.
     * @format date-time
     */
    voting_start_time?: string;
    /**
     * voting_end_time is the end time of voting on a proposal.
     * @format date-time
     */
    voting_end_time?: string;
  };
}

/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC
 * method.
 */
export interface CosmosGovV1Beta1QueryProposalsResponse {
  /** proposals defines all the requested governance proposals. */
  proposals?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    content?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /**
     * status defines the proposal status.
     * @default "PROPOSAL_STATUS_UNSPECIFIED"
     */
    status?:
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /**
     * final_tally_result is the final tally result of the proposal. When
     * querying a proposal via gRPC, this field is not populated until the
     * proposal's voting period has ended.
     */
    final_tally_result?: {
      /** yes is the number of yes votes on a proposal. */
      yes?: string;
      /** abstain is the number of abstain votes on a proposal. */
      abstain?: string;
      /** no is the number of no votes on a proposal. */
      no?: string;
      /** no_with_veto is the number of no with veto votes on a proposal. */
      no_with_veto?: string;
    };
    /**
     * submit_time is the time of proposal submission.
     * @format date-time
     */
    submit_time?: string;
    /**
     * deposit_end_time is the end time for deposition.
     * @format date-time
     */
    deposit_end_time?: string;
    /** total_deposit is the total deposit on the proposal. */
    total_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * voting_start_time is the starting time to vote on a proposal.
     * @format date-time
     */
    voting_start_time?: string;
    /**
     * voting_end_time is the end time of voting on a proposal.
     * @format date-time
     */
    voting_end_time?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
export interface CosmosGovV1Beta1QueryTallyResultResponse {
  /** tally defines the requested tally. */
  tally?: {
    /** yes is the number of yes votes on a proposal. */
    yes?: string;
    /** abstain is the number of abstain votes on a proposal. */
    abstain?: string;
    /** no is the number of no votes on a proposal. */
    no?: string;
    /** no_with_veto is the number of no with veto votes on a proposal. */
    no_with_veto?: string;
  };
}

/** QueryVoteResponse is the response type for the Query/Vote RPC method. */
export interface CosmosGovV1Beta1QueryVoteResponse {
  /**
   * Vote defines a vote on a governance proposal.
   * A Vote consists of a proposal ID, the voter, and the vote option.
   */
  vote?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** voter is the voter address of the proposal. */
    voter?: string;
    /**
     * Deprecated: Prefer to use `options` instead. This field is set in queries
     * if and only if `len(options) == 1` and that option has weight 1. In all
     * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
     * @default "VOTE_OPTION_UNSPECIFIED"
     */
    option?:
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /**
     * options is the weighted vote options.
     *
     * Since: cosmos-sdk 0.43
     */
    options?: {
      /**
       * option defines the valid vote options, it must not contain duplicate vote options.
       * @default "VOTE_OPTION_UNSPECIFIED"
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** weight is the vote weight associated with the vote option. */
      weight?: string;
    }[];
  };
}

/** QueryVotesResponse is the response type for the Query/Votes RPC method. */
export interface CosmosGovV1Beta1QueryVotesResponse {
  /** votes defines the queried votes. */
  votes?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** voter is the voter address of the proposal. */
    voter?: string;
    /**
     * Deprecated: Prefer to use `options` instead. This field is set in queries
     * if and only if `len(options) == 1` and that option has weight 1. In all
     * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
     * @default "VOTE_OPTION_UNSPECIFIED"
     */
    option?:
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /**
     * options is the weighted vote options.
     *
     * Since: cosmos-sdk 0.43
     */
    options?: {
      /**
       * option defines the valid vote options, it must not contain duplicate vote options.
       * @default "VOTE_OPTION_UNSPECIFIED"
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** weight is the vote weight associated with the vote option. */
      weight?: string;
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** TallyParams defines the params for tallying votes on governance proposals. */
export interface CosmosGovV1Beta1TallyParams {
  /**
   * Minimum percentage of total stake needed to vote for a result to be
   * considered valid.
   * @format byte
   */
  quorum?: string;
  /**
   * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
   * @format byte
   */
  threshold?: string;
  /**
   * Minimum value of Veto votes to Total votes ratio for proposal to be
   * vetoed. Default value: 1/3.
   * @format byte
   */
  veto_threshold?: string;
}

/** TallyResult defines a standard tally for a governance proposal. */
export interface CosmosGovV1Beta1TallyResult {
  /** yes is the number of yes votes on a proposal. */
  yes?: string;
  /** abstain is the number of abstain votes on a proposal. */
  abstain?: string;
  /** no is the number of no votes on a proposal. */
  no?: string;
  /** no_with_veto is the number of no with veto votes on a proposal. */
  no_with_veto?: string;
}

/**
 * Vote defines a vote on a governance proposal.
 * A Vote consists of a proposal ID, the voter, and the vote option.
 */
export interface CosmosGovV1Beta1Vote {
  /**
   * proposal_id defines the unique id of the proposal.
   * @format uint64
   */
  proposal_id?: string;
  /** voter is the voter address of the proposal. */
  voter?: string;
  /**
   * Deprecated: Prefer to use `options` instead. This field is set in queries
   * if and only if `len(options) == 1` and that option has weight 1. In all
   * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
   * @default "VOTE_OPTION_UNSPECIFIED"
   */
  option?:
    | "VOTE_OPTION_UNSPECIFIED"
    | "VOTE_OPTION_YES"
    | "VOTE_OPTION_ABSTAIN"
    | "VOTE_OPTION_NO"
    | "VOTE_OPTION_NO_WITH_VETO";
  /**
   * options is the weighted vote options.
   *
   * Since: cosmos-sdk 0.43
   */
  options?: {
    /**
     * option defines the valid vote options, it must not contain duplicate vote options.
     * @default "VOTE_OPTION_UNSPECIFIED"
     */
    option?:
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /** weight is the vote weight associated with the vote option. */
    weight?: string;
  }[];
}

/** VotingParams defines the params for voting on governance proposals. */
export interface CosmosGovV1Beta1VotingParams {
  /** Duration of the voting period. */
  voting_period?: string;
}

/**
 * WeightedVoteOption defines a unit of vote for vote split.
 *
 * Since: cosmos-sdk 0.43
 */
export interface CosmosGovV1Beta1WeightedVoteOption {
  /**
   * option defines the valid vote options, it must not contain duplicate vote options.
   * @default "VOTE_OPTION_UNSPECIFIED"
   */
  option?:
    | "VOTE_OPTION_UNSPECIFIED"
    | "VOTE_OPTION_YES"
    | "VOTE_OPTION_ABSTAIN"
    | "VOTE_OPTION_NO"
    | "VOTE_OPTION_NO_WITH_VETO";
  /** weight is the vote weight associated with the vote option. */
  weight?: string;
}

/**
 * Deposit defines an amount deposited by an account address to an active
 * proposal.
 */
export interface CosmosGovV1Deposit {
  /**
   * proposal_id defines the unique id of the proposal.
   * @format uint64
   */
  proposal_id?: string;
  /** depositor defines the deposit addresses from the proposals. */
  depositor?: string;
  /** amount to be deposited by depositor. */
  amount?: {
    denom?: string;
    amount?: string;
  }[];
}

/** DepositParams defines the params for deposits on governance proposals. */
export interface CosmosGovV1DepositParams {
  /** Minimum deposit for a proposal to enter voting period. */
  min_deposit?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
   * months.
   */
  max_deposit_period?: string;
}

/**
 * Params defines the parameters for the x/gov module.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosGovV1Params {
  /** Minimum deposit for a proposal to enter voting period. */
  min_deposit?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
   * months.
   */
  max_deposit_period?: string;
  /** Duration of the voting period. */
  voting_period?: string;
  /**
   * Minimum percentage of total stake needed to vote for a result to be
   *  considered valid.
   */
  quorum?: string;
  /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
  threshold?: string;
  /**
   * Minimum value of Veto votes to Total votes ratio for proposal to be
   *  vetoed. Default value: 1/3.
   */
  veto_threshold?: string;
  /** The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
  min_initial_deposit_ratio?: string;
  /**
   * The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
   *
   * Since: cosmos-sdk 0.50
   */
  proposal_cancel_ratio?: string;
  /**
   * The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
   * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
   *
   * Since: cosmos-sdk 0.50
   */
  proposal_cancel_dest?: string;
  /**
   * Duration of the voting period of an expedited proposal.
   *
   * Since: cosmos-sdk 0.50
   */
  expedited_voting_period?: string;
  /**
   * Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
   *
   * Since: cosmos-sdk 0.50
   */
  expedited_threshold?: string;
  /** Minimum expedited deposit for a proposal to enter voting period. */
  expedited_min_deposit?: {
    denom?: string;
    amount?: string;
  }[];
  /** burn deposits if a proposal does not meet quorum */
  burn_vote_quorum?: boolean;
  /** burn deposits if the proposal does not enter voting period */
  burn_proposal_deposit_prevote?: boolean;
  /** burn deposits if quorum with vote type no_veto is met */
  burn_vote_veto?: boolean;
  /**
   * The ratio representing the proportion of the deposit value minimum that must be met when making a deposit.
   * Default value: 0.01. Meaning that for a chain with a min_deposit of 100stake, a deposit of 1stake would be
   * required.
   *
   * Since: cosmos-sdk 0.50
   */
  min_deposit_ratio?: string;
}

/** Proposal defines the core field members of a governance proposal. */
export interface CosmosGovV1Proposal {
  /**
   * id defines the unique id of the proposal.
   * @format uint64
   */
  id?: string;
  /** messages are the arbitrary messages to be executed if the proposal passes. */
  messages?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
  /**
   * status defines the proposal status.
   * @default "PROPOSAL_STATUS_UNSPECIFIED"
   */
  status?:
    | "PROPOSAL_STATUS_UNSPECIFIED"
    | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
    | "PROPOSAL_STATUS_VOTING_PERIOD"
    | "PROPOSAL_STATUS_PASSED"
    | "PROPOSAL_STATUS_REJECTED"
    | "PROPOSAL_STATUS_FAILED";
  /**
   * final_tally_result is the final tally result of the proposal. When
   * querying a proposal via gRPC, this field is not populated until the
   * proposal's voting period has ended.
   */
  final_tally_result?: {
    /** yes_count is the number of yes votes on a proposal. */
    yes_count?: string;
    /** abstain_count is the number of abstain votes on a proposal. */
    abstain_count?: string;
    /** no_count is the number of no votes on a proposal. */
    no_count?: string;
    /** no_with_veto_count is the number of no with veto votes on a proposal. */
    no_with_veto_count?: string;
  };
  /**
   * submit_time is the time of proposal submission.
   * @format date-time
   */
  submit_time?: string;
  /**
   * deposit_end_time is the end time for deposition.
   * @format date-time
   */
  deposit_end_time?: string;
  /** total_deposit is the total deposit on the proposal. */
  total_deposit?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * voting_start_time is the starting time to vote on a proposal.
   * @format date-time
   */
  voting_start_time?: string;
  /**
   * voting_end_time is the end time of voting on a proposal.
   * @format date-time
   */
  voting_end_time?: string;
  /**
   * metadata is any arbitrary metadata attached to the proposal.
   * the recommended format of the metadata is to be found here:
   * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
   */
  metadata?: string;
  /**
   * title is the title of the proposal
   * Since: cosmos-sdk 0.47
   */
  title?: string;
  /**
   * summary is a short summary of the proposal
   * Since: cosmos-sdk 0.47
   */
  summary?: string;
  /**
   * proposer is the address of the proposal sumbitter
   * Since: cosmos-sdk 0.47
   */
  proposer?: string;
  /**
   * expedited defines if the proposal is expedited
   * Since: cosmos-sdk 0.50
   */
  expedited?: boolean;
  /**
   * failed_reason defines the reason why the proposal failed
   * Since: cosmos-sdk 0.50
   */
  failed_reason?: string;
}

/** QueryConstitutionResponse is the response type for the Query/Constitution RPC method */
export interface CosmosGovV1QueryConstitutionResponse {
  constitution?: string;
}

/** QueryDepositResponse is the response type for the Query/Deposit RPC method. */
export interface CosmosGovV1QueryDepositResponse {
  /**
   * Deposit defines an amount deposited by an account address to an active
   * proposal.
   */
  deposit?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** depositor defines the deposit addresses from the proposals. */
    depositor?: string;
    /** amount to be deposited by depositor. */
    amount?: {
      denom?: string;
      amount?: string;
    }[];
  };
}

/** QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
export interface CosmosGovV1QueryDepositsResponse {
  /** deposits defines the requested deposits. */
  deposits?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** depositor defines the deposit addresses from the proposals. */
    depositor?: string;
    /** amount to be deposited by depositor. */
    amount?: {
      denom?: string;
      amount?: string;
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface CosmosGovV1QueryParamsResponse {
  /**
   * Deprecated: Prefer to use `params` instead.
   * voting_params defines the parameters related to voting.
   */
  voting_params?: {
    /** Duration of the voting period. */
    voting_period?: string;
  };
  /**
   * Deprecated: Prefer to use `params` instead.
   * deposit_params defines the parameters related to deposit.
   */
  deposit_params?: {
    /** Minimum deposit for a proposal to enter voting period. */
    min_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
     * months.
     */
    max_deposit_period?: string;
  };
  /**
   * Deprecated: Prefer to use `params` instead.
   * tally_params defines the parameters related to tally.
   */
  tally_params?: {
    /**
     * Minimum percentage of total stake needed to vote for a result to be
     * considered valid.
     */
    quorum?: string;
    /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
    threshold?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be
     * vetoed. Default value: 1/3.
     */
    veto_threshold?: string;
  };
  /**
   * params defines all the paramaters of x/gov module.
   *
   * Since: cosmos-sdk 0.47
   */
  params?: {
    /** Minimum deposit for a proposal to enter voting period. */
    min_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
     * months.
     */
    max_deposit_period?: string;
    /** Duration of the voting period. */
    voting_period?: string;
    /**
     * Minimum percentage of total stake needed to vote for a result to be
     *  considered valid.
     */
    quorum?: string;
    /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
    threshold?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be
     *  vetoed. Default value: 1/3.
     */
    veto_threshold?: string;
    /** The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
    min_initial_deposit_ratio?: string;
    /**
     * The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
     *
     * Since: cosmos-sdk 0.50
     */
    proposal_cancel_ratio?: string;
    /**
     * The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
     * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
     *
     * Since: cosmos-sdk 0.50
     */
    proposal_cancel_dest?: string;
    /**
     * Duration of the voting period of an expedited proposal.
     *
     * Since: cosmos-sdk 0.50
     */
    expedited_voting_period?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
     *
     * Since: cosmos-sdk 0.50
     */
    expedited_threshold?: string;
    /** Minimum expedited deposit for a proposal to enter voting period. */
    expedited_min_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /** burn deposits if a proposal does not meet quorum */
    burn_vote_quorum?: boolean;
    /** burn deposits if the proposal does not enter voting period */
    burn_proposal_deposit_prevote?: boolean;
    /** burn deposits if quorum with vote type no_veto is met */
    burn_vote_veto?: boolean;
    /**
     * The ratio representing the proportion of the deposit value minimum that must be met when making a deposit.
     * Default value: 0.01. Meaning that for a chain with a min_deposit of 100stake, a deposit of 1stake would be
     * required.
     *
     * Since: cosmos-sdk 0.50
     */
    min_deposit_ratio?: string;
  };
}

/** QueryProposalResponse is the response type for the Query/Proposal RPC method. */
export interface CosmosGovV1QueryProposalResponse {
  /** Proposal defines the core field members of a governance proposal. */
  proposal?: {
    /**
     * id defines the unique id of the proposal.
     * @format uint64
     */
    id?: string;
    /** messages are the arbitrary messages to be executed if the proposal passes. */
    messages?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    }[];
    /**
     * status defines the proposal status.
     * @default "PROPOSAL_STATUS_UNSPECIFIED"
     */
    status?:
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /**
     * final_tally_result is the final tally result of the proposal. When
     * querying a proposal via gRPC, this field is not populated until the
     * proposal's voting period has ended.
     */
    final_tally_result?: {
      /** yes_count is the number of yes votes on a proposal. */
      yes_count?: string;
      /** abstain_count is the number of abstain votes on a proposal. */
      abstain_count?: string;
      /** no_count is the number of no votes on a proposal. */
      no_count?: string;
      /** no_with_veto_count is the number of no with veto votes on a proposal. */
      no_with_veto_count?: string;
    };
    /**
     * submit_time is the time of proposal submission.
     * @format date-time
     */
    submit_time?: string;
    /**
     * deposit_end_time is the end time for deposition.
     * @format date-time
     */
    deposit_end_time?: string;
    /** total_deposit is the total deposit on the proposal. */
    total_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * voting_start_time is the starting time to vote on a proposal.
     * @format date-time
     */
    voting_start_time?: string;
    /**
     * voting_end_time is the end time of voting on a proposal.
     * @format date-time
     */
    voting_end_time?: string;
    /**
     * metadata is any arbitrary metadata attached to the proposal.
     * the recommended format of the metadata is to be found here:
     * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
     */
    metadata?: string;
    /**
     * title is the title of the proposal
     * Since: cosmos-sdk 0.47
     */
    title?: string;
    /**
     * summary is a short summary of the proposal
     * Since: cosmos-sdk 0.47
     */
    summary?: string;
    /**
     * proposer is the address of the proposal sumbitter
     * Since: cosmos-sdk 0.47
     */
    proposer?: string;
    /**
     * expedited defines if the proposal is expedited
     * Since: cosmos-sdk 0.50
     */
    expedited?: boolean;
    /**
     * failed_reason defines the reason why the proposal failed
     * Since: cosmos-sdk 0.50
     */
    failed_reason?: string;
  };
}

/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC
 * method.
 */
export interface CosmosGovV1QueryProposalsResponse {
  /** proposals defines all the requested governance proposals. */
  proposals?: {
    /**
     * id defines the unique id of the proposal.
     * @format uint64
     */
    id?: string;
    /** messages are the arbitrary messages to be executed if the proposal passes. */
    messages?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    }[];
    /**
     * status defines the proposal status.
     * @default "PROPOSAL_STATUS_UNSPECIFIED"
     */
    status?:
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /**
     * final_tally_result is the final tally result of the proposal. When
     * querying a proposal via gRPC, this field is not populated until the
     * proposal's voting period has ended.
     */
    final_tally_result?: {
      /** yes_count is the number of yes votes on a proposal. */
      yes_count?: string;
      /** abstain_count is the number of abstain votes on a proposal. */
      abstain_count?: string;
      /** no_count is the number of no votes on a proposal. */
      no_count?: string;
      /** no_with_veto_count is the number of no with veto votes on a proposal. */
      no_with_veto_count?: string;
    };
    /**
     * submit_time is the time of proposal submission.
     * @format date-time
     */
    submit_time?: string;
    /**
     * deposit_end_time is the end time for deposition.
     * @format date-time
     */
    deposit_end_time?: string;
    /** total_deposit is the total deposit on the proposal. */
    total_deposit?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * voting_start_time is the starting time to vote on a proposal.
     * @format date-time
     */
    voting_start_time?: string;
    /**
     * voting_end_time is the end time of voting on a proposal.
     * @format date-time
     */
    voting_end_time?: string;
    /**
     * metadata is any arbitrary metadata attached to the proposal.
     * the recommended format of the metadata is to be found here:
     * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
     */
    metadata?: string;
    /**
     * title is the title of the proposal
     * Since: cosmos-sdk 0.47
     */
    title?: string;
    /**
     * summary is a short summary of the proposal
     * Since: cosmos-sdk 0.47
     */
    summary?: string;
    /**
     * proposer is the address of the proposal sumbitter
     * Since: cosmos-sdk 0.47
     */
    proposer?: string;
    /**
     * expedited defines if the proposal is expedited
     * Since: cosmos-sdk 0.50
     */
    expedited?: boolean;
    /**
     * failed_reason defines the reason why the proposal failed
     * Since: cosmos-sdk 0.50
     */
    failed_reason?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
export interface CosmosGovV1QueryTallyResultResponse {
  /** tally defines the requested tally. */
  tally?: {
    /** yes_count is the number of yes votes on a proposal. */
    yes_count?: string;
    /** abstain_count is the number of abstain votes on a proposal. */
    abstain_count?: string;
    /** no_count is the number of no votes on a proposal. */
    no_count?: string;
    /** no_with_veto_count is the number of no with veto votes on a proposal. */
    no_with_veto_count?: string;
  };
}

/** QueryVoteResponse is the response type for the Query/Vote RPC method. */
export interface CosmosGovV1QueryVoteResponse {
  /**
   * Vote defines a vote on a governance proposal.
   * A Vote consists of a proposal ID, the voter, and the vote option.
   */
  vote?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** voter is the voter address of the proposal. */
    voter?: string;
    /** options is the weighted vote options. */
    options?: {
      /**
       * option defines the valid vote options, it must not contain duplicate vote options.
       * @default "VOTE_OPTION_UNSPECIFIED"
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** weight is the vote weight associated with the vote option. */
      weight?: string;
    }[];
    /**
     * metadata is any arbitrary metadata attached to the vote.
     * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
     */
    metadata?: string;
  };
}

/** QueryVotesResponse is the response type for the Query/Votes RPC method. */
export interface CosmosGovV1QueryVotesResponse {
  /** votes defines the queried votes. */
  votes?: {
    /**
     * proposal_id defines the unique id of the proposal.
     * @format uint64
     */
    proposal_id?: string;
    /** voter is the voter address of the proposal. */
    voter?: string;
    /** options is the weighted vote options. */
    options?: {
      /**
       * option defines the valid vote options, it must not contain duplicate vote options.
       * @default "VOTE_OPTION_UNSPECIFIED"
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** weight is the vote weight associated with the vote option. */
      weight?: string;
    }[];
    /**
     * metadata is any arbitrary metadata attached to the vote.
     * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
     */
    metadata?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** TallyParams defines the params for tallying votes on governance proposals. */
export interface CosmosGovV1TallyParams {
  /**
   * Minimum percentage of total stake needed to vote for a result to be
   * considered valid.
   */
  quorum?: string;
  /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
  threshold?: string;
  /**
   * Minimum value of Veto votes to Total votes ratio for proposal to be
   * vetoed. Default value: 1/3.
   */
  veto_threshold?: string;
}

/** TallyResult defines a standard tally for a governance proposal. */
export interface CosmosGovV1TallyResult {
  /** yes_count is the number of yes votes on a proposal. */
  yes_count?: string;
  /** abstain_count is the number of abstain votes on a proposal. */
  abstain_count?: string;
  /** no_count is the number of no votes on a proposal. */
  no_count?: string;
  /** no_with_veto_count is the number of no with veto votes on a proposal. */
  no_with_veto_count?: string;
}

/**
 * Vote defines a vote on a governance proposal.
 * A Vote consists of a proposal ID, the voter, and the vote option.
 */
export interface CosmosGovV1Vote {
  /**
   * proposal_id defines the unique id of the proposal.
   * @format uint64
   */
  proposal_id?: string;
  /** voter is the voter address of the proposal. */
  voter?: string;
  /** options is the weighted vote options. */
  options?: {
    /**
     * option defines the valid vote options, it must not contain duplicate vote options.
     * @default "VOTE_OPTION_UNSPECIFIED"
     */
    option?:
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /** weight is the vote weight associated with the vote option. */
    weight?: string;
  }[];
  /**
   * metadata is any arbitrary metadata attached to the vote.
   * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
   */
  metadata?: string;
}

/** VotingParams defines the params for voting on governance proposals. */
export interface CosmosGovV1VotingParams {
  /** Duration of the voting period. */
  voting_period?: string;
}

/** WeightedVoteOption defines a unit of vote for vote split. */
export interface CosmosGovV1WeightedVoteOption {
  /**
   * option defines the valid vote options, it must not contain duplicate vote options.
   * @default "VOTE_OPTION_UNSPECIFIED"
   */
  option?:
    | "VOTE_OPTION_UNSPECIFIED"
    | "VOTE_OPTION_YES"
    | "VOTE_OPTION_ABSTAIN"
    | "VOTE_OPTION_NO"
    | "VOTE_OPTION_NO_WITH_VETO";
  /** weight is the vote weight associated with the vote option. */
  weight?: string;
}

/** ABCIMessageLog defines a structure containing an indexed tx ABCI message log. */
export interface CosmosBaseAbciV1Beta1ABCIMessageLog {
  /** @format int64 */
  msg_index?: number;
  log?: string;
  /**
   * Events contains a slice of Event objects that were emitted during some
   * execution.
   */
  events?: {
    type?: string;
    attributes?: {
      key?: string;
      value?: string;
    }[];
  }[];
}

/**
 * Attribute defines an attribute wrapper where the key and value are
 * strings instead of raw bytes.
 */
export interface CosmosBaseAbciV1Beta1Attribute {
  key?: string;
  value?: string;
}

/** GasInfo defines tx execution gas context. */
export interface CosmosBaseAbciV1Beta1GasInfo {
  /**
   * GasWanted is the maximum units of work we allow this tx to perform.
   * @format uint64
   */
  gas_wanted?: string;
  /**
   * GasUsed is the amount of gas actually consumed.
   * @format uint64
   */
  gas_used?: string;
}

/** Result is the union of ResponseFormat and ResponseCheckTx. */
export interface CosmosBaseAbciV1Beta1Result {
  /**
   * Data is any data returned from message or handler execution. It MUST be
   * length prefixed in order to separate data from multiple message executions.
   * Deprecated. This field is still populated, but prefer msg_response instead
   * because it also contains the Msg response typeURL.
   * @format byte
   */
  data?: string;
  /** Log contains the log information from message or handler execution. */
  log?: string;
  /**
   * Events contains a slice of Event objects that were emitted during message
   * or handler execution.
   */
  events?: {
    type?: string;
    attributes?: {
      key?: string;
      value?: string;
      index?: boolean;
    }[];
  }[];
  /**
   * msg_responses contains the Msg handler responses type packed in Anys.
   *
   * Since: cosmos-sdk 0.46
   */
  msg_responses?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
}

/**
 * StringEvent defines en Event object wrapper where all the attributes
 * contain key/value pairs that are strings instead of raw bytes.
 */
export interface CosmosBaseAbciV1Beta1StringEvent {
  type?: string;
  attributes?: {
    key?: string;
    value?: string;
  }[];
}

/**
 * TxResponse defines a structure containing relevant tx data and metadata. The
 * tags are stringified and the log is JSON decoded.
 */
export interface CosmosBaseAbciV1Beta1TxResponse {
  /**
   * The block height
   * @format int64
   */
  height?: string;
  /** The transaction hash. */
  txhash?: string;
  /** Namespace for the Code */
  codespace?: string;
  /**
   * Response code.
   * @format int64
   */
  code?: number;
  /** Result bytes, if any. */
  data?: string;
  /**
   * The output of the application's logger (raw string). May be
   * non-deterministic.
   */
  raw_log?: string;
  /** The output of the application's logger (typed). May be non-deterministic. */
  logs?: {
    /** @format int64 */
    msg_index?: number;
    log?: string;
    /**
     * Events contains a slice of Event objects that were emitted during some
     * execution.
     */
    events?: {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
      }[];
    }[];
  }[];
  /** Additional information. May be non-deterministic. */
  info?: string;
  /**
   * Amount of gas requested for transaction.
   * @format int64
   */
  gas_wanted?: string;
  /**
   * Amount of gas consumed by transaction.
   * @format int64
   */
  gas_used?: string;
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  tx?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * Time of the previous block. For heights > 1, it's the weighted median of
   * the timestamps of the valid votes in the block.LastCommit. For height == 1,
   * it's genesis time.
   */
  timestamp?: string;
  /**
   * Events defines all the events emitted by processing a transaction. Note,
   * these events include those emitted by processing all the messages and those
   * emitted from the ante. Whereas Logs contains the events, with
   * additional metadata, emitted only by processing the messages.
   *
   * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
   */
  events?: {
    type?: string;
    attributes?: {
      key?: string;
      value?: string;
      index?: boolean;
    }[];
  }[];
}

/**
 * CompactBitArray is an implementation of a space efficient bit array.
 * This is used to ensure that the encoded data takes up a minimal amount of
 * space after proto encoding.
 * This is not thread safe, and is not intended for concurrent usage.
 */
export interface CosmosCryptoMultisigV1Beta1CompactBitArray {
  /** @format int64 */
  extra_bits_stored?: number;
  /** @format byte */
  elems?: string;
}

/**
 * AuthInfo describes the fee and signer modes that are used to sign a
 * transaction.
 */
export interface CosmosTxV1Beta1AuthInfo {
  /**
   * signer_infos defines the signing modes for the required signers. The number
   * and order of elements must match the required signers from TxBody's
   * messages. The first element is the primary signer and the one which pays
   * the fee.
   */
  signer_infos?: CosmosTxV1Beta1SignerInfo[];
  /**
   * Fee is the fee and gas limit for the transaction. The first signer is the
   * primary signer and the one which pays the fee. The fee can be calculated
   * based on the cost of evaluating the body and doing signature verification
   * of the signers. This can be estimated via simulation.
   */
  fee?: {
    /** amount is the amount of coins to be paid as a fee */
    amount?: {
      denom?: string;
      amount?: string;
    }[];
    /**
     * gas_limit is the maximum gas that can be used in transaction processing
     * before an out of gas error occurs
     * @format uint64
     */
    gas_limit?: string;
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
     * the payer must be a tx signer (and thus have signed this field in AuthInfo).
     * setting this field does *not* change the ordering of required signers for the transaction.
     */
    payer?: string;
    /**
     * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
     * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
     * not support fee grants, this will fail
     */
    granter?: string;
  };
  /**
   * Tip is the optional tip used for transactions fees paid in another denom.
   *
   * This field is ignored if the chain didn't enable tips, i.e. didn't add the
   * `TipDecorator` in its posthandler.
   *
   * Since: cosmos-sdk 0.46
   */
  tip?: {
    /** amount is the amount of the tip */
    amount?: {
      denom?: string;
      amount?: string;
    }[];
    /** tipper is the address of the account paying for the tip */
    tipper?: string;
  };
}

/**
 * BroadcastTxRequest is the request type for the Service.BroadcastTxRequest
 * RPC method.
 */
export interface CosmosTxV1Beta1BroadcastTxRequest {
  /**
   * tx_bytes is the raw transaction.
   * @format byte
   */
  tx_bytes?: string;
  /**
   * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
   * method.
   *
   *  - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
   *  - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
   * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
   *  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
   * for a CheckTx execution response only.
   *  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
   * returns immediately.
   * @default "BROADCAST_MODE_UNSPECIFIED"
   */
  mode?:
    | "BROADCAST_MODE_UNSPECIFIED"
    | "BROADCAST_MODE_BLOCK"
    | "BROADCAST_MODE_SYNC"
    | "BROADCAST_MODE_ASYNC";
}

/**
 * BroadcastTxResponse is the response type for the
 * Service.BroadcastTx method.
 */
export interface CosmosTxV1Beta1BroadcastTxResponse {
  /**
   * TxResponse defines a structure containing relevant tx data and metadata. The
   * tags are stringified and the log is JSON decoded.
   */
  tx_response?: {
    /**
     * The block height
     * @format int64
     */
    height?: string;
    /** The transaction hash. */
    txhash?: string;
    /** Namespace for the Code */
    codespace?: string;
    /**
     * Response code.
     * @format int64
     */
    code?: number;
    /** Result bytes, if any. */
    data?: string;
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     */
    raw_log?: string;
    /** The output of the application's logger (typed). May be non-deterministic. */
    logs?: {
      /** @format int64 */
      msg_index?: number;
      log?: string;
      /**
       * Events contains a slice of Event objects that were emitted during some
       * execution.
       */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
        }[];
      }[];
    }[];
    /** Additional information. May be non-deterministic. */
    info?: string;
    /**
     * Amount of gas requested for transaction.
     * @format int64
     */
    gas_wanted?: string;
    /**
     * Amount of gas consumed by transaction.
     * @format int64
     */
    gas_used?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    tx?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /**
     * Time of the previous block. For heights > 1, it's the weighted median of
     * the timestamps of the valid votes in the block.LastCommit. For height == 1,
     * it's genesis time.
     */
    timestamp?: string;
    /**
     * Events defines all the events emitted by processing a transaction. Note,
     * these events include those emitted by processing all the messages and those
     * emitted from the ante. Whereas Logs contains the events, with
     * additional metadata, emitted only by processing the messages.
     *
     * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
     */
    events?: {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
        index?: boolean;
      }[];
    }[];
  };
}

/**
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 */
export interface CosmosTxV1Beta1Fee {
  /** amount is the amount of coins to be paid as a fee */
  amount?: {
    denom?: string;
    amount?: string;
  }[];
  /**
   * gas_limit is the maximum gas that can be used in transaction processing
   * before an out of gas error occurs
   * @format uint64
   */
  gas_limit?: string;
  /**
   * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
   * the payer must be a tx signer (and thus have signed this field in AuthInfo).
   * setting this field does *not* change the ordering of required signers for the transaction.
   */
  payer?: string;
  /**
   * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
   * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
   * not support fee grants, this will fail
   */
  granter?: string;
}

/**
 * GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs
 * method.
 *
 * Since: cosmos-sdk 0.45.2
 */
export interface CosmosTxV1Beta1GetBlockWithTxsResponse {
  /** txs are the transactions in the block. */
  txs?: CosmosTxV1Beta1Tx[];
  /** BlockID */
  block_id?: {
    /** @format byte */
    hash?: string;
    /** PartsetHeader */
    part_set_header?: {
      /** @format int64 */
      total?: number;
      /** @format byte */
      hash?: string;
    };
  };
  block?: {
    /** Header defines the structure of a block header. */
    header?: {
      /**
       * basic block info
       * Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** @format uint64 */
        block?: string;
        /** @format uint64 */
        app?: string;
      };
      chain_id?: string;
      /** @format int64 */
      height?: string;
      /** @format date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * @format byte
       */
      last_commit_hash?: string;
      /** @format byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * @format byte
       */
      validators_hash?: string;
      /** @format byte */
      next_validators_hash?: string;
      /** @format byte */
      consensus_hash?: string;
      /** @format byte */
      app_hash?: string;
      /** @format byte */
      last_results_hash?: string;
      /**
       * consensus info
       * @format byte
       */
      evidence_hash?: string;
      /** @format byte */
      proposer_address?: string;
    };
    /** Data contains the set of transactions included in the block */
    data?: {
      /**
       * Txs that will be applied by state @ block.Height+1.
       * NOTE: not all txs here are valid.  We're just agreeing on the order first.
       * This means that block.AppHash does not include these txs.
       */
      txs?: string[];
    };
    evidence?: {
      evidence?: {
        /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_a?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /**
           * Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_b?: {
            /**
             * SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default "SIGNED_MSG_TYPE_UNKNOWN"
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** @format int64 */
            height?: string;
            /** @format int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** @format byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** @format int64 */
                total?: number;
                /** @format byte */
                hash?: string;
              };
            };
            /** @format date-time */
            timestamp?: string;
            /** @format byte */
            validator_address?: string;
            /** @format int32 */
            validator_index?: number;
            /**
             * Vote signature by the validator if they participated in consensus for the
             * associated block.
             * @format byte
             */
            signature?: string;
            /**
             * Vote extension provided by the application. Only valid for precommit
             * messages.
             * @format byte
             */
            extension?: string;
            /**
             * Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             * @format byte
             */
            extension_signature?: string;
          };
          /** @format int64 */
          total_voting_power?: string;
          /** @format int64 */
          validator_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
        /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** @format uint64 */
                  block?: string;
                  /** @format uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** @format int64 */
                height?: string;
                /** @format date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * @format byte
                 */
                last_commit_hash?: string;
                /** @format byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * @format byte
                 */
                validators_hash?: string;
                /** @format byte */
                next_validators_hash?: string;
                /** @format byte */
                consensus_hash?: string;
                /** @format byte */
                app_hash?: string;
                /** @format byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * @format byte
                 */
                evidence_hash?: string;
                /** @format byte */
                proposer_address?: string;
              };
              /** Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** @format int64 */
                height?: string;
                /** @format int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** @format byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** @format int64 */
                    total?: number;
                    /** @format byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default "BLOCK_ID_FLAG_UNKNOWN"
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** @format byte */
                  validator_address?: string;
                  /** @format date-time */
                  timestamp?: string;
                  /** @format byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** @format byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** @format byte */
                  ed25519?: string;
                  /** @format byte */
                  secp256k1?: string;
                };
                /** @format int64 */
                voting_power?: string;
                /** @format int64 */
                proposer_priority?: string;
              };
              /** @format int64 */
              total_voting_power?: string;
            };
          };
          /** @format int64 */
          common_height?: string;
          byzantine_validators?: {
            /** @format byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** @format byte */
              ed25519?: string;
              /** @format byte */
              secp256k1?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** @format int64 */
          total_voting_power?: string;
          /** @format date-time */
          timestamp?: string;
        };
      }[];
    };
    /** Commit contains the evidence that a block was committed by a set of validators. */
    last_commit?: {
      /** @format int64 */
      height?: string;
      /** @format int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** @format byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** @format int64 */
          total?: number;
          /** @format byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default "BLOCK_ID_FLAG_UNKNOWN"
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** @format byte */
        validator_address?: string;
        /** @format date-time */
        timestamp?: string;
        /** @format byte */
        signature?: string;
      }[];
    };
  };
  /** pagination defines a pagination for the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** GetTxResponse is the response type for the Service.GetTx method. */
export interface CosmosTxV1Beta1GetTxResponse {
  /** tx is the queried transaction. */
  tx?: CosmosTxV1Beta1Tx;
  /**
   * TxResponse defines a structure containing relevant tx data and metadata. The
   * tags are stringified and the log is JSON decoded.
   */
  tx_response?: {
    /**
     * The block height
     * @format int64
     */
    height?: string;
    /** The transaction hash. */
    txhash?: string;
    /** Namespace for the Code */
    codespace?: string;
    /**
     * Response code.
     * @format int64
     */
    code?: number;
    /** Result bytes, if any. */
    data?: string;
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     */
    raw_log?: string;
    /** The output of the application's logger (typed). May be non-deterministic. */
    logs?: {
      /** @format int64 */
      msg_index?: number;
      log?: string;
      /**
       * Events contains a slice of Event objects that were emitted during some
       * execution.
       */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
        }[];
      }[];
    }[];
    /** Additional information. May be non-deterministic. */
    info?: string;
    /**
     * Amount of gas requested for transaction.
     * @format int64
     */
    gas_wanted?: string;
    /**
     * Amount of gas consumed by transaction.
     * @format int64
     */
    gas_used?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    tx?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /**
     * Time of the previous block. For heights > 1, it's the weighted median of
     * the timestamps of the valid votes in the block.LastCommit. For height == 1,
     * it's genesis time.
     */
    timestamp?: string;
    /**
     * Events defines all the events emitted by processing a transaction. Note,
     * these events include those emitted by processing all the messages and those
     * emitted from the ante. Whereas Logs contains the events, with
     * additional metadata, emitted only by processing the messages.
     *
     * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
     */
    events?: {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
        index?: boolean;
      }[];
    }[];
  };
}

/**
 * GetTxsEventResponse is the response type for the Service.TxsByEvents
 * RPC method.
 */
export interface CosmosTxV1Beta1GetTxsEventResponse {
  /** txs is the list of queried transactions. */
  txs?: CosmosTxV1Beta1Tx[];
  /** tx_responses is the list of queried TxResponses. */
  tx_responses?: {
    /**
     * The block height
     * @format int64
     */
    height?: string;
    /** The transaction hash. */
    txhash?: string;
    /** Namespace for the Code */
    codespace?: string;
    /**
     * Response code.
     * @format int64
     */
    code?: number;
    /** Result bytes, if any. */
    data?: string;
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     */
    raw_log?: string;
    /** The output of the application's logger (typed). May be non-deterministic. */
    logs?: {
      /** @format int64 */
      msg_index?: number;
      log?: string;
      /**
       * Events contains a slice of Event objects that were emitted during some
       * execution.
       */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
        }[];
      }[];
    }[];
    /** Additional information. May be non-deterministic. */
    info?: string;
    /**
     * Amount of gas requested for transaction.
     * @format int64
     */
    gas_wanted?: string;
    /**
     * Amount of gas consumed by transaction.
     * @format int64
     */
    gas_used?: string;
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    tx?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
    /**
     * Time of the previous block. For heights > 1, it's the weighted median of
     * the timestamps of the valid votes in the block.LastCommit. For height == 1,
     * it's genesis time.
     */
    timestamp?: string;
    /**
     * Events defines all the events emitted by processing a transaction. Note,
     * these events include those emitted by processing all the messages and those
     * emitted from the ante. Whereas Logs contains the events, with
     * additional metadata, emitted only by processing the messages.
     *
     * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
     */
    events?: {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
        index?: boolean;
      }[];
    }[];
  }[];
  /**
   * pagination defines a pagination for the response.
   * Deprecated post v0.46.x: use total instead.
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
  /**
   * total is total number of results available
   * @format uint64
   */
  total?: string;
}

/** ModeInfo describes the signing mode of a single or nested multisig signer. */
export interface CosmosTxV1Beta1ModeInfo {
  /** single represents a single signer */
  single?: {
    /**
     * mode is the signing mode of the single signer
     * SignMode represents a signing mode with its own security guarantees.
     *
     * This enum should be considered a registry of all known sign modes
     * in the Cosmos ecosystem. Apps are not expected to support all known
     * sign modes. Apps that would like to support custom  sign modes are
     * encouraged to open a small PR against this file to add a new case
     * to this SignMode enum describing their sign mode so that different
     * apps have a consistent version of this enum.
     *
     *  - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
     * rejected.
     *  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
     * verified with raw bytes from Tx.
     *  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
     * human-readable textual representation on top of the binary representation
     * from SIGN_MODE_DIRECT.
     *
     * Since: cosmos-sdk 0.50
     *  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
     * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
     * require signers signing over other signers' `signer_info`.
     *
     * Since: cosmos-sdk 0.46
     *  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
     * Amino JSON and will be removed in the future.
     *  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
     * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
     *
     * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
     * but is not implemented on the SDK by default. To enable EIP-191, you need
     * to pass a custom `TxConfig` that has an implementation of
     * `SignModeHandler` for EIP-191. The SDK may decide to fully support
     * EIP-191 in the future.
     *
     * Since: cosmos-sdk 0.45.2
     * @default "SIGN_MODE_UNSPECIFIED"
     */
    mode?:
      | "SIGN_MODE_UNSPECIFIED"
      | "SIGN_MODE_DIRECT"
      | "SIGN_MODE_TEXTUAL"
      | "SIGN_MODE_DIRECT_AUX"
      | "SIGN_MODE_LEGACY_AMINO_JSON"
      | "SIGN_MODE_EIP_191";
  };
  /** multi represents a nested multisig signer */
  multi?: CosmosTxV1Beta1ModeInfoMulti;
}

/** Multi is the mode info for a multisig public key */
export interface CosmosTxV1Beta1ModeInfoMulti {
  /**
   * bitarray specifies which keys within the multisig are signing
   * CompactBitArray is an implementation of a space efficient bit array.
   * This is used to ensure that the encoded data takes up a minimal amount of
   * space after proto encoding.
   * This is not thread safe, and is not intended for concurrent usage.
   */
  bitarray?: {
    /** @format int64 */
    extra_bits_stored?: number;
    /** @format byte */
    elems?: string;
  };
  /**
   * mode_infos is the corresponding modes of the signers of the multisig
   * which could include nested multisig public keys
   */
  mode_infos?: CosmosTxV1Beta1ModeInfo[];
}

/**
 * Single is the mode info for a single signer. It is structured as a message
 * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
 * future
 */
export interface CosmosTxV1Beta1ModeInfoSingle {
  /**
   * mode is the signing mode of the single signer
   * SignMode represents a signing mode with its own security guarantees.
   *
   * This enum should be considered a registry of all known sign modes
   * in the Cosmos ecosystem. Apps are not expected to support all known
   * sign modes. Apps that would like to support custom  sign modes are
   * encouraged to open a small PR against this file to add a new case
   * to this SignMode enum describing their sign mode so that different
   * apps have a consistent version of this enum.
   *
   *  - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
   * rejected.
   *  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
   * verified with raw bytes from Tx.
   *  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
   * human-readable textual representation on top of the binary representation
   * from SIGN_MODE_DIRECT.
   *
   * Since: cosmos-sdk 0.50
   *  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
   * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
   * require signers signing over other signers' `signer_info`.
   *
   * Since: cosmos-sdk 0.46
   *  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
   * Amino JSON and will be removed in the future.
   *  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
   * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
   *
   * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
   * but is not implemented on the SDK by default. To enable EIP-191, you need
   * to pass a custom `TxConfig` that has an implementation of
   * `SignModeHandler` for EIP-191. The SDK may decide to fully support
   * EIP-191 in the future.
   *
   * Since: cosmos-sdk 0.45.2
   * @default "SIGN_MODE_UNSPECIFIED"
   */
  mode?:
    | "SIGN_MODE_UNSPECIFIED"
    | "SIGN_MODE_DIRECT"
    | "SIGN_MODE_TEXTUAL"
    | "SIGN_MODE_DIRECT_AUX"
    | "SIGN_MODE_LEGACY_AMINO_JSON"
    | "SIGN_MODE_EIP_191";
}

/**
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 */
export interface CosmosTxV1Beta1SignerInfo {
  /**
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  public_key?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * mode_info describes the signing mode of the signer and is a nested
   * structure to support nested multisig pubkey's
   * ModeInfo describes the signing mode of a single or nested multisig signer.
   */
  mode_info?: CosmosTxV1Beta1ModeInfo;
  /**
   * sequence is the sequence of the account, which describes the
   * number of committed transactions signed by a given address. It is used to
   * prevent replay attacks.
   * @format uint64
   */
  sequence?: string;
}

/**
 * SimulateRequest is the request type for the Service.Simulate
 * RPC method.
 */
export interface CosmosTxV1Beta1SimulateRequest {
  /**
   * tx is the transaction to simulate.
   * Deprecated. Send raw tx bytes instead.
   */
  tx?: CosmosTxV1Beta1Tx;
  /**
   * tx_bytes is the raw transaction.
   *
   * Since: cosmos-sdk 0.43
   * @format byte
   */
  tx_bytes?: string;
}

/**
 * SimulateResponse is the response type for the
 * Service.SimulateRPC method.
 */
export interface CosmosTxV1Beta1SimulateResponse {
  /** gas_info is the information about gas used in the simulation. */
  gas_info?: {
    /**
     * GasWanted is the maximum units of work we allow this tx to perform.
     * @format uint64
     */
    gas_wanted?: string;
    /**
     * GasUsed is the amount of gas actually consumed.
     * @format uint64
     */
    gas_used?: string;
  };
  /** result is the result of the simulation. */
  result?: {
    /**
     * Data is any data returned from message or handler execution. It MUST be
     * length prefixed in order to separate data from multiple message executions.
     * Deprecated. This field is still populated, but prefer msg_response instead
     * because it also contains the Msg response typeURL.
     * @format byte
     */
    data?: string;
    /** Log contains the log information from message or handler execution. */
    log?: string;
    /**
     * Events contains a slice of Event objects that were emitted during message
     * or handler execution.
     */
    events?: {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
        index?: boolean;
      }[];
    }[];
    /**
     * msg_responses contains the Msg handler responses type packed in Anys.
     *
     * Since: cosmos-sdk 0.46
     */
    msg_responses?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    }[];
  };
}

/**
 * Tip is the tip used for meta-transactions.
 *
 * Since: cosmos-sdk 0.46
 */
export interface CosmosTxV1Beta1Tip {
  /** amount is the amount of the tip */
  amount?: {
    denom?: string;
    amount?: string;
  }[];
  /** tipper is the address of the account paying for the tip */
  tipper?: string;
}

/** Tx is the standard type used for broadcasting transactions. */
export interface CosmosTxV1Beta1Tx {
  /**
   * body is the processable content of the transaction
   * TxBody is the body of a transaction that all signers sign over.
   */
  body?: {
    /**
     * messages is a list of messages to be executed. The required signers of
     * those messages define the number and order of elements in AuthInfo's
     * signer_infos and Tx's signatures. Each required signer address is added to
     * the list only the first time it occurs.
     * By convention, the first required signer (usually from the first message)
     * is referred to as the primary signer and pays the fee for the whole
     * transaction.
     */
    messages?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    }[];
    /**
     * memo is any arbitrary note/comment to be added to the transaction.
     * WARNING: in clients, any publicly exposed text should not be called memo,
     * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
     */
    memo?: string;
    /**
     * timeout is the block height after which this transaction will not
     * be processed by the chain
     * @format uint64
     */
    timeout_height?: string;
    /**
     * extension_options are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, the transaction will be rejected
     */
    extension_options?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    }[];
    /**
     * extension_options are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, they will be ignored
     */
    non_critical_extension_options?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    }[];
  };
  /**
   * auth_info is the authorization related content of the transaction,
   * specifically signers, signer modes and fee
   * AuthInfo describes the fee and signer modes that are used to sign a
   * transaction.
   */
  auth_info?: CosmosTxV1Beta1AuthInfo;
  /**
   * signatures is a list of signatures that matches the length and order of
   * AuthInfo's signer_infos to allow connecting signature meta information like
   * public key and signing mode by position.
   */
  signatures?: string[];
}

/** TxBody is the body of a transaction that all signers sign over. */
export interface CosmosTxV1Beta1TxBody {
  /**
   * messages is a list of messages to be executed. The required signers of
   * those messages define the number and order of elements in AuthInfo's
   * signer_infos and Tx's signatures. Each required signer address is added to
   * the list only the first time it occurs.
   * By convention, the first required signer (usually from the first message)
   * is referred to as the primary signer and pays the fee for the whole
   * transaction.
   */
  messages?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
  /**
   * memo is any arbitrary note/comment to be added to the transaction.
   * WARNING: in clients, any publicly exposed text should not be called memo,
   * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
   */
  memo?: string;
  /**
   * timeout is the block height after which this transaction will not
   * be processed by the chain
   * @format uint64
   */
  timeout_height?: string;
  /**
   * extension_options are arbitrary options that can be added by chains
   * when the default options are not sufficient. If any of these are present
   * and can't be handled, the transaction will be rejected
   */
  extension_options?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
  /**
   * extension_options are arbitrary options that can be added by chains
   * when the default options are not sufficient. If any of these are present
   * and can't be handled, they will be ignored
   */
  non_critical_extension_options?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  }[];
}

/**
 * TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino
 * RPC method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxDecodeAminoRequest {
  /** @format byte */
  amino_binary?: string;
}

/**
 * TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino
 * RPC method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxDecodeAminoResponse {
  amino_json?: string;
}

/**
 * TxDecodeRequest is the request type for the Service.TxDecode
 * RPC method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxDecodeRequest {
  /**
   * tx_bytes is the raw transaction.
   * @format byte
   */
  tx_bytes?: string;
}

/**
 * TxDecodeResponse is the response type for the
 * Service.TxDecode method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxDecodeResponse {
  /** tx is the decoded transaction. */
  tx?: CosmosTxV1Beta1Tx;
}

/**
 * TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino
 * RPC method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxEncodeAminoRequest {
  amino_json?: string;
}

/**
 * TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino
 * RPC method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxEncodeAminoResponse {
  /** @format byte */
  amino_binary?: string;
}

/**
 * TxEncodeRequest is the request type for the Service.TxEncode
 * RPC method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxEncodeRequest {
  /** tx is the transaction to encode. */
  tx?: CosmosTxV1Beta1Tx;
}

/**
 * TxEncodeResponse is the response type for the
 * Service.TxEncode method.
 *
 * Since: cosmos-sdk 0.47
 */
export interface CosmosTxV1Beta1TxEncodeResponse {
  /**
   * tx_bytes is the encoded transaction bytes.
   * @format byte
   */
  tx_bytes?: string;
}

/**
 * Event allows application developers to attach additional information to
 * ResponseFinalizeBlock and ResponseCheckTx.
 * Later, transactions may be queried using these events.
 */
export interface TendermintAbciEvent {
  type?: string;
  attributes?: {
    key?: string;
    value?: string;
    index?: boolean;
  }[];
}

/** EventAttribute is a single key-value pair, associated with an event. */
export interface TendermintAbciEventAttribute {
  key?: string;
  value?: string;
  index?: boolean;
}

/** Params represents the parameters used for by the slashing module. */
export interface CosmosSlashingV1Beta1Params {
  /** @format int64 */
  signed_blocks_window?: string;
  /** @format byte */
  min_signed_per_window?: string;
  downtime_jail_duration?: string;
  /** @format byte */
  slash_fraction_double_sign?: string;
  /** @format byte */
  slash_fraction_downtime?: string;
}

/** QueryParamsResponse is the response type for the Query/Params RPC method */
export interface CosmosSlashingV1Beta1QueryParamsResponse {
  /** Params represents the parameters used for by the slashing module. */
  params?: {
    /** @format int64 */
    signed_blocks_window?: string;
    /** @format byte */
    min_signed_per_window?: string;
    downtime_jail_duration?: string;
    /** @format byte */
    slash_fraction_double_sign?: string;
    /** @format byte */
    slash_fraction_downtime?: string;
  };
}

/**
 * QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
 * method
 */
export interface CosmosSlashingV1Beta1QuerySigningInfoResponse {
  /**
   * val_signing_info is the signing info of requested val cons address
   * ValidatorSigningInfo defines a validator's signing info for monitoring their
   * liveness activity.
   */
  val_signing_info?: {
    address?: string;
    /**
     * Height at which validator was first a candidate OR was un-jailed
     * @format int64
     */
    start_height?: string;
    /**
     * Index which is incremented every time a validator is bonded in a block and
     * _may_ have signed a pre-commit or not. This in conjunction with the
     * signed_blocks_window param determines the index in the missed block bitmap.
     * @format int64
     */
    index_offset?: string;
    /**
     * Timestamp until which the validator is jailed due to liveness downtime.
     * @format date-time
     */
    jailed_until?: string;
    /**
     * Whether or not a validator has been tombstoned (killed out of validator
     * set). It is set once the validator commits an equivocation or for any other
     * configured misbehavior.
     */
    tombstoned?: boolean;
    /**
     * A counter of missed (unsigned) blocks. It is used to avoid unnecessary
     * reads in the missed block bitmap.
     * @format int64
     */
    missed_blocks_counter?: string;
  };
}

/**
 * QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
 * method
 */
export interface CosmosSlashingV1Beta1QuerySigningInfosResponse {
  /** info is the signing info of all validators */
  info?: {
    address?: string;
    /**
     * Height at which validator was first a candidate OR was un-jailed
     * @format int64
     */
    start_height?: string;
    /**
     * Index which is incremented every time a validator is bonded in a block and
     * _may_ have signed a pre-commit or not. This in conjunction with the
     * signed_blocks_window param determines the index in the missed block bitmap.
     * @format int64
     */
    index_offset?: string;
    /**
     * Timestamp until which the validator is jailed due to liveness downtime.
     * @format date-time
     */
    jailed_until?: string;
    /**
     * Whether or not a validator has been tombstoned (killed out of validator
     * set). It is set once the validator commits an equivocation or for any other
     * configured misbehavior.
     */
    tombstoned?: boolean;
    /**
     * A counter of missed (unsigned) blocks. It is used to avoid unnecessary
     * reads in the missed block bitmap.
     * @format int64
     */
    missed_blocks_counter?: string;
  }[];
  /**
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * ValidatorSigningInfo defines a validator's signing info for monitoring their
 * liveness activity.
 */
export interface CosmosSlashingV1Beta1ValidatorSigningInfo {
  address?: string;
  /**
   * Height at which validator was first a candidate OR was un-jailed
   * @format int64
   */
  start_height?: string;
  /**
   * Index which is incremented every time a validator is bonded in a block and
   * _may_ have signed a pre-commit or not. This in conjunction with the
   * signed_blocks_window param determines the index in the missed block bitmap.
   * @format int64
   */
  index_offset?: string;
  /**
   * Timestamp until which the validator is jailed due to liveness downtime.
   * @format date-time
   */
  jailed_until?: string;
  /**
   * Whether or not a validator has been tombstoned (killed out of validator
   * set). It is set once the validator commits an equivocation or for any other
   * configured misbehavior.
   */
  tombstoned?: boolean;
  /**
   * A counter of missed (unsigned) blocks. It is used to avoid unnecessary
   * reads in the missed block bitmap.
   * @format int64
   */
  missed_blocks_counter?: string;
}

export interface RatelimitV1Flow {
  /**
   * Inflow defines the total amount of inbound transfers for the given
   * rate limit in the current window
   */
  inflow?: string;
  /**
   * Outflow defines the total amount of outbound transfers for the given
   * rate limit in the current window
   */
  outflow?: string;
  /**
   * ChannelValue stores the total supply of the denom at the start of
   * the rate limit. This is used as the denominator when checking
   * the rate limit threshold
   * The ChannelValue is fixed for the duration of the rate limit window
   */
  channel_value?: string;
}

/** Path holds the denom and channelID that define the rate limited route */
export interface RatelimitV1Path {
  denom?: string;
  channel_id?: string;
}

export interface RatelimitV1QueryAllBlacklistedDenomsResponse {
  denoms?: string[];
}

export interface RatelimitV1QueryAllRateLimitsResponse {
  rate_limits?: {
    /** Path holds the denom and channelID that define the rate limited route */
    path?: {
      denom?: string;
      channel_id?: string;
    };
    /** Quota defines the rate limit thresholds for transfer packets */
    quota?: {
      /**
       * MaxPercentSend defines the threshold for outflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_send?: string;
      /**
       * MaxPercentSend defines the threshold for inflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_recv?: string;
      /**
       * DurationHours specifies the number of hours before the rate limit
       * is reset (e.g. 24 indicates that the rate limit is reset each day)
       * @format uint64
       */
      duration_hours?: string;
    };
    flow?: {
      /**
       * Inflow defines the total amount of inbound transfers for the given
       * rate limit in the current window
       */
      inflow?: string;
      /**
       * Outflow defines the total amount of outbound transfers for the given
       * rate limit in the current window
       */
      outflow?: string;
      /**
       * ChannelValue stores the total supply of the denom at the start of
       * the rate limit. This is used as the denominator when checking
       * the rate limit threshold
       * The ChannelValue is fixed for the duration of the rate limit window
       */
      channel_value?: string;
    };
  }[];
}

export interface RatelimitV1QueryAllWhitelistedAddressesResponse {
  address_pairs?: {
    sender?: string;
    receiver?: string;
  }[];
}

export interface RatelimitV1QueryRateLimitResponse {
  /**
   * RateLimit stores all the context about a given rate limit, including
   * the relevant denom and channel, rate limit thresholds, and current
   * progress towards the limits
   */
  rate_limit?: {
    /** Path holds the denom and channelID that define the rate limited route */
    path?: {
      denom?: string;
      channel_id?: string;
    };
    /** Quota defines the rate limit thresholds for transfer packets */
    quota?: {
      /**
       * MaxPercentSend defines the threshold for outflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_send?: string;
      /**
       * MaxPercentSend defines the threshold for inflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_recv?: string;
      /**
       * DurationHours specifies the number of hours before the rate limit
       * is reset (e.g. 24 indicates that the rate limit is reset each day)
       * @format uint64
       */
      duration_hours?: string;
    };
    flow?: {
      /**
       * Inflow defines the total amount of inbound transfers for the given
       * rate limit in the current window
       */
      inflow?: string;
      /**
       * Outflow defines the total amount of outbound transfers for the given
       * rate limit in the current window
       */
      outflow?: string;
      /**
       * ChannelValue stores the total supply of the denom at the start of
       * the rate limit. This is used as the denominator when checking
       * the rate limit threshold
       * The ChannelValue is fixed for the duration of the rate limit window
       */
      channel_value?: string;
    };
  };
}

export interface RatelimitV1QueryRateLimitsByChainIdResponse {
  rate_limits?: {
    /** Path holds the denom and channelID that define the rate limited route */
    path?: {
      denom?: string;
      channel_id?: string;
    };
    /** Quota defines the rate limit thresholds for transfer packets */
    quota?: {
      /**
       * MaxPercentSend defines the threshold for outflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_send?: string;
      /**
       * MaxPercentSend defines the threshold for inflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_recv?: string;
      /**
       * DurationHours specifies the number of hours before the rate limit
       * is reset (e.g. 24 indicates that the rate limit is reset each day)
       * @format uint64
       */
      duration_hours?: string;
    };
    flow?: {
      /**
       * Inflow defines the total amount of inbound transfers for the given
       * rate limit in the current window
       */
      inflow?: string;
      /**
       * Outflow defines the total amount of outbound transfers for the given
       * rate limit in the current window
       */
      outflow?: string;
      /**
       * ChannelValue stores the total supply of the denom at the start of
       * the rate limit. This is used as the denominator when checking
       * the rate limit threshold
       * The ChannelValue is fixed for the duration of the rate limit window
       */
      channel_value?: string;
    };
  }[];
}

export interface RatelimitV1QueryRateLimitsByChannelIdResponse {
  rate_limits?: {
    /** Path holds the denom and channelID that define the rate limited route */
    path?: {
      denom?: string;
      channel_id?: string;
    };
    /** Quota defines the rate limit thresholds for transfer packets */
    quota?: {
      /**
       * MaxPercentSend defines the threshold for outflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_send?: string;
      /**
       * MaxPercentSend defines the threshold for inflows
       * The threshold is defined as a percentage (e.g. 10 indicates 10%)
       */
      max_percent_recv?: string;
      /**
       * DurationHours specifies the number of hours before the rate limit
       * is reset (e.g. 24 indicates that the rate limit is reset each day)
       * @format uint64
       */
      duration_hours?: string;
    };
    flow?: {
      /**
       * Inflow defines the total amount of inbound transfers for the given
       * rate limit in the current window
       */
      inflow?: string;
      /**
       * Outflow defines the total amount of outbound transfers for the given
       * rate limit in the current window
       */
      outflow?: string;
      /**
       * ChannelValue stores the total supply of the denom at the start of
       * the rate limit. This is used as the denominator when checking
       * the rate limit threshold
       * The ChannelValue is fixed for the duration of the rate limit window
       */
      channel_value?: string;
    };
  }[];
}

/** Quota defines the rate limit thresholds for transfer packets */
export interface RatelimitV1Quota {
  /**
   * MaxPercentSend defines the threshold for outflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   */
  max_percent_send?: string;
  /**
   * MaxPercentSend defines the threshold for inflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   */
  max_percent_recv?: string;
  /**
   * DurationHours specifies the number of hours before the rate limit
   * is reset (e.g. 24 indicates that the rate limit is reset each day)
   * @format uint64
   */
  duration_hours?: string;
}

/**
 * RateLimit stores all the context about a given rate limit, including
 * the relevant denom and channel, rate limit thresholds, and current
 * progress towards the limits
 */
export interface RatelimitV1RateLimit {
  /** Path holds the denom and channelID that define the rate limited route */
  path?: {
    denom?: string;
    channel_id?: string;
  };
  /** Quota defines the rate limit thresholds for transfer packets */
  quota?: {
    /**
     * MaxPercentSend defines the threshold for outflows
     * The threshold is defined as a percentage (e.g. 10 indicates 10%)
     */
    max_percent_send?: string;
    /**
     * MaxPercentSend defines the threshold for inflows
     * The threshold is defined as a percentage (e.g. 10 indicates 10%)
     */
    max_percent_recv?: string;
    /**
     * DurationHours specifies the number of hours before the rate limit
     * is reset (e.g. 24 indicates that the rate limit is reset each day)
     * @format uint64
     */
    duration_hours?: string;
  };
  flow?: {
    /**
     * Inflow defines the total amount of inbound transfers for the given
     * rate limit in the current window
     */
    inflow?: string;
    /**
     * Outflow defines the total amount of outbound transfers for the given
     * rate limit in the current window
     */
    outflow?: string;
    /**
     * ChannelValue stores the total supply of the denom at the start of
     * the rate limit. This is used as the denominator when checking
     * the rate limit threshold
     * The ChannelValue is fixed for the duration of the rate limit window
     */
    channel_value?: string;
  };
}

/**
 * WhitelistedAddressPair represents a sender-receiver combo that is
 * not subject to rate limit restrictions
 */
export interface RatelimitV1WhitelistedAddressPair {
  sender?: string;
  receiver?: string;
}

/**
 * DenomTrace contains the base denomination for ICS20 fungible tokens and the
 * source tracing information path.
 */
export interface IbcApplicationsTransferV1DenomTrace {
  /**
   * path defines the chain of port/channel identifiers used for tracing the
   * source of the fungible token.
   */
  path?: string;
  /** base denomination of the relayed fungible token. */
  base_denom?: string;
}

/**
 * Params defines the set of IBC transfer parameters.
 * NOTE: To prevent a single token from being transferred, set the
 * TransfersEnabled parameter to true and then set the bank module's SendEnabled
 * parameter for the denomination to false.
 */
export interface IbcApplicationsTransferV1Params {
  /**
   * send_enabled enables or disables all cross-chain token transfers from this
   * chain.
   */
  send_enabled?: boolean;
  /**
   * receive_enabled enables or disables all cross-chain token transfers to this
   * chain.
   */
  receive_enabled?: boolean;
}

/**
 * QueryDenomHashResponse is the response type for the Query/DenomHash RPC
 * method.
 */
export interface IbcApplicationsTransferV1QueryDenomHashResponse {
  /** hash (in hex format) of the denomination trace information. */
  hash?: string;
}

/**
 * QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
 * method.
 */
export interface IbcApplicationsTransferV1QueryDenomTraceResponse {
  /**
   * DenomTrace contains the base denomination for ICS20 fungible tokens and the
   * source tracing information path.
   */
  denom_trace?: {
    /**
     * path defines the chain of port/channel identifiers used for tracing the
     * source of the fungible token.
     */
    path?: string;
    /** base denomination of the relayed fungible token. */
    base_denom?: string;
  };
}

/**
 * QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
 * method.
 */
export interface IbcApplicationsTransferV1QueryDenomTracesResponse {
  /** denom_traces returns all denominations trace information. */
  denom_traces?: {
    /**
     * path defines the chain of port/channel identifiers used for tracing the
     * source of the fungible token.
     */
    path?: string;
    /** base denomination of the relayed fungible token. */
    base_denom?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method. */
export interface IbcApplicationsTransferV1QueryEscrowAddressResponse {
  /** the escrow account address */
  escrow_address?: string;
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface IbcApplicationsTransferV1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /**
     * send_enabled enables or disables all cross-chain token transfers from this
     * chain.
     */
    send_enabled?: boolean;
    /**
     * receive_enabled enables or disables all cross-chain token transfers to this
     * chain.
     */
    receive_enabled?: boolean;
  };
}

/** QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method. */
export interface IbcApplicationsTransferV1QueryTotalEscrowForDenomResponse {
  /**
   * Coin defines a token with a denomination and an amount.
   *
   * NOTE: The amount field is an Int which implements the custom method
   * signatures required by gogoproto.
   */
  amount?: {
    denom?: string;
    amount?: string;
  };
}

/** Fee defines the ICS29 receive, acknowledgement and timeout fees */
export interface IbcApplicationsFeeV1Fee {
  /** the packet receive fee */
  recv_fee?: {
    denom?: string;
    amount?: string;
  }[];
  /** the packet acknowledgement fee */
  ack_fee?: {
    denom?: string;
    amount?: string;
  }[];
  /** the packet timeout fee */
  timeout_fee?: {
    denom?: string;
    amount?: string;
  }[];
}

/** FeeEnabledChannel contains the PortID & ChannelID for a fee enabled channel */
export interface IbcApplicationsFeeV1FeeEnabledChannel {
  /** unique port identifier */
  port_id?: string;
  /** unique channel identifier */
  channel_id?: string;
}

/** IdentifiedPacketFees contains a list of type PacketFee and associated PacketId */
export interface IbcApplicationsFeeV1IdentifiedPacketFees {
  /** unique packet identifier comprised of the channel ID, port ID and sequence */
  packet_id?: {
    /** channel port identifier */
    port_id?: string;
    /** channel unique identifier */
    channel_id?: string;
    /**
     * packet sequence
     * @format uint64
     */
    sequence?: string;
  };
  /** list of packet fees */
  packet_fees?: {
    /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
    fee?: {
      /** the packet receive fee */
      recv_fee?: {
        denom?: string;
        amount?: string;
      }[];
      /** the packet acknowledgement fee */
      ack_fee?: {
        denom?: string;
        amount?: string;
      }[];
      /** the packet timeout fee */
      timeout_fee?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** the refund address for unspent fees */
    refund_address?: string;
    /** optional list of relayers permitted to receive fees */
    relayers?: string[];
  }[];
}

/** PacketFee contains ICS29 relayer fees, refund address and optional list of permitted relayers */
export interface IbcApplicationsFeeV1PacketFee {
  /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
  fee?: {
    /** the packet receive fee */
    recv_fee?: {
      denom?: string;
      amount?: string;
    }[];
    /** the packet acknowledgement fee */
    ack_fee?: {
      denom?: string;
      amount?: string;
    }[];
    /** the packet timeout fee */
    timeout_fee?: {
      denom?: string;
      amount?: string;
    }[];
  };
  /** the refund address for unspent fees */
  refund_address?: string;
  /** optional list of relayers permitted to receive fees */
  relayers?: string[];
}

/** QueryCounterpartyPayeeResponse defines the response type for the CounterpartyPayee rpc */
export interface IbcApplicationsFeeV1QueryCounterpartyPayeeResponse {
  /** the counterparty payee address used to compensate forward relaying */
  counterparty_payee?: string;
}

/** QueryFeeEnabledChannelResponse defines the response type for the FeeEnabledChannel rpc */
export interface IbcApplicationsFeeV1QueryFeeEnabledChannelResponse {
  /** boolean flag representing the fee enabled channel status */
  fee_enabled?: boolean;
}

/** QueryFeeEnabledChannelsResponse defines the response type for the FeeEnabledChannels rpc */
export interface IbcApplicationsFeeV1QueryFeeEnabledChannelsResponse {
  /** list of fee enabled channels */
  fee_enabled_channels?: {
    /** unique port identifier */
    port_id?: string;
    /** unique channel identifier */
    channel_id?: string;
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPacket rpc */
export interface IbcApplicationsFeeV1QueryIncentivizedPacketResponse {
  /** IdentifiedPacketFees contains a list of type PacketFee and associated PacketId */
  incentivized_packet?: {
    /** unique packet identifier comprised of the channel ID, port ID and sequence */
    packet_id?: {
      /** channel port identifier */
      port_id?: string;
      /** channel unique identifier */
      channel_id?: string;
      /**
       * packet sequence
       * @format uint64
       */
      sequence?: string;
    };
    /** list of packet fees */
    packet_fees?: {
      /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
      fee?: {
        /** the packet receive fee */
        recv_fee?: {
          denom?: string;
          amount?: string;
        }[];
        /** the packet acknowledgement fee */
        ack_fee?: {
          denom?: string;
          amount?: string;
        }[];
        /** the packet timeout fee */
        timeout_fee?: {
          denom?: string;
          amount?: string;
        }[];
      };
      /** the refund address for unspent fees */
      refund_address?: string;
      /** optional list of relayers permitted to receive fees */
      relayers?: string[];
    }[];
  };
}

/** QueryIncentivizedPacketsResponse defines the response type for the incentivized packets RPC */
export interface IbcApplicationsFeeV1QueryIncentivizedPacketsForChannelResponse {
  /** Map of all incentivized_packets */
  incentivized_packets?: {
    /** unique packet identifier comprised of the channel ID, port ID and sequence */
    packet_id?: {
      /** channel port identifier */
      port_id?: string;
      /** channel unique identifier */
      channel_id?: string;
      /**
       * packet sequence
       * @format uint64
       */
      sequence?: string;
    };
    /** list of packet fees */
    packet_fees?: {
      /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
      fee?: {
        /** the packet receive fee */
        recv_fee?: {
          denom?: string;
          amount?: string;
        }[];
        /** the packet acknowledgement fee */
        ack_fee?: {
          denom?: string;
          amount?: string;
        }[];
        /** the packet timeout fee */
        timeout_fee?: {
          denom?: string;
          amount?: string;
        }[];
      };
      /** the refund address for unspent fees */
      refund_address?: string;
      /** optional list of relayers permitted to receive fees */
      relayers?: string[];
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPackets rpc */
export interface IbcApplicationsFeeV1QueryIncentivizedPacketsResponse {
  /** list of identified fees for incentivized packets */
  incentivized_packets?: {
    /** unique packet identifier comprised of the channel ID, port ID and sequence */
    packet_id?: {
      /** channel port identifier */
      port_id?: string;
      /** channel unique identifier */
      channel_id?: string;
      /**
       * packet sequence
       * @format uint64
       */
      sequence?: string;
    };
    /** list of packet fees */
    packet_fees?: {
      /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
      fee?: {
        /** the packet receive fee */
        recv_fee?: {
          denom?: string;
          amount?: string;
        }[];
        /** the packet acknowledgement fee */
        ack_fee?: {
          denom?: string;
          amount?: string;
        }[];
        /** the packet timeout fee */
        timeout_fee?: {
          denom?: string;
          amount?: string;
        }[];
      };
      /** the refund address for unspent fees */
      refund_address?: string;
      /** optional list of relayers permitted to receive fees */
      relayers?: string[];
    }[];
  }[];
  /** pagination defines the pagination in the response. */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/** QueryPayeeResponse defines the response type for the Payee rpc */
export interface IbcApplicationsFeeV1QueryPayeeResponse {
  /** the payee address to which packet fees are paid out */
  payee_address?: string;
}

/** QueryTotalAckFeesResponse defines the response type for the TotalAckFees rpc */
export interface IbcApplicationsFeeV1QueryTotalAckFeesResponse {
  /** the total packet acknowledgement fees */
  ack_fees?: {
    denom?: string;
    amount?: string;
  }[];
}

/** QueryTotalRecvFeesResponse defines the response type for the TotalRecvFees rpc */
export interface IbcApplicationsFeeV1QueryTotalRecvFeesResponse {
  /** the total packet receive fees */
  recv_fees?: {
    denom?: string;
    amount?: string;
  }[];
}

/** QueryTotalTimeoutFeesResponse defines the response type for the TotalTimeoutFees rpc */
export interface IbcApplicationsFeeV1QueryTotalTimeoutFeesResponse {
  /** the total packet timeout fees */
  timeout_fees?: {
    denom?: string;
    amount?: string;
  }[];
}

/**
 * PacketId is an identifer for a unique Packet
 * Source chains refer to packets by source port/channel
 * Destination chains refer to packets by destination port/channel
 */
export interface IbcCoreChannelV1PacketId {
  /** channel port identifier */
  port_id?: string;
  /** channel unique identifier */
  channel_id?: string;
  /**
   * packet sequence
   * @format uint64
   */
  sequence?: string;
}

/**
 * Params defines the set of on-chain interchain accounts parameters.
 * The following parameters may be used to disable the controller submodule.
 */
export interface IbcApplicationsInterchainAccountsControllerV1Params {
  /** controller_enabled enables or disables the controller submodule. */
  controller_enabled?: boolean;
}

/** QueryInterchainAccountResponse the response type for the Query/InterchainAccount RPC method. */
export interface IbcApplicationsInterchainAccountsControllerV1QueryInterchainAccountResponse {
  address?: string;
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface IbcApplicationsInterchainAccountsControllerV1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /** controller_enabled enables or disables the controller submodule. */
    controller_enabled?: boolean;
  };
}

/**
 * Params defines the set of on-chain interchain accounts parameters.
 * The following parameters may be used to disable the host submodule.
 */
export interface IbcApplicationsInterchainAccountsHostV1Params {
  /** host_enabled enables or disables the host submodule. */
  host_enabled?: boolean;
  /** allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain. */
  allow_messages?: string[];
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface IbcApplicationsInterchainAccountsHostV1QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /** host_enabled enables or disables the host submodule. */
    host_enabled?: boolean;
    /** allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain. */
    allow_messages?: string[];
  };
}

/**
 * Channel defines pipeline for exactly-once packet delivery between specific
 * modules on separate blockchains, which has at least one end capable of
 * sending packets and one end capable of receiving packets.
 */
export interface IbcCoreChannelV1Channel {
  /**
   * current state of the channel end
   * State defines if a channel is in one of the following states:
   * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
   *
   *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
   *  - STATE_INIT: A channel has just started the opening handshake.
   *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
   *  - STATE_OPEN: A channel has completed the handshake. Open channels are
   * ready to send and receive packets.
   *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
   * packets.
   *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
   *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
   * @default "STATE_UNINITIALIZED_UNSPECIFIED"
   */
  state?:
    | "STATE_UNINITIALIZED_UNSPECIFIED"
    | "STATE_INIT"
    | "STATE_TRYOPEN"
    | "STATE_OPEN"
    | "STATE_CLOSED"
    | "STATE_FLUSHING"
    | "STATE_FLUSHCOMPLETE";
  /**
   * whether the channel is ordered or unordered
   * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
   *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
   * which they were sent.
   *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
   * @default "ORDER_NONE_UNSPECIFIED"
   */
  ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
  /** counterparty channel end */
  counterparty?: {
    /** port on the counterparty chain which owns the other end of the channel. */
    port_id?: string;
    /** channel end on the counterparty chain */
    channel_id?: string;
  };
  /**
   * list of connection identifiers, in order, along which packets sent on
   * this channel will travel
   */
  connection_hops?: string[];
  /** opaque channel version, which is agreed upon during the handshake */
  version?: string;
  /**
   * upgrade sequence indicates the latest upgrade attempt performed by this channel
   * the value of 0 indicates the channel has never been upgraded
   * @format uint64
   */
  upgrade_sequence?: string;
}

/** Counterparty defines a channel end counterparty */
export interface IbcCoreChannelV1Counterparty {
  /** port on the counterparty chain which owns the other end of the channel. */
  port_id?: string;
  /** channel end on the counterparty chain */
  channel_id?: string;
}

/**
 * ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the
 * upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the
 * next sequence.
 */
export interface IbcCoreChannelV1ErrorReceipt {
  /**
   * the channel upgrade sequence
   * @format uint64
   */
  sequence?: string;
  /** the error message detailing the cause of failure */
  message?: string;
}

/**
 * IdentifiedChannel defines a channel with additional port and channel
 * identifier fields.
 */
export interface IbcCoreChannelV1IdentifiedChannel {
  /**
   * current state of the channel end
   * State defines if a channel is in one of the following states:
   * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
   *
   *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
   *  - STATE_INIT: A channel has just started the opening handshake.
   *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
   *  - STATE_OPEN: A channel has completed the handshake. Open channels are
   * ready to send and receive packets.
   *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
   * packets.
   *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
   *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
   * @default "STATE_UNINITIALIZED_UNSPECIFIED"
   */
  state?:
    | "STATE_UNINITIALIZED_UNSPECIFIED"
    | "STATE_INIT"
    | "STATE_TRYOPEN"
    | "STATE_OPEN"
    | "STATE_CLOSED"
    | "STATE_FLUSHING"
    | "STATE_FLUSHCOMPLETE";
  /**
   * whether the channel is ordered or unordered
   * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
   *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
   * which they were sent.
   *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
   * @default "ORDER_NONE_UNSPECIFIED"
   */
  ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
  /** counterparty channel end */
  counterparty?: {
    /** port on the counterparty chain which owns the other end of the channel. */
    port_id?: string;
    /** channel end on the counterparty chain */
    channel_id?: string;
  };
  /**
   * list of connection identifiers, in order, along which packets sent on
   * this channel will travel
   */
  connection_hops?: string[];
  /** opaque channel version, which is agreed upon during the handshake */
  version?: string;
  /** port identifier */
  port_id?: string;
  /** channel identifier */
  channel_id?: string;
  /**
   * upgrade sequence indicates the latest upgrade attempt performed by this channel
   * the value of 0 indicates the channel has never been upgraded
   * @format uint64
   */
  upgrade_sequence?: string;
}

/**
 * PacketState defines the generic type necessary to retrieve and store
 * packet commitments, acknowledgements, and receipts.
 * Caller is responsible for knowing the context necessary to interpret this
 * state as a commitment, acknowledgement, or a receipt.
 */
export interface IbcCoreChannelV1PacketState {
  /** channel port identifier. */
  port_id?: string;
  /** channel unique identifier. */
  channel_id?: string;
  /**
   * packet sequence.
   * @format uint64
   */
  sequence?: string;
  /**
   * embedded data that represents packet state.
   * @format byte
   */
  data?: string;
}

/** Params defines the set of IBC channel parameters. */
export interface IbcCoreChannelV1Params {
  /**
   * Timeout defines an execution deadline structure for 04-channel handlers.
   * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
   * A valid Timeout contains either one or both of a timestamp and block height (sequence).
   */
  upgrade_timeout?: {
    /**
     * block height after which the packet or upgrade times out
     * Normally the RevisionHeight is incremented at each height while keeping
     * RevisionNumber the same. However some consensus algorithms may choose to
     * reset the height in certain conditions e.g. hard forks, state-machine
     * breaking changes In these cases, the RevisionNumber is incremented so that
     * height continues to be monitonically increasing even as the RevisionHeight
     * gets reset
     */
    height?: {
      /**
       * the revision that the client is currently on
       * @format uint64
       */
      revision_number?: string;
      /**
       * the height within the given revision
       * @format uint64
       */
      revision_height?: string;
    };
    /**
     * block timestamp (in nanoseconds) after which the packet or upgrade times out
     * @format uint64
     */
    timestamp?: string;
  };
}

/**
 * QueryChannelClientStateResponse is the Response type for the
 * Query/QueryChannelClientState RPC method
 */
export interface IbcCoreChannelV1QueryChannelClientStateResponse {
  /**
   * client state associated with the channel
   * IdentifiedClientState defines a client state with an additional client
   * identifier field.
   */
  identified_client_state?: {
    /** client identifier */
    client_id?: string;
    /**
     * client state
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    client_state?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryChannelClientStateResponse is the Response type for the
 * Query/QueryChannelClientState RPC method
 */
export interface IbcCoreChannelV1QueryChannelConsensusStateResponse {
  /**
   * consensus state associated with the channel
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  consensus_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /** client ID associated with the consensus state */
  client_id?: string;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/** QueryChannelParamsResponse is the response type for the Query/ChannelParams RPC method. */
export interface IbcCoreChannelV1QueryChannelParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /**
     * Timeout defines an execution deadline structure for 04-channel handlers.
     * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
     * A valid Timeout contains either one or both of a timestamp and block height (sequence).
     */
    upgrade_timeout?: {
      /**
       * block height after which the packet or upgrade times out
       * Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * @format uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * @format uint64
         */
        revision_height?: string;
      };
      /**
       * block timestamp (in nanoseconds) after which the packet or upgrade times out
       * @format uint64
       */
      timestamp?: string;
    };
  };
}

/**
 * QueryChannelResponse is the response type for the Query/Channel RPC method.
 * Besides the Channel end, it includes a proof and the height from which the
 * proof was retrieved.
 */
export interface IbcCoreChannelV1QueryChannelResponse {
  /**
   * channel associated with the request identifiers
   * Channel defines pipeline for exactly-once packet delivery between specific
   * modules on separate blockchains, which has at least one end capable of
   * sending packets and one end capable of receiving packets.
   */
  channel?: {
    /**
     * current state of the channel end
     * State defines if a channel is in one of the following states:
     * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
     *
     *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *  - STATE_INIT: A channel has just started the opening handshake.
     *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
     *  - STATE_OPEN: A channel has completed the handshake. Open channels are
     * ready to send and receive packets.
     *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
     * packets.
     *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
     *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
     * @default "STATE_UNINITIALIZED_UNSPECIFIED"
     */
    state?:
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN"
      | "STATE_CLOSED"
      | "STATE_FLUSHING"
      | "STATE_FLUSHCOMPLETE";
    /**
     * whether the channel is ordered or unordered
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
     *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @default "ORDER_NONE_UNSPECIFIED"
     */
    ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
    /** counterparty channel end */
    counterparty?: {
      /** port on the counterparty chain which owns the other end of the channel. */
      port_id?: string;
      /** channel end on the counterparty chain */
      channel_id?: string;
    };
    /**
     * list of connection identifiers, in order, along which packets sent on
     * this channel will travel
     */
    connection_hops?: string[];
    /** opaque channel version, which is agreed upon during the handshake */
    version?: string;
    /**
     * upgrade sequence indicates the latest upgrade attempt performed by this channel
     * the value of 0 indicates the channel has never been upgraded
     * @format uint64
     */
    upgrade_sequence?: string;
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/** QueryChannelsResponse is the response type for the Query/Channels RPC method. */
export interface IbcCoreChannelV1QueryChannelsResponse {
  /** list of stored channels of the chain. */
  channels?: {
    /**
     * current state of the channel end
     * State defines if a channel is in one of the following states:
     * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
     *
     *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *  - STATE_INIT: A channel has just started the opening handshake.
     *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
     *  - STATE_OPEN: A channel has completed the handshake. Open channels are
     * ready to send and receive packets.
     *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
     * packets.
     *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
     *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
     * @default "STATE_UNINITIALIZED_UNSPECIFIED"
     */
    state?:
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN"
      | "STATE_CLOSED"
      | "STATE_FLUSHING"
      | "STATE_FLUSHCOMPLETE";
    /**
     * whether the channel is ordered or unordered
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
     *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @default "ORDER_NONE_UNSPECIFIED"
     */
    ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
    /** counterparty channel end */
    counterparty?: {
      /** port on the counterparty chain which owns the other end of the channel. */
      port_id?: string;
      /** channel end on the counterparty chain */
      channel_id?: string;
    };
    /**
     * list of connection identifiers, in order, along which packets sent on
     * this channel will travel
     */
    connection_hops?: string[];
    /** opaque channel version, which is agreed upon during the handshake */
    version?: string;
    /** port identifier */
    port_id?: string;
    /** channel identifier */
    channel_id?: string;
    /**
     * upgrade sequence indicates the latest upgrade attempt performed by this channel
     * the value of 0 indicates the channel has never been upgraded
     * @format uint64
     */
    upgrade_sequence?: string;
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryConnectionChannelsResponse is the Response type for the
 * Query/QueryConnectionChannels RPC method
 */
export interface IbcCoreChannelV1QueryConnectionChannelsResponse {
  /** list of channels associated with a connection. */
  channels?: {
    /**
     * current state of the channel end
     * State defines if a channel is in one of the following states:
     * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
     *
     *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *  - STATE_INIT: A channel has just started the opening handshake.
     *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
     *  - STATE_OPEN: A channel has completed the handshake. Open channels are
     * ready to send and receive packets.
     *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
     * packets.
     *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
     *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
     * @default "STATE_UNINITIALIZED_UNSPECIFIED"
     */
    state?:
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN"
      | "STATE_CLOSED"
      | "STATE_FLUSHING"
      | "STATE_FLUSHCOMPLETE";
    /**
     * whether the channel is ordered or unordered
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
     *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @default "ORDER_NONE_UNSPECIFIED"
     */
    ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
    /** counterparty channel end */
    counterparty?: {
      /** port on the counterparty chain which owns the other end of the channel. */
      port_id?: string;
      /** channel end on the counterparty chain */
      channel_id?: string;
    };
    /**
     * list of connection identifiers, in order, along which packets sent on
     * this channel will travel
     */
    connection_hops?: string[];
    /** opaque channel version, which is agreed upon during the handshake */
    version?: string;
    /** port identifier */
    port_id?: string;
    /** channel identifier */
    channel_id?: string;
    /**
     * upgrade sequence indicates the latest upgrade attempt performed by this channel
     * the value of 0 indicates the channel has never been upgraded
     * @format uint64
     */
    upgrade_sequence?: string;
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QuerySequenceResponse is the response type for the
 * Query/QueryNextSequenceReceiveResponse RPC method
 */
export interface IbcCoreChannelV1QueryNextSequenceReceiveResponse {
  /**
   * next sequence receive number
   * @format uint64
   */
  next_sequence_receive?: string;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryNextSequenceSendResponse is the request type for the
 * Query/QueryNextSequenceSend RPC method
 */
export interface IbcCoreChannelV1QueryNextSequenceSendResponse {
  /**
   * next sequence send number
   * @format uint64
   */
  next_sequence_send?: string;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryPacketAcknowledgementResponse defines the client query response for a
 * packet which also includes a proof and the height from which the
 * proof was retrieved
 */
export interface IbcCoreChannelV1QueryPacketAcknowledgementResponse {
  /**
   * packet associated with the request fields
   * @format byte
   */
  acknowledgement?: string;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryPacketAcknowledgemetsResponse is the request type for the
 * Query/QueryPacketAcknowledgements RPC method
 */
export interface IbcCoreChannelV1QueryPacketAcknowledgementsResponse {
  acknowledgements?: {
    /** channel port identifier. */
    port_id?: string;
    /** channel unique identifier. */
    channel_id?: string;
    /**
     * packet sequence.
     * @format uint64
     */
    sequence?: string;
    /**
     * embedded data that represents packet state.
     * @format byte
     */
    data?: string;
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryPacketCommitmentResponse defines the client query response for a packet
 * which also includes a proof and the height from which the proof was
 * retrieved
 */
export interface IbcCoreChannelV1QueryPacketCommitmentResponse {
  /**
   * packet associated with the request fields
   * @format byte
   */
  commitment?: string;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryPacketCommitmentsResponse is the request type for the
 * Query/QueryPacketCommitments RPC method
 */
export interface IbcCoreChannelV1QueryPacketCommitmentsResponse {
  commitments?: {
    /** channel port identifier. */
    port_id?: string;
    /** channel unique identifier. */
    channel_id?: string;
    /**
     * packet sequence.
     * @format uint64
     */
    sequence?: string;
    /**
     * embedded data that represents packet state.
     * @format byte
     */
    data?: string;
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryPacketReceiptResponse defines the client query response for a packet
 * receipt which also includes a proof, and the height from which the proof was
 * retrieved
 */
export interface IbcCoreChannelV1QueryPacketReceiptResponse {
  /** success flag for if receipt exists */
  received?: boolean;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryUnreceivedAcksResponse is the response type for the
 * Query/UnreceivedAcks RPC method
 */
export interface IbcCoreChannelV1QueryUnreceivedAcksResponse {
  /** list of unreceived acknowledgement sequences */
  sequences?: string[];
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryUnreceivedPacketsResponse is the response type for the
 * Query/UnreceivedPacketCommitments RPC method
 */
export interface IbcCoreChannelV1QueryUnreceivedPacketsResponse {
  /** list of unreceived packet sequences */
  sequences?: string[];
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/** QueryUpgradeErrorResponse is the response type for the Query/QueryUpgradeError RPC method */
export interface IbcCoreChannelV1QueryUpgradeErrorResponse {
  /**
   * ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the
   * upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the
   * next sequence.
   */
  error_receipt?: {
    /**
     * the channel upgrade sequence
     * @format uint64
     */
    sequence?: string;
    /** the error message detailing the cause of failure */
    message?: string;
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/** QueryUpgradeResponse is the response type for the QueryUpgradeResponse RPC method */
export interface IbcCoreChannelV1QueryUpgradeResponse {
  /**
   * Upgrade is a verifiable type which contains the relevant information
   * for an attempted upgrade. It provides the proposed changes to the channel
   * end, the timeout for this upgrade attempt and the next packet sequence
   * which allows the counterparty to efficiently know the highest sequence it has received.
   * The next sequence send is used for pruning and upgrading from unordered to ordered channels.
   */
  upgrade?: {
    /**
     * UpgradeFields are the fields in a channel end which may be changed
     * during a channel upgrade.
     */
    fields?: {
      /**
       * Order defines if a channel is ORDERED or UNORDERED
       * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
       *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
       * which they were sent.
       *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
       * @default "ORDER_NONE_UNSPECIFIED"
       */
      ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
      connection_hops?: string[];
      version?: string;
    };
    /**
     * Timeout defines an execution deadline structure for 04-channel handlers.
     * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
     * A valid Timeout contains either one or both of a timestamp and block height (sequence).
     */
    timeout?: {
      /**
       * block height after which the packet or upgrade times out
       * Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * @format uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * @format uint64
         */
        revision_height?: string;
      };
      /**
       * block timestamp (in nanoseconds) after which the packet or upgrade times out
       * @format uint64
       */
      timestamp?: string;
    };
    /** @format uint64 */
    next_sequence_send?: string;
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * Timeout defines an execution deadline structure for 04-channel handlers.
 * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
 * A valid Timeout contains either one or both of a timestamp and block height (sequence).
 */
export interface IbcCoreChannelV1Timeout {
  /**
   * block height after which the packet or upgrade times out
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
  /**
   * block timestamp (in nanoseconds) after which the packet or upgrade times out
   * @format uint64
   */
  timestamp?: string;
}

/**
 * Upgrade is a verifiable type which contains the relevant information
 * for an attempted upgrade. It provides the proposed changes to the channel
 * end, the timeout for this upgrade attempt and the next packet sequence
 * which allows the counterparty to efficiently know the highest sequence it has received.
 * The next sequence send is used for pruning and upgrading from unordered to ordered channels.
 */
export interface IbcCoreChannelV1Upgrade {
  /**
   * UpgradeFields are the fields in a channel end which may be changed
   * during a channel upgrade.
   */
  fields?: {
    /**
     * Order defines if a channel is ORDERED or UNORDERED
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
     *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @default "ORDER_NONE_UNSPECIFIED"
     */
    ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
    connection_hops?: string[];
    version?: string;
  };
  /**
   * Timeout defines an execution deadline structure for 04-channel handlers.
   * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
   * A valid Timeout contains either one or both of a timestamp and block height (sequence).
   */
  timeout?: {
    /**
     * block height after which the packet or upgrade times out
     * Normally the RevisionHeight is incremented at each height while keeping
     * RevisionNumber the same. However some consensus algorithms may choose to
     * reset the height in certain conditions e.g. hard forks, state-machine
     * breaking changes In these cases, the RevisionNumber is incremented so that
     * height continues to be monitonically increasing even as the RevisionHeight
     * gets reset
     */
    height?: {
      /**
       * the revision that the client is currently on
       * @format uint64
       */
      revision_number?: string;
      /**
       * the height within the given revision
       * @format uint64
       */
      revision_height?: string;
    };
    /**
     * block timestamp (in nanoseconds) after which the packet or upgrade times out
     * @format uint64
     */
    timestamp?: string;
  };
  /** @format uint64 */
  next_sequence_send?: string;
}

/**
 * UpgradeFields are the fields in a channel end which may be changed
 * during a channel upgrade.
 */
export interface IbcCoreChannelV1UpgradeFields {
  /**
   * Order defines if a channel is ORDERED or UNORDERED
   * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
   *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
   * which they were sent.
   *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
   * @default "ORDER_NONE_UNSPECIFIED"
   */
  ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
  connection_hops?: string[];
  version?: string;
}

/**
 * Height is a monotonically increasing data type
 * that can be compared against another Height for the purposes of updating and
 * freezing clients
 * Normally the RevisionHeight is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionHeight
 * gets reset
 */
export interface IbcCoreClientV1Height {
  /**
   * the revision that the client is currently on
   * @format uint64
   */
  revision_number?: string;
  /**
   * the height within the given revision
   * @format uint64
   */
  revision_height?: string;
}

/**
 * IdentifiedClientState defines a client state with an additional client
 * identifier field.
 */
export interface IbcCoreClientV1IdentifiedClientState {
  /** client identifier */
  client_id?: string;
  /**
   * client state
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  client_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/**
 * MerklePrefix is merkle path prefixed to the key.
 * The constructed key from the Path and the key will be append(Path.KeyPath,
 * append(Path.KeyPrefix, key...))
 */
export interface IbcCoreCommitmentV1MerklePrefix {
  /** @format byte */
  key_prefix?: string;
}

/**
 * ConnectionEnd defines a stateful object on a chain connected to another
 * separate one.
 * NOTE: there must only be 2 defined ConnectionEnds to establish
 * a connection between two chains.
 */
export interface IbcCoreConnectionV1ConnectionEnd {
  /** client associated with this connection. */
  client_id?: string;
  /**
   * IBC version which can be utilised to determine encodings or protocols for
   * channels or packets utilising this connection.
   */
  versions?: {
    /** unique version identifier */
    identifier?: string;
    /** list of features compatible with the specified identifier */
    features?: string[];
  }[];
  /**
   * current state of the connection end.
   * @default "STATE_UNINITIALIZED_UNSPECIFIED"
   */
  state?:
    | "STATE_UNINITIALIZED_UNSPECIFIED"
    | "STATE_INIT"
    | "STATE_TRYOPEN"
    | "STATE_OPEN";
  /** counterparty chain associated with this connection. */
  counterparty?: {
    /**
     * identifies the client on the counterparty chain associated with a given
     * connection.
     */
    client_id?: string;
    /**
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     */
    connection_id?: string;
    /**
     * MerklePrefix is merkle path prefixed to the key.
     * The constructed key from the Path and the key will be append(Path.KeyPath,
     * append(Path.KeyPrefix, key...))
     * commitment merkle prefix of the counterparty chain.
     */
    prefix?: {
      /** @format byte */
      key_prefix?: string;
    };
  };
  /**
   * delay period that must pass before a consensus state can be used for
   * packet-verification NOTE: delay period logic is only implemented by some
   * clients.
   * @format uint64
   */
  delay_period?: string;
}

/** Counterparty defines the counterparty chain associated with a connection end. */
export interface IbcCoreConnectionV1Counterparty {
  /**
   * identifies the client on the counterparty chain associated with a given
   * connection.
   */
  client_id?: string;
  /**
   * identifies the connection end on the counterparty chain associated with a
   * given connection.
   */
  connection_id?: string;
  /**
   * MerklePrefix is merkle path prefixed to the key.
   * The constructed key from the Path and the key will be append(Path.KeyPath,
   * append(Path.KeyPrefix, key...))
   * commitment merkle prefix of the counterparty chain.
   */
  prefix?: {
    /** @format byte */
    key_prefix?: string;
  };
}

/**
 * IdentifiedConnection defines a connection with additional connection
 * identifier field.
 */
export interface IbcCoreConnectionV1IdentifiedConnection {
  /** connection identifier. */
  id?: string;
  /** client associated with this connection. */
  client_id?: string;
  /**
   * IBC version which can be utilised to determine encodings or protocols for
   * channels or packets utilising this connection
   */
  versions?: {
    /** unique version identifier */
    identifier?: string;
    /** list of features compatible with the specified identifier */
    features?: string[];
  }[];
  /**
   * current state of the connection end.
   * @default "STATE_UNINITIALIZED_UNSPECIFIED"
   */
  state?:
    | "STATE_UNINITIALIZED_UNSPECIFIED"
    | "STATE_INIT"
    | "STATE_TRYOPEN"
    | "STATE_OPEN";
  /** counterparty chain associated with this connection. */
  counterparty?: {
    /**
     * identifies the client on the counterparty chain associated with a given
     * connection.
     */
    client_id?: string;
    /**
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     */
    connection_id?: string;
    /**
     * MerklePrefix is merkle path prefixed to the key.
     * The constructed key from the Path and the key will be append(Path.KeyPath,
     * append(Path.KeyPrefix, key...))
     * commitment merkle prefix of the counterparty chain.
     */
    prefix?: {
      /** @format byte */
      key_prefix?: string;
    };
  };
  /**
   * delay period associated with this connection.
   * @format uint64
   */
  delay_period?: string;
}

/** Params defines the set of Connection parameters. */
export interface IbcCoreConnectionV1Params {
  /**
   * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
   * largest amount of time that the chain might reasonably take to produce the next block under normal operating
   * conditions. A safe choice is 3-5x the expected time per block.
   * @format uint64
   */
  max_expected_time_per_block?: string;
}

/**
 * QueryClientConnectionsResponse is the response type for the
 * Query/ClientConnections RPC method
 */
export interface IbcCoreConnectionV1QueryClientConnectionsResponse {
  /** slice of all the connection paths associated with a client. */
  connection_paths?: string[];
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was generated
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryConnectionClientStateResponse is the response type for the
 * Query/ConnectionClientState RPC method
 */
export interface IbcCoreConnectionV1QueryConnectionClientStateResponse {
  /**
   * client state associated with the channel
   * IdentifiedClientState defines a client state with an additional client
   * identifier field.
   */
  identified_client_state?: {
    /** client identifier */
    client_id?: string;
    /**
     * client state
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    client_state?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryConnectionConsensusStateResponse is the response type for the
 * Query/ConnectionConsensusState RPC method
 */
export interface IbcCoreConnectionV1QueryConnectionConsensusStateResponse {
  /**
   * consensus state associated with the channel
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  consensus_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /** client ID associated with the consensus state */
  client_id?: string;
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/** QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method. */
export interface IbcCoreConnectionV1QueryConnectionParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /**
     * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
     * largest amount of time that the chain might reasonably take to produce the next block under normal operating
     * conditions. A safe choice is 3-5x the expected time per block.
     * @format uint64
     */
    max_expected_time_per_block?: string;
  };
}

/**
 * QueryConnectionResponse is the response type for the Query/Connection RPC
 * method. Besides the connection end, it includes a proof and the height from
 * which the proof was retrieved.
 */
export interface IbcCoreConnectionV1QueryConnectionResponse {
  /**
   * connection associated with the request identifier
   * ConnectionEnd defines a stateful object on a chain connected to another
   * separate one.
   * NOTE: there must only be 2 defined ConnectionEnds to establish
   * a connection between two chains.
   */
  connection?: {
    /** client associated with this connection. */
    client_id?: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     */
    versions?: {
      /** unique version identifier */
      identifier?: string;
      /** list of features compatible with the specified identifier */
      features?: string[];
    }[];
    /**
     * current state of the connection end.
     * @default "STATE_UNINITIALIZED_UNSPECIFIED"
     */
    state?:
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN";
    /** counterparty chain associated with this connection. */
    counterparty?: {
      /**
       * identifies the client on the counterparty chain associated with a given
       * connection.
       */
      client_id?: string;
      /**
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       */
      connection_id?: string;
      /**
       * MerklePrefix is merkle path prefixed to the key.
       * The constructed key from the Path and the key will be append(Path.KeyPath,
       * append(Path.KeyPrefix, key...))
       * commitment merkle prefix of the counterparty chain.
       */
      prefix?: {
        /** @format byte */
        key_prefix?: string;
      };
    };
    /**
     * delay period that must pass before a consensus state can be used for
     * packet-verification NOTE: delay period logic is only implemented by some
     * clients.
     * @format uint64
     */
    delay_period?: string;
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryConnectionsResponse is the response type for the Query/Connections RPC
 * method.
 */
export interface IbcCoreConnectionV1QueryConnectionsResponse {
  /** list of stored connections of the chain. */
  connections?: {
    /** connection identifier. */
    id?: string;
    /** client associated with this connection. */
    client_id?: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection
     */
    versions?: {
      /** unique version identifier */
      identifier?: string;
      /** list of features compatible with the specified identifier */
      features?: string[];
    }[];
    /**
     * current state of the connection end.
     * @default "STATE_UNINITIALIZED_UNSPECIFIED"
     */
    state?:
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN";
    /** counterparty chain associated with this connection. */
    counterparty?: {
      /**
       * identifies the client on the counterparty chain associated with a given
       * connection.
       */
      client_id?: string;
      /**
       * identifies the connection end on the counterparty chain associated with a
       * given connection.
       */
      connection_id?: string;
      /**
       * MerklePrefix is merkle path prefixed to the key.
       * The constructed key from the Path and the key will be append(Path.KeyPath,
       * append(Path.KeyPrefix, key...))
       * commitment merkle prefix of the counterparty chain.
       */
      prefix?: {
        /** @format byte */
        key_prefix?: string;
      };
    };
    /**
     * delay period associated with this connection.
     * @format uint64
     */
    delay_period?: string;
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
  /**
   * query block height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * Version defines the versioning scheme used to negotiate the IBC verison in
 * the connection handshake.
 */
export interface IbcCoreConnectionV1Version {
  /** unique version identifier */
  identifier?: string;
  /** list of features compatible with the specified identifier */
  features?: string[];
}

/**
 * ConsensusStateWithHeight defines a consensus state with an additional height
 * field.
 */
export interface IbcCoreClientV1ConsensusStateWithHeight {
  /**
   * consensus state height
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
  /**
   * consensus state
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  consensus_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/** Params defines the set of IBC light client parameters. */
export interface IbcCoreClientV1Params {
  /**
   * allowed_clients defines the list of allowed client state types which can be created
   * and interacted with. If a client type is removed from the allowed clients list, usage
   * of this client will be disabled until it is added again to the list.
   */
  allowed_clients?: string[];
}

/**
 * QueryClientParamsResponse is the response type for the Query/ClientParams RPC
 * method.
 */
export interface IbcCoreClientV1QueryClientParamsResponse {
  /** params defines the parameters of the module. */
  params?: {
    /**
     * allowed_clients defines the list of allowed client state types which can be created
     * and interacted with. If a client type is removed from the allowed clients list, usage
     * of this client will be disabled until it is added again to the list.
     */
    allowed_clients?: string[];
  };
}

/**
 * QueryClientStateResponse is the response type for the Query/ClientState RPC
 * method. Besides the client state, it includes a proof and the height from
 * which the proof was retrieved.
 */
export interface IbcCoreClientV1QueryClientStateResponse {
  /**
   * client state associated with the request identifier
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  client_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * height at which the proof was retrieved
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryClientStatesResponse is the response type for the Query/ClientStates RPC
 * method.
 */
export interface IbcCoreClientV1QueryClientStatesResponse {
  /** list of stored ClientStates of the chain. */
  client_states?: {
    /** client identifier */
    client_id?: string;
    /**
     * client state
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    client_state?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
 * method. It returns the current status of the IBC client.
 */
export interface IbcCoreClientV1QueryClientStatusResponse {
  status?: string;
}

/**
 * QueryConsensusStateHeightsResponse is the response type for the
 * Query/ConsensusStateHeights RPC method
 */
export interface IbcCoreClientV1QueryConsensusStateHeightsResponse {
  /** consensus state heights */
  consensus_state_heights?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryConsensusStateResponse is the response type for the Query/ConsensusState
 * RPC method
 */
export interface IbcCoreClientV1QueryConsensusStateResponse {
  /**
   * consensus state associated with the client identifier at the given height
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  consensus_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
  /**
   * merkle proof of existence
   * @format byte
   */
  proof?: string;
  /**
   * Height is a monotonically increasing data type
   * that can be compared against another Height for the purposes of updating and
   * freezing clients
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
}

/**
 * QueryConsensusStatesResponse is the response type for the
 * Query/ConsensusStates RPC method
 */
export interface IbcCoreClientV1QueryConsensusStatesResponse {
  /** consensus states associated with the identifier */
  consensus_states?: {
    /**
     * consensus state height
     * Normally the RevisionHeight is incremented at each height while keeping
     * RevisionNumber the same. However some consensus algorithms may choose to
     * reset the height in certain conditions e.g. hard forks, state-machine
     * breaking changes In these cases, the RevisionNumber is incremented so that
     * height continues to be monitonically increasing even as the RevisionHeight
     * gets reset
     */
    height?: {
      /**
       * the revision that the client is currently on
       * @format uint64
       */
      revision_number?: string;
      /**
       * the height within the given revision
       * @format uint64
       */
      revision_height?: string;
    };
    /**
     * consensus state
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *     // or ...
     *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *       foo = any.unpack(Foo.getDefaultInstance());
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    consensus_state?: {
      /**
       * A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Must be a valid serialized protocol buffer of the above specified type.
       * @format byte
       */
      value?: string;
    };
  }[];
  /**
   * pagination response
   * PageResponse is to be embedded in gRPC response messages where the
   * corresponding request message has used PageRequest.
   *
   *  message SomeResponse {
   *          repeated Bar results = 1;
   *          PageResponse page = 2;
   *  }
   */
  pagination?: {
    /**
     * next_key is the key to be passed to PageRequest.key to
     * query the next page most efficiently. It will be empty if
     * there are no more results.
     * @format byte
     */
    next_key?: string;
    /**
     * total is total number of results available if PageRequest.count_total
     * was set, its value is undefined otherwise
     * @format uint64
     */
    total?: string;
  };
}

/**
 * QueryUpgradedClientStateResponse is the response type for the
 * Query/UpgradedClientState RPC method.
 */
export interface IbcCoreClientV1QueryUpgradedClientStateResponse {
  /**
   * client state associated with the request identifier
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  upgraded_client_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/**
 * QueryUpgradedConsensusStateResponse is the response type for the
 * Query/UpgradedConsensusState RPC method.
 */
export interface IbcCoreClientV1QueryUpgradedConsensusStateResponse {
  /**
   * Consensus state associated with the request identifier
   * `Any` contains an arbitrary serialized protocol buffer message along with a
   * URL that describes the type of the serialized message.
   *
   * Protobuf library provides support to pack/unpack Any values in the form
   * of utility functions or additional generated methods of the Any type.
   *
   * Example 1: Pack and unpack a message in C++.
   *
   *     Foo foo = ...;
   *     Any any;
   *     any.PackFrom(foo);
   *     ...
   *     if (any.UnpackTo(&foo)) {
   *       ...
   *     }
   *
   * Example 2: Pack and unpack a message in Java.
   *
   *     Foo foo = ...;
   *     Any any = Any.pack(foo);
   *     ...
   *     if (any.is(Foo.class)) {
   *       foo = any.unpack(Foo.class);
   *     }
   *     // or ...
   *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
   *       foo = any.unpack(Foo.getDefaultInstance());
   *     }
   *
   * Example 3: Pack and unpack a message in Python.
   *
   *     foo = Foo(...)
   *     any = Any()
   *     any.Pack(foo)
   *     ...
   *     if any.Is(Foo.DESCRIPTOR):
   *       any.Unpack(foo)
   *       ...
   *
   * Example 4: Pack and unpack a message in Go
   *
   *      foo := &pb.Foo{...}
   *      any, err := anypb.New(foo)
   *      if err != nil {
   *        ...
   *      }
   *      ...
   *      foo := &pb.Foo{}
   *      if err := any.UnmarshalTo(foo); err != nil {
   *        ...
   *      }
   *
   * The pack methods provided by protobuf library will by default use
   * 'type.googleapis.com/full.type.name' as the type URL and the unpack
   * methods only use the fully qualified type name after the last '/'
   * in the type URL, for example "foo.bar.com/x/y.z" will yield type
   * name "y.z".
   *
   * JSON
   *
   * The JSON representation of an `Any` value uses the regular
   * representation of the deserialized, embedded message, with an
   * additional field `@type` which contains the type URL. Example:
   *
   *     package google.profile;
   *     message Person {
   *       string first_name = 1;
   *       string last_name = 2;
   *     }
   *
   *     {
   *       "@type": "type.googleapis.com/google.profile.Person",
   *       "firstName": <string>,
   *       "lastName": <string>
   *     }
   *
   * If the embedded message type is well-known and has a custom JSON
   * representation, that representation will be embedded adding a field
   * `value` which holds the custom JSON in addition to the `@type`
   * field. Example (for message [google.protobuf.Duration][]):
   *
   *     {
   *       "@type": "type.googleapis.com/google.protobuf.Duration",
   *       "value": "1.212s"
   *     }
   */
  upgraded_consensus_state?: {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @format byte
     */
    value?: string;
  };
}

/** QueryVerifyMembershipRequest is the request type for the Query/VerifyMembership RPC method */
export interface IbcCoreClientV1QueryVerifyMembershipRequest {
  /** client unique identifier. */
  client_id?: string;
  /**
   * the proof to be verified by the client.
   * @format byte
   */
  proof?: string;
  /**
   * Height is a monotonically increasing data type
   * that can be compared against another Height for the purposes of updating and
   * freezing clients
   * Normally the RevisionHeight is incremented at each height while keeping
   * RevisionNumber the same. However some consensus algorithms may choose to
   * reset the height in certain conditions e.g. hard forks, state-machine
   * breaking changes In these cases, the RevisionNumber is incremented so that
   * height continues to be monitonically increasing even as the RevisionHeight
   * gets reset
   */
  proof_height?: {
    /**
     * the revision that the client is currently on
     * @format uint64
     */
    revision_number?: string;
    /**
     * the height within the given revision
     * @format uint64
     */
    revision_height?: string;
  };
  /**
   * MerklePath is the path used to verify commitment proofs, which can be an
   * arbitrary structured object (defined by a commitment type).
   * MerklePath is represented from root-to-leaf
   * the commitment key path.
   */
  merkle_path?: {
    key_path?: string[];
  };
  /**
   * the value which is proven.
   * @format byte
   */
  value?: string;
  /**
   * optional time delay
   * @format uint64
   */
  time_delay?: string;
  /**
   * optional block delay
   * @format uint64
   */
  block_delay?: string;
}

/** QueryVerifyMembershipResponse is the response type for the Query/VerifyMembership RPC method */
export interface IbcCoreClientV1QueryVerifyMembershipResponse {
  /** boolean indicating success or failure of proof verification. */
  success?: boolean;
}

/**
 * MerklePath is the path used to verify commitment proofs, which can be an
 * arbitrary structured object (defined by a commitment type).
 * MerklePath is represented from root-to-leaf
 */
export interface IbcCoreCommitmentV1MerklePath {
  key_path?: string[];
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<
  FullRequestParams,
  "body" | "method" | "query" | "path"
>;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown>
  extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json",
  JsonApi = "application/vnd.api+json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) =>
    fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter(
      (key) => "undefined" !== typeof query[key],
    );
    return keys
      .map((key) =>
        Array.isArray(query[key])
          ? this.addArrayQueryParam(query, key)
          : this.addQueryParam(query, key),
      )
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.JsonApi]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.Text]: (input: any) =>
      input !== null && typeof input !== "string"
        ? JSON.stringify(input)
        : input,
    [ContentType.FormData]: (input: any) => {
      if (input instanceof FormData) {
        return input;
      }

      return Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
              ? JSON.stringify(property)
              : `${property}`,
        );
        return formData;
      }, new FormData());
    },
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(
    params1: RequestParams,
    params2?: RequestParams,
  ): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (
    cancelToken: CancelToken,
  ): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<HttpResponse<T, E>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(
      `${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`,
      {
        ...requestParams,
        headers: {
          ...(requestParams.headers || {}),
          ...(type && type !== ContentType.FormData
            ? { "Content-Type": type }
            : {}),
        },
        signal:
          (cancelToken
            ? this.createAbortSignal(cancelToken)
            : requestParams.signal) || null,
        body:
          typeof body === "undefined" || body === null
            ? null
            : payloadFormatter(body),
      },
    ).then(async (response) => {
      const r = response as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const responseToParse = responseFormat ? response.clone() : response;
      const data = !responseFormat
        ? r
        : await responseToParse[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data;
    });
  };
}

/**
 * @title Kiichain - HTTP API Console
 * @version v1
 *
 * Kiichain REST API
 */
export class Api<
  SecurityDataType extends unknown,
> extends HttpClient<SecurityDataType> {
  cosmwasm = {
    /**
     * No description
     *
     * @tags Query
     * @name Codes
     * @summary Codes gets the metadata for all stored wasm codes
     * @request GET:/cosmwasm/wasm/v1/code
     */
    codes: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          code_infos?: {
            /** @format uint64 */
            code_id?: string;
            creator?: string;
            /** @format byte */
            data_hash?: string;
            /** AccessConfig access control type. */
            instantiate_permission?: {
              /**
               * AccessType permission types
               * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
               *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
               *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
               *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
               * @default "ACCESS_TYPE_UNSPECIFIED"
               */
              permission?:
                | "ACCESS_TYPE_UNSPECIFIED"
                | "ACCESS_TYPE_NOBODY"
                | "ACCESS_TYPE_EVERYBODY"
                | "ACCESS_TYPE_ANY_OF_ADDRESSES";
              addresses?: string[];
            };
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/code`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Code
     * @summary Code gets the binary code and metadata for a singe wasm code
     * @request GET:/cosmwasm/wasm/v1/code/{code_id}
     */
    code: (codeId: string, params: RequestParams = {}) =>
      this.request<
        {
          /** CodeInfoResponse contains code meta data from CodeInfo */
          code_info?: {
            /** @format uint64 */
            code_id?: string;
            creator?: string;
            /** @format byte */
            data_hash?: string;
            /** AccessConfig access control type. */
            instantiate_permission?: {
              /**
               * AccessType permission types
               * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
               *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
               *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
               *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
               * @default "ACCESS_TYPE_UNSPECIFIED"
               */
              permission?:
                | "ACCESS_TYPE_UNSPECIFIED"
                | "ACCESS_TYPE_NOBODY"
                | "ACCESS_TYPE_EVERYBODY"
                | "ACCESS_TYPE_ANY_OF_ADDRESSES";
              addresses?: string[];
            };
          };
          /** @format byte */
          data?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/code/${codeId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ContractsByCode
     * @summary ContractsByCode lists all smart contracts for a code id
     * @request GET:/cosmwasm/wasm/v1/code/{code_id}/contracts
     */
    contractsByCode: (
      codeId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** contracts are a set of contract addresses */
          contracts?: string[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/code/${codeId}/contracts`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name WasmParams
     * @summary Params gets the module params
     * @request GET:/cosmwasm/wasm/v1/codes/params
     */
    wasmParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /** AccessConfig access control type. */
            code_upload_access?: {
              /**
               * AccessType permission types
               * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
               *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
               *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
               *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
               * @default "ACCESS_TYPE_UNSPECIFIED"
               */
              permission?:
                | "ACCESS_TYPE_UNSPECIFIED"
                | "ACCESS_TYPE_NOBODY"
                | "ACCESS_TYPE_EVERYBODY"
                | "ACCESS_TYPE_ANY_OF_ADDRESSES";
              addresses?: string[];
            };
            /**
             * AccessType permission types
             * - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
             *  - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
             *  - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
             *  - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
             * @default "ACCESS_TYPE_UNSPECIFIED"
             */
            instantiate_default_permission?:
              | "ACCESS_TYPE_UNSPECIFIED"
              | "ACCESS_TYPE_NOBODY"
              | "ACCESS_TYPE_EVERYBODY"
              | "ACCESS_TYPE_ANY_OF_ADDRESSES";
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/codes/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name PinnedCodes
     * @summary PinnedCodes gets the pinned code ids
     * @request GET:/cosmwasm/wasm/v1/codes/pinned
     */
    pinnedCodes: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          code_ids?: string[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/codes/pinned`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name BuildAddress
     * @summary BuildAddress builds a contract address
     * @request GET:/cosmwasm/wasm/v1/contract/build_address
     */
    buildAddress: (
      query?: {
        /** CodeHash is the hash of the code. */
        code_hash?: string;
        /** CreatorAddress is the address of the contract instantiator. */
        creator_address?: string;
        /** Salt is a hex encoded salt. */
        salt?: string;
        /**
         * InitArgs are optional json encoded init args to be used in contract address
         * building if provided.
         * @format byte
         */
        init_args?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** Address is the contract address */
          address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contract/build_address`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ContractInfo
     * @summary ContractInfo gets the contract meta data
     * @request GET:/cosmwasm/wasm/v1/contract/{address}
     */
    contractInfo: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /** address is the address of the contract */
          address?: string;
          /** ContractInfo stores a WASM contract instance */
          contract_info?: {
            /**
             * CodeID is the reference to the stored Wasm code
             * @format uint64
             */
            code_id?: string;
            /** Creator address who initially instantiated the contract */
            creator?: string;
            /** Admin is an optional address that can execute migrations */
            admin?: string;
            /** Label is optional metadata to be stored with a contract instance. */
            label?: string;
            /** Created Tx position when the contract was instantiated. */
            created?: {
              /**
               * BlockHeight is the block the contract was created at
               * @format uint64
               */
              block_height?: string;
              /**
               * TxIndex is a monotonic counter within the block (actual transaction index,
               * or gas consumed)
               * @format uint64
               */
              tx_index?: string;
            };
            ibc_port_id?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            extension?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contract/${address}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ContractHistory
     * @summary ContractHistory gets the contract code history
     * @request GET:/cosmwasm/wasm/v1/contract/{address}/history
     */
    contractHistory: (
      address: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          entries?: {
            /**
             * ContractCodeHistoryOperationType actions that caused a code change
             * - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
             *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
             *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
             *  - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
             * @default "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
             */
            operation?:
              | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
              | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
              | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
              | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
            /**
             * CodeID is the reference to the stored WASM code
             * @format uint64
             */
            code_id?: string;
            /** Updated Tx position when the operation was executed. */
            updated?: {
              /**
               * BlockHeight is the block the contract was created at
               * @format uint64
               */
              block_height?: string;
              /**
               * TxIndex is a monotonic counter within the block (actual transaction index,
               * or gas consumed)
               * @format uint64
               */
              tx_index?: string;
            };
            /** @format byte */
            msg?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contract/${address}/history`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name RawContractState
     * @summary RawContractState gets single key from the raw store data of a contract
     * @request GET:/cosmwasm/wasm/v1/contract/{address}/raw/{query_data}
     */
    rawContractState: (
      address: string,
      queryData: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Data contains the raw store data
           * @format byte
           */
          data?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contract/${address}/raw/${queryData}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name SmartContractState
     * @summary SmartContractState get smart query result from the contract
     * @request GET:/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}
     */
    smartContractState: (
      address: string,
      queryData: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Data contains the json data returned from the smart contract
           * @format byte
           */
          data?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contract/${address}/smart/${queryData}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name AllContractState
     * @summary AllContractState gets all raw store data for a single contract
     * @request GET:/cosmwasm/wasm/v1/contract/{address}/state
     */
    allContractState: (
      address: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          models?: {
            /**
             * hex-encode key to read it better (this is often ascii)
             * @format byte
             */
            key?: string;
            /**
             * base64-encode raw value
             * @format byte
             */
            value?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contract/${address}/state`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ContractsByCreator
     * @summary ContractsByCreator gets the contracts by creator
     * @request GET:/cosmwasm/wasm/v1/contracts/creator/{creator_address}
     */
    contractsByCreator: (
      creatorAddress: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** ContractAddresses result set */
          contract_addresses?: string[];
          /** Pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmwasm/wasm/v1/contracts/creator/${creatorAddress}`,
        method: "GET",
        query: query,
        ...params,
      }),
  };
  kiichain = {
    /**
 * No description
 *
 * @tags Query
 * @name DenomAuthorityMetadata
 * @summary DenomAuthorityMetadata defines a gRPC query method for fetching
DenomAuthorityMetadata for a particular denom.
 * @request GET:/kiichain/tokenfactory/v1beta1/denoms/{denom}/authority_metadata
 */
    denomAuthorityMetadata: (denom: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * DenomAuthorityMetadata specifies metadata for addresses that have specific
           * capabilities over a token factory denom. Right now there is only one Admin
           * permission, but is planned to be extended to the future.
           */
          authority_metadata?: {
            /** Can be empty for no admin, or a valid kii address */
            admin?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/tokenfactory/v1beta1/denoms/${denom}/authority_metadata`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name DenomsFromAdmin
 * @summary DenomsFromAdmin defines a gRPC query method for fetching all
denominations owned by a specific admin.
 * @request GET:/kiichain/tokenfactory/v1beta1/denoms_from_admin/{admin}
 */
    denomsFromAdmin: (admin: string, params: RequestParams = {}) =>
      this.request<
        {
          denoms?: string[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/tokenfactory/v1beta1/denoms_from_admin/${admin}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name DenomsFromCreator
 * @summary DenomsFromCreator defines a gRPC query method for fetching all
denominations created by a specific admin/creator.
 * @request GET:/kiichain/tokenfactory/v1beta1/denoms_from_creator/{creator}
 */
    denomsFromCreator: (creator: string, params: RequestParams = {}) =>
      this.request<
        {
          denoms?: string[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/tokenfactory/v1beta1/denoms_from_creator/${creator}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name TokenFactoryParams
 * @summary Params defines a gRPC query method that returns the tokenfactory module's
parameters.
 * @request GET:/kiichain/tokenfactory/v1beta1/params
 */
    tokenFactoryParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            denom_creation_fee?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * if denom_creation_fee is an empty array, then this field is used to add
             * more gas consumption to the base cost.
             * https://github.com/CosmWasm/token-factory/issues/11
             * @format uint64
             */
            denom_creation_gas_consume?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/tokenfactory/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Actives
     * @summary Actives returns all actives denoms on the module's KVStore
     * @request GET:/kiichain/oracle/v1beta1/denoms/actives
     */
    actives: (params: RequestParams = {}) =>
      this.request<
        {
          actives?: string[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/denoms/actives`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ExchangeRates
     * @summary ExchangeRates returns the exchange rate for all denoms
     * @request GET:/kiichain/oracle/v1beta1/denoms/exchange_rates
     */
    exchangeRates: (params: RequestParams = {}) =>
      this.request<
        {
          denom_oracle_exchange_rate?: {
            denom?: string;
            /**
             * Data type that stores the final calculated exchange rate after all votes were
             * aggregated to that single exchange, record the last block height and timestamp when rate was updated
             */
            oracle_exchange_rate?: {
              exchange_rate?: string;
              last_update?: string;
              /** @format int64 */
              last_update_timestamp?: string;
            };
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/denoms/exchange_rates`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name PriceSnapshotHistory
     * @summary PriceSnapshotHistory returns the history of price snapshots for all assets
     * @request GET:/kiichain/oracle/v1beta1/denoms/price_snapshot_history
     */
    priceSnapshotHistory: (params: RequestParams = {}) =>
      this.request<
        {
          price_snapshot?: {
            /** @format int64 */
            snapshot_timestamp?: string;
            price_snapshot_items?: {
              denom?: string;
              /**
               * Data type that stores the final calculated exchange rate after all votes were
               * aggregated to that single exchange, record the last block height and timestamp when rate was updated
               */
              oracle_exchange_rate?: {
                exchange_rate?: string;
                last_update?: string;
                /** @format int64 */
                last_update_timestamp?: string;
              };
            }[];
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/denoms/price_snapshot_history`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name Twaps
 * @summary Twap = Time-weighted average price
Twaps returns the list of the average price over a specific period of time and denom
 * @request GET:/kiichain/oracle/v1beta1/denoms/twaps/{lookback_seconds}
 */
    twaps: (lookbackSeconds: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Twap = Time-weighted average price
           * oracle_twap is the average price over an specific period of time and denom
           */
          oracle_twap?: {
            denom?: string;
            twap?: string;
            /** @format int64 */
            lookback_seconds?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/denoms/twaps/${lookbackSeconds}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VoteTargets
     * @summary VoteTargets returns all vote targets denoms
     * @request GET:/kiichain/oracle/v1beta1/denoms/vote_targets
     */
    voteTargets: (params: RequestParams = {}) =>
      this.request<
        {
          vote_targets?: string[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/denoms/vote_targets`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ExchangeRate
     * @summary ExchangeRate returns exchange rate of a specific denom
     * @request GET:/kiichain/oracle/v1beta1/denoms/{denom}/exchange_rate
     */
    exchangeRate: (denom: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Data type that stores the final calculated exchange rate after all votes were
           * aggregated to that single exchange, record the last block height and timestamp when rate was updated
           */
          oracle_exchange_rate?: {
            exchange_rate?: string;
            last_update?: string;
            /** @format int64 */
            last_update_timestamp?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/denoms/${denom}/exchange_rate`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name OracleParams
     * @summary Params returns the Oracle module's params
     * @request GET:/kiichain/oracle/v1beta1/params
     */
    oracleParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** return the params module's params */
          params?: {
            /**
             * The number of blocks per voting
             * @format uint64
             */
            vote_period?: string;
            /**
             * Minimum percentage of validators required to approve a price. For instance, if vote_threshold = "0.5" at least 50% of validators must submit votes
             * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
             */
            vote_threshold?: string;
            /**
             * Acceptable deviation from the media price (higher and lower)
             * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
             */
            reward_band?: string;
            /**
             * List of allowed assets
             * DenomList is a custom data type, defined on x/oracle/types/denom.go
             */
            whitelist?: {
              /** Stores the name of a token pair, e.g: "BTC/USD" */
              name?: string;
            }[];
            /**
             * How much stake is slashed if a validator fails to submit votes
             * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
             */
            slash_fraction?: string;
            /**
             * Define the window (in blocks) to vote, if not receive penalties due to bad performance
             * @format uint64
             */
            slash_window?: string;
            /**
             * Minimum percentage of voting on windows to avoid slashing. For instance, if min_valid_per_window = 0.8, then a validator must submit votes in 80% of windows to avoid slashing
             * "cosmossdk.io/math.LegacyDec" = Cosmos SDK decimal data type
             */
            min_valid_per_window?: string;
            /**
             * How far back (in blocks) the module can compute historical price metrics
             * @format uint64
             */
            lookback_duration?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name SlashWindow
     * @summary SlashWindow returns slash window information
     * @request GET:/kiichain/oracle/v1beta1/slash_window
     */
    slashWindow: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * window_progress defines the number of voting periods
           * @format uint64
           */
          window_progress?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/slash_window`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name FeederDelegation
     * @summary FeederDelegation returns the delegator by the validator address
     * @request GET:/kiichain/oracle/v1beta1/validators/{validator_addr}/feeder
     */
    feederDelegation: (validatorAddr: string, params: RequestParams = {}) =>
      this.request<
        {
          /** delegated address */
          feed_addr?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/validators/${validatorAddr}/feeder`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VotePenaltyCounter
     * @summary VotePenaltyCounter returns the voting behavior by an specific validator
     * @request GET:/kiichain/oracle/v1beta1/validators/{validator_addr}/vote_penalty_counter
     */
    votePenaltyCounter: (validatorAddr: string, params: RequestParams = {}) =>
      this.request<
        {
          /** Returns the voting behavior per validator */
          vote_penalty_counter?: {
            /** @format uint64 */
            miss_count?: string;
            /** @format uint64 */
            abstain_count?: string;
            /** @format uint64 */
            success_count?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/oracle/v1beta1/validators/${validatorAddr}/vote_penalty_counter`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name RewardsParams
 * @summary Params defines a gRPC query method that returns the reward module's
parameters.
 * @request GET:/kiichain/rewards/v1beta1/params
 */
    rewardsParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /** Denom used */
            token_denom?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/rewards/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ReleaseSchedule
 * @summary ReleaseSchedule defines a gRPC query method for fetching
ReleaseSchedule data.
 * @request GET:/kiichain/rewards/v1beta1/release-schedule
 */
    releaseSchedule: (params: RequestParams = {}) =>
      this.request<
        {
          /** ReleaseSchedule defines information related to reward distribution */
          release_schedule?: {
            /**
             * Total amount to be rewarded
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            total_amount?: {
              denom?: string;
              amount?: string;
            };
            /**
             * Amount released
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            released_amount?: {
              denom?: string;
              amount?: string;
            };
            /**
             * Timestamp of end of release
             * @format date-time
             */
            end_time?: string;
            /**
             * Last height released
             * @format date-time
             */
            last_release_time?: string;
            /** If reward pool is active */
            active?: boolean;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/rewards/v1beta1/release-schedule`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name RewardPool
 * @summary RewardPool defines a gRPC query method for fetching
RewardPool data.
 * @request GET:/kiichain/rewards/v1beta1/reward-pool
 */
    rewardPool: (params: RequestParams = {}) =>
      this.request<
        {
          /** RewardPool is the global fee pool for distribution. */
          reward_pool?: {
            community_pool?: {
              denom?: string;
              amount?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/rewards/v1beta1/reward-pool`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name FeeTokens
     * @summary FeeTokens defines a gRPC query method that returns the fee tokens
     * @request GET:/kiichain/feeabstraction/v1beta1/fee_tokens
     */
    feeTokens: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Defines a collection of fee token metadata
           * fee_tokens defines the fee tokens registered in the module.
           */
          fee_tokens?: {
            /** Items is a repeated field of FeeTokenMetadata */
            items?: {
              /** Denom is the token denom */
              denom?: string;
              /** Identifier on the oracle module */
              oracle_denom?: string;
              /**
               * Decimals is the number of decimals for the token
               * @format int64
               */
              decimals?: number;
              /**
               * Price is the price of the token in the native denom
               * This price is paired against the native denom
               * So, this equals to the token/native denom
               */
              price?: string;
              /** Enabled indicates if the token is enabled for fee abstraction */
              enabled?: boolean;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/feeabstraction/v1beta1/fee_tokens`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name FeeAbstractionParams
     * @summary Params defines a gRPC query method that returns the fee abstraction params
     * @request GET:/kiichain/feeabstraction/v1beta1/params
     */
    feeAbstractionParams: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Params defines the parameters for the fee abstraction module
           * params defines the parameters of the module.
           */
          params?: {
            /** Native denom */
            native_denom?: string;
            /** Oracle module identifier */
            native_oracle_denom?: string;
            /** Enabled indicates if the fee abstraction module is enabled */
            enabled?: boolean;
            /** ClampFactor is the factor to clamp the price deviation */
            clamp_factor?: string;
            /**
             * TwapLookbackWindow is the lookback window for calculating TWAPs
             * @format uint64
             */
            twap_lookback_window?: string;
            /**
             * FallbackNativePrice is the fallback price for the native token if the
             * oracle price is not available (in USD)
             */
            fallback_native_price?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/kiichain/feeabstraction/v1beta1/params`,
        method: "GET",
        ...params,
      }),
  };
  cosmos = {
    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name AllBalances
     * @summary AllBalances queries the balance of all coins for a single account.
     * @request GET:/cosmos/bank/v1beta1/balances/{address}
     */
    allBalances: (
      address: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         * resolve_denom is the flag to resolve the denom into a human-readable form from the metadata.
         *
         * Since: cosmos-sdk 0.50
         */
        resolve_denom?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** balances is the balances of all the coins. */
          balances?: {
            denom?: string;
            amount?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/balances/${address}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Balance
     * @summary Balance queries the balance of a single coin for a single account.
     * @request GET:/cosmos/bank/v1beta1/balances/{address}/by_denom
     */
    balance: (
      address: string,
      query?: {
        /** denom is the coin denom to query balances for. */
        denom?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Coin defines a token with a denomination and an amount.
           *
           * NOTE: The amount field is an Int which implements the custom method
           * signatures required by gogoproto.
           */
          balance?: {
            denom?: string;
            amount?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/balances/${address}/by_denom`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set. Since: cosmos-sdk 0.46
 *
 * @tags Query
 * @name DenomOwners
 * @summary DenomOwners queries for all account addresses that own a particular token
denomination.
 * @request GET:/cosmos/bank/v1beta1/denom_owners/{denom}
 */
    denomOwners: (
      denom: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          denom_owners?: {
            /** address defines the address that owns a particular denomination. */
            address?: string;
            /**
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/denom_owners/${denom}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * @description Since: cosmos-sdk 0.50.3
 *
 * @tags Query
 * @name DenomOwnersByQuery
 * @summary DenomOwnersByQuery queries for all account addresses that own a particular token
denomination.
 * @request GET:/cosmos/bank/v1beta1/denom_owners_by_query
 */
    denomOwnersByQuery: (
      query?: {
        /** denom defines the coin denomination to query all account holders for. */
        denom?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          denom_owners?: {
            /** address defines the address that owns a particular denomination. */
            address?: string;
            /**
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/denom_owners_by_query`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name DenomsMetadata
 * @summary DenomsMetadata queries the client metadata for all registered coin
denominations.
 * @request GET:/cosmos/bank/v1beta1/denoms_metadata
 */
    denomsMetadata: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** metadata provides the client information for all the registered tokens. */
          metadatas?: {
            description?: string;
            /** denom_units represents the list of DenomUnit's for a given coin */
            denom_units?: {
              /** denom represents the string name of the given denom unit (e.g uatom). */
              denom?: string;
              /**
               * exponent represents power of 10 exponent that one must
               * raise the base_denom to in order to equal the given DenomUnit's denom
               * 1 denom = 10^exponent base_denom
               * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
               * exponent = 6, thus: 1 atom = 10^6 uatom).
               * @format int64
               */
              exponent?: number;
              /** aliases is a list of string aliases for the given denom */
              aliases?: string[];
            }[];
            /** base represents the base denom (should be the DenomUnit with exponent = 0). */
            base?: string;
            /**
             * display indicates the suggested denom that should be
             * displayed in clients.
             */
            display?: string;
            /**
             * name defines the name of the token (eg: Cosmos Atom)
             * Since: cosmos-sdk 0.43
             */
            name?: string;
            /**
             * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
             * be the same as the display.
             *
             * Since: cosmos-sdk 0.43
             */
            symbol?: string;
            /**
             * URI to a document (on or off-chain) that contains additional information. Optional.
             *
             * Since: cosmos-sdk 0.46
             */
            uri?: string;
            /**
             * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
             * the document didn't change. Optional.
             *
             * Since: cosmos-sdk 0.46
             */
            uri_hash?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/denoms_metadata`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DenomMetadata
     * @summary DenomMetadata queries the client metadata of a given coin denomination.
     * @request GET:/cosmos/bank/v1beta1/denoms_metadata/{denom}
     */
    denomMetadata: (denom: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Metadata represents a struct that describes
           * a basic token.
           */
          metadata?: {
            description?: string;
            /** denom_units represents the list of DenomUnit's for a given coin */
            denom_units?: {
              /** denom represents the string name of the given denom unit (e.g uatom). */
              denom?: string;
              /**
               * exponent represents power of 10 exponent that one must
               * raise the base_denom to in order to equal the given DenomUnit's denom
               * 1 denom = 10^exponent base_denom
               * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
               * exponent = 6, thus: 1 atom = 10^6 uatom).
               * @format int64
               */
              exponent?: number;
              /** aliases is a list of string aliases for the given denom */
              aliases?: string[];
            }[];
            /** base represents the base denom (should be the DenomUnit with exponent = 0). */
            base?: string;
            /**
             * display indicates the suggested denom that should be
             * displayed in clients.
             */
            display?: string;
            /**
             * name defines the name of the token (eg: Cosmos Atom)
             * Since: cosmos-sdk 0.43
             */
            name?: string;
            /**
             * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
             * be the same as the display.
             *
             * Since: cosmos-sdk 0.43
             */
            symbol?: string;
            /**
             * URI to a document (on or off-chain) that contains additional information. Optional.
             *
             * Since: cosmos-sdk 0.46
             */
            uri?: string;
            /**
             * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
             * the document didn't change. Optional.
             *
             * Since: cosmos-sdk 0.46
             */
            uri_hash?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/denoms_metadata/${denom}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DenomMetadataByQueryString
     * @summary DenomMetadataByQueryString queries the client metadata of a given coin denomination.
     * @request GET:/cosmos/bank/v1beta1/denoms_metadata_by_query_string
     */
    denomMetadataByQueryString: (
      query?: {
        /** denom is the coin denom to query the metadata for. */
        denom?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Metadata represents a struct that describes
           * a basic token.
           */
          metadata?: {
            description?: string;
            /** denom_units represents the list of DenomUnit's for a given coin */
            denom_units?: {
              /** denom represents the string name of the given denom unit (e.g uatom). */
              denom?: string;
              /**
               * exponent represents power of 10 exponent that one must
               * raise the base_denom to in order to equal the given DenomUnit's denom
               * 1 denom = 10^exponent base_denom
               * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
               * exponent = 6, thus: 1 atom = 10^6 uatom).
               * @format int64
               */
              exponent?: number;
              /** aliases is a list of string aliases for the given denom */
              aliases?: string[];
            }[];
            /** base represents the base denom (should be the DenomUnit with exponent = 0). */
            base?: string;
            /**
             * display indicates the suggested denom that should be
             * displayed in clients.
             */
            display?: string;
            /**
             * name defines the name of the token (eg: Cosmos Atom)
             * Since: cosmos-sdk 0.43
             */
            name?: string;
            /**
             * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
             * be the same as the display.
             *
             * Since: cosmos-sdk 0.43
             */
            symbol?: string;
            /**
             * URI to a document (on or off-chain) that contains additional information. Optional.
             *
             * Since: cosmos-sdk 0.46
             */
            uri?: string;
            /**
             * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
             * the document didn't change. Optional.
             *
             * Since: cosmos-sdk 0.46
             */
            uri_hash?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/denoms_metadata_by_query_string`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name BankParams
     * @summary Params queries the parameters of x/bank module.
     * @request GET:/cosmos/bank/v1beta1/params
     */
    bankParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params provides the parameters of the bank module. */
          params?: {
            /**
             * Deprecated: Use of SendEnabled in params is deprecated.
             * For genesis, use the newly added send_enabled field in the genesis object.
             * Storage, lookup, and manipulation of this information is now in the keeper.
             *
             * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
             */
            send_enabled?: {
              denom?: string;
              enabled?: boolean;
            }[];
            default_send_enabled?: boolean;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * @description This query only returns denominations that have specific SendEnabled settings. Any denomination that does not have a specific setting will use the default params.default_send_enabled, and will not be returned by this query. Since: cosmos-sdk 0.47
     *
     * @tags Query
     * @name SendEnabled
     * @summary SendEnabled queries for SendEnabled entries.
     * @request GET:/cosmos/bank/v1beta1/send_enabled
     */
    sendEnabled: (
      query?: {
        /** denoms is the specific denoms you want look up. Leave empty to get all entries. */
        denoms?: string[];
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          send_enabled?: {
            denom?: string;
            enabled?: boolean;
          }[];
          /**
           * pagination defines the pagination in the response. This field is only
           * populated if the denoms field in the request is empty.
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/send_enabled`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set. Since: cosmos-sdk 0.46
 *
 * @tags Query
 * @name SpendableBalances
 * @summary SpendableBalances queries the spendable balance of all coins for a single
account.
 * @request GET:/cosmos/bank/v1beta1/spendable_balances/{address}
 */
    spendableBalances: (
      address: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** balances is the spendable balances of all the coins. */
          balances?: {
            denom?: string;
            amount?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/spendable_balances/${address}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set. Since: cosmos-sdk 0.47
 *
 * @tags Query
 * @name SpendableBalanceByDenom
 * @summary SpendableBalanceByDenom queries the spendable balance of a single denom for
a single account.
 * @request GET:/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom
 */
    spendableBalanceByDenom: (
      address: string,
      query?: {
        /** denom is the coin denom to query balances for. */
        denom?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Coin defines a token with a denomination and an amount.
           *
           * NOTE: The amount field is an Int which implements the custom method
           * signatures required by gogoproto.
           */
          balance?: {
            denom?: string;
            amount?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/spendable_balances/${address}/by_denom`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name TotalSupply
     * @summary TotalSupply queries the total supply of all coins.
     * @request GET:/cosmos/bank/v1beta1/supply
     */
    totalSupply: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** supply is the supply of the coins */
          supply?: {
            denom?: string;
            amount?: string;
          }[];
          /**
           * pagination defines the pagination in the response.
           *
           * Since: cosmos-sdk 0.43
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/supply`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name SupplyOf
     * @summary SupplyOf queries the supply of a single coin.
     * @request GET:/cosmos/bank/v1beta1/supply/by_denom
     */
    supplyOf: (
      query?: {
        /** denom is the coin denom to query balances for. */
        denom?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Coin defines a token with a denomination and an amount.
           *
           * NOTE: The amount field is an Int which implements the custom method
           * signatures required by gogoproto.
           */
          amount?: {
            denom?: string;
            amount?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/bank/v1beta1/supply/by_denom`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Grants
     * @summary Returns list of `Authorization`, granted to the grantee by the granter.
     * @request GET:/cosmos/authz/v1beta1/grants
     */
    grants: (
      query?: {
        granter?: string;
        grantee?: string;
        /** Optional, msg_type_url, when set, will query only grants matching given msg type. */
        msg_type_url?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** authorizations is a list of grants granted for grantee by granter. */
          grants?: {
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            authorization?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /**
             * time when the grant will expire and will be pruned. If null, then the grant
             * doesn't have a time expiration (other conditions  in `authorization`
             * may apply to invalidate the grant)
             * @format date-time
             */
            expiration?: string;
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/authz/v1beta1/grants`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name GranteeGrants
     * @summary GranteeGrants returns a list of `GrantAuthorization` by grantee.
     * @request GET:/cosmos/authz/v1beta1/grants/grantee/{grantee}
     */
    granteeGrants: (
      grantee: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** grants is a list of grants granted to the grantee. */
          grants?: {
            granter?: string;
            grantee?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            authorization?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** @format date-time */
            expiration?: string;
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/authz/v1beta1/grants/grantee/${grantee}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name GranterGrants
     * @summary GranterGrants returns list of `GrantAuthorization`, granted by granter.
     * @request GET:/cosmos/authz/v1beta1/grants/granter/{granter}
     */
    granterGrants: (
      granter: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** grants is a list of grants granted by the granter. */
          grants?: {
            granter?: string;
            grantee?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            authorization?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** @format date-time */
            expiration?: string;
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/authz/v1beta1/grants/granter/${granter}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name DelegatorDelegations
     * @summary DelegatorDelegations queries all delegations of a given delegator address.
     * @request GET:/cosmos/staking/v1beta1/delegations/{delegator_addr}
     */
    delegatorDelegations: (
      delegatorAddr: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** delegation_responses defines all the delegations' info of a delegator. */
          delegation_responses?: {
            /**
             * Delegation represents the bond with tokens held by an account. It is
             * owned by one delegator, and is associated with the voting power of one
             * validator.
             */
            delegation?: {
              /** delegator_address is the encoded address of the delegator. */
              delegator_address?: string;
              /** validator_address is the encoded address of the validator. */
              validator_address?: string;
              /** shares define the delegation shares received. */
              shares?: string;
            };
            /**
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/delegations/${delegatorAddr}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name Redelegations
     * @summary Redelegations queries redelegations of given address.
     * @request GET:/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations
     */
    redelegations: (
      delegatorAddr: string,
      query?: {
        /** src_validator_addr defines the validator address to redelegate from. */
        src_validator_addr?: string;
        /** dst_validator_addr defines the validator address to redelegate to. */
        dst_validator_addr?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          redelegation_responses?: {
            /**
             * Redelegation contains the list of a particular delegator's redelegating bonds
             * from a particular source validator to a particular destination validator.
             */
            redelegation?: {
              /** delegator_address is the bech32-encoded address of the delegator. */
              delegator_address?: string;
              /** validator_src_address is the validator redelegation source operator address. */
              validator_src_address?: string;
              /** validator_dst_address is the validator redelegation destination operator address. */
              validator_dst_address?: string;
              /** entries are the redelegation entries. */
              entries?: {
                /**
                 * creation_height  defines the height which the redelegation took place.
                 * @format int64
                 */
                creation_height?: string;
                /**
                 * completion_time defines the unix time for redelegation completion.
                 * @format date-time
                 */
                completion_time?: string;
                /** initial_balance defines the initial balance when redelegation started. */
                initial_balance?: string;
                /** shares_dst is the amount of destination-validator shares created by redelegation. */
                shares_dst?: string;
                /**
                 * Incrementing id that uniquely identifies this entry
                 * @format uint64
                 */
                unbonding_id?: string;
                /**
                 * Strictly positive if this entry's unbonding has been stopped by external modules
                 * @format int64
                 */
                unbonding_on_hold_ref_count?: string;
              }[];
            };
            entries?: {
              /** RedelegationEntry defines a redelegation object with relevant metadata. */
              redelegation_entry?: {
                /**
                 * creation_height  defines the height which the redelegation took place.
                 * @format int64
                 */
                creation_height?: string;
                /**
                 * completion_time defines the unix time for redelegation completion.
                 * @format date-time
                 */
                completion_time?: string;
                /** initial_balance defines the initial balance when redelegation started. */
                initial_balance?: string;
                /** shares_dst is the amount of destination-validator shares created by redelegation. */
                shares_dst?: string;
                /**
                 * Incrementing id that uniquely identifies this entry
                 * @format uint64
                 */
                unbonding_id?: string;
                /**
                 * Strictly positive if this entry's unbonding has been stopped by external modules
                 * @format int64
                 */
                unbonding_on_hold_ref_count?: string;
              };
              balance?: string;
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/delegators/${delegatorAddr}/redelegations`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
 *
 * @tags Query
 * @name DelegatorUnbondingDelegations
 * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given
delegator address.
 * @request GET:/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations
 */
    delegatorUnbondingDelegations: (
      delegatorAddr: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          unbonding_responses?: {
            /** delegator_address is the encoded address of the delegator. */
            delegator_address?: string;
            /** validator_address is the encoded address of the validator. */
            validator_address?: string;
            /** entries are the unbonding delegation entries. */
            entries?: {
              /**
               * creation_height is the height which the unbonding took place.
               * @format int64
               */
              creation_height?: string;
              /**
               * completion_time is the unix time for unbonding completion.
               * @format date-time
               */
              completion_time?: string;
              /** initial_balance defines the tokens initially scheduled to receive at completion. */
              initial_balance?: string;
              /** balance defines the tokens to receive at completion. */
              balance?: string;
              /**
               * Incrementing id that uniquely identifies this entry
               * @format uint64
               */
              unbonding_id?: string;
              /**
               * Strictly positive if this entry's unbonding has been stopped by external modules
               * @format int64
               */
              unbonding_on_hold_ref_count?: string;
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/delegators/${delegatorAddr}/unbonding_delegations`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
 *
 * @tags Query
 * @name DelegatorValidators
 * @summary DelegatorValidators queries all validators info for given delegator
address.
 * @request GET:/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators
 */
    delegatorValidators: (
      delegatorAddr: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** validators defines the validators' info of a delegator. */
          validators?: {
            /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
            operator_address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_pubkey?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** jailed defined whether the validator has been jailed from bonded status or not. */
            jailed?: boolean;
            /**
             * status is the validator status (bonded/unbonding/unbonded).
             * @default "BOND_STATUS_UNSPECIFIED"
             */
            status?:
              | "BOND_STATUS_UNSPECIFIED"
              | "BOND_STATUS_UNBONDED"
              | "BOND_STATUS_UNBONDING"
              | "BOND_STATUS_BONDED";
            /** tokens define the delegated tokens (incl. self-delegation). */
            tokens?: string;
            /** delegator_shares defines total shares issued to a validator's delegators. */
            delegator_shares?: string;
            /** description defines the description terms for the validator. */
            description?: {
              /** moniker defines a human-readable name for the validator. */
              moniker?: string;
              /** identity defines an optional identity signature (ex. UPort or Keybase). */
              identity?: string;
              /** website defines an optional website link. */
              website?: string;
              /** security_contact defines an optional email for security contact. */
              security_contact?: string;
              /** details define other optional details. */
              details?: string;
            };
            /**
             * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
             * @format int64
             */
            unbonding_height?: string;
            /**
             * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
             * @format date-time
             */
            unbonding_time?: string;
            /** commission defines the commission parameters. */
            commission?: {
              /** commission_rates defines the initial commission rates to be used for creating a validator. */
              commission_rates?: {
                /** rate is the commission rate charged to delegators, as a fraction. */
                rate?: string;
                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                max_rate?: string;
                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                max_change_rate?: string;
              };
              /**
               * update_time is the last time the commission rate was changed.
               * @format date-time
               */
              update_time?: string;
            };
            /**
             * min_self_delegation is the validator's self declared minimum self delegation.
             *
             * Since: cosmos-sdk 0.46
             */
            min_self_delegation?: string;
            /**
             * strictly positive if this validator's unbonding has been stopped by external modules
             * @format int64
             */
            unbonding_on_hold_ref_count?: string;
            /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
            unbonding_ids?: string[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/delegators/${delegatorAddr}/validators`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name DelegatorValidator
 * @summary DelegatorValidator queries validator info for given delegator validator
pair.
 * @request GET:/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}
 */
    delegatorValidator: (
      delegatorAddr: string,
      validatorAddr: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Validator defines a validator, together with the total amount of the
           * Validator's bond shares and their exchange rate to coins. Slashing results in
           * a decrease in the exchange rate, allowing correct calculation of future
           * undelegations without iterating over delegators. When coins are delegated to
           * this validator, the validator is credited with a delegation whose number of
           * bond shares is based on the amount of coins delegated divided by the current
           * exchange rate. Voting power can be calculated as total bonded shares
           * multiplied by exchange rate.
           */
          validator?: {
            /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
            operator_address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_pubkey?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** jailed defined whether the validator has been jailed from bonded status or not. */
            jailed?: boolean;
            /**
             * status is the validator status (bonded/unbonding/unbonded).
             * @default "BOND_STATUS_UNSPECIFIED"
             */
            status?:
              | "BOND_STATUS_UNSPECIFIED"
              | "BOND_STATUS_UNBONDED"
              | "BOND_STATUS_UNBONDING"
              | "BOND_STATUS_BONDED";
            /** tokens define the delegated tokens (incl. self-delegation). */
            tokens?: string;
            /** delegator_shares defines total shares issued to a validator's delegators. */
            delegator_shares?: string;
            /** description defines the description terms for the validator. */
            description?: {
              /** moniker defines a human-readable name for the validator. */
              moniker?: string;
              /** identity defines an optional identity signature (ex. UPort or Keybase). */
              identity?: string;
              /** website defines an optional website link. */
              website?: string;
              /** security_contact defines an optional email for security contact. */
              security_contact?: string;
              /** details define other optional details. */
              details?: string;
            };
            /**
             * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
             * @format int64
             */
            unbonding_height?: string;
            /**
             * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
             * @format date-time
             */
            unbonding_time?: string;
            /** commission defines the commission parameters. */
            commission?: {
              /** commission_rates defines the initial commission rates to be used for creating a validator. */
              commission_rates?: {
                /** rate is the commission rate charged to delegators, as a fraction. */
                rate?: string;
                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                max_rate?: string;
                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                max_change_rate?: string;
              };
              /**
               * update_time is the last time the commission rate was changed.
               * @format date-time
               */
              update_time?: string;
            };
            /**
             * min_self_delegation is the validator's self declared minimum self delegation.
             *
             * Since: cosmos-sdk 0.46
             */
            min_self_delegation?: string;
            /**
             * strictly positive if this validator's unbonding has been stopped by external modules
             * @format int64
             */
            unbonding_on_hold_ref_count?: string;
            /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
            unbonding_ids?: string[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/delegators/${delegatorAddr}/validators/${validatorAddr}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name HistoricalInfo
     * @summary HistoricalInfo queries the historical info for given height.
     * @request GET:/cosmos/staking/v1beta1/historical_info/{height}
     */
    historicalInfo: (height: string, params: RequestParams = {}) =>
      this.request<
        {
          /** hist defines the historical info at the given height. */
          hist?: {
            /** Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** prev block info */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /** @format byte */
              proposer_address?: string;
            };
            valset?: {
              /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /**
               * `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *     // or ...
               *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
               *       foo = any.unpack(Foo.getDefaultInstance());
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              consensus_pubkey?: {
                /**
                 * A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Must be a valid serialized protocol buffer of the above specified type.
                 * @format byte
                 */
                value?: string;
              };
              /** jailed defined whether the validator has been jailed from bonded status or not. */
              jailed?: boolean;
              /**
               * status is the validator status (bonded/unbonding/unbonded).
               * @default "BOND_STATUS_UNSPECIFIED"
               */
              status?:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** description defines the description terms for the validator. */
              description?: {
                /** moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** website defines an optional website link. */
                website?: string;
                /** security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** details define other optional details. */
                details?: string;
              };
              /**
               * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               * @format int64
               */
              unbonding_height?: string;
              /**
               * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               * @format date-time
               */
              unbonding_time?: string;
              /** commission defines the commission parameters. */
              commission?: {
                /** commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * update_time is the last time the commission rate was changed.
                 * @format date-time
                 */
                update_time?: string;
              };
              /**
               * min_self_delegation is the validator's self declared minimum self delegation.
               *
               * Since: cosmos-sdk 0.46
               */
              min_self_delegation?: string;
              /**
               * strictly positive if this validator's unbonding has been stopped by external modules
               * @format int64
               */
              unbonding_on_hold_ref_count?: string;
              /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
              unbonding_ids?: string[];
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/historical_info/${height}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name StakingParams
     * @summary Parameters queries the staking parameters.
     * @request GET:/cosmos/staking/v1beta1/params
     */
    stakingParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params holds all the parameters of this module. */
          params?: {
            /** unbonding_time is the time duration of unbonding. */
            unbonding_time?: string;
            /**
             * max_validators is the maximum number of validators.
             * @format int64
             */
            max_validators?: number;
            /**
             * max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
             * @format int64
             */
            max_entries?: number;
            /**
             * historical_entries is the number of historical entries to persist.
             * @format int64
             */
            historical_entries?: number;
            /** bond_denom defines the bondable coin denomination. */
            bond_denom?: string;
            /** min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators */
            min_commission_rate?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Pool
     * @summary Pool queries the pool info.
     * @request GET:/cosmos/staking/v1beta1/pool
     */
    pool: (params: RequestParams = {}) =>
      this.request<
        {
          /** pool defines the pool info. */
          pool?: {
            not_bonded_tokens?: string;
            bonded_tokens?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/pool`,
        method: "GET",
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name Validators
     * @summary Validators queries all validators that match the given status.
     * @request GET:/cosmos/staking/v1beta1/validators
     */
    validators: (
      query?: {
        /** status enables to query for validators matching a given status. */
        status?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** validators contains all the queried validators. */
          validators?: {
            /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
            operator_address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_pubkey?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** jailed defined whether the validator has been jailed from bonded status or not. */
            jailed?: boolean;
            /**
             * status is the validator status (bonded/unbonding/unbonded).
             * @default "BOND_STATUS_UNSPECIFIED"
             */
            status?:
              | "BOND_STATUS_UNSPECIFIED"
              | "BOND_STATUS_UNBONDED"
              | "BOND_STATUS_UNBONDING"
              | "BOND_STATUS_BONDED";
            /** tokens define the delegated tokens (incl. self-delegation). */
            tokens?: string;
            /** delegator_shares defines total shares issued to a validator's delegators. */
            delegator_shares?: string;
            /** description defines the description terms for the validator. */
            description?: {
              /** moniker defines a human-readable name for the validator. */
              moniker?: string;
              /** identity defines an optional identity signature (ex. UPort or Keybase). */
              identity?: string;
              /** website defines an optional website link. */
              website?: string;
              /** security_contact defines an optional email for security contact. */
              security_contact?: string;
              /** details define other optional details. */
              details?: string;
            };
            /**
             * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
             * @format int64
             */
            unbonding_height?: string;
            /**
             * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
             * @format date-time
             */
            unbonding_time?: string;
            /** commission defines the commission parameters. */
            commission?: {
              /** commission_rates defines the initial commission rates to be used for creating a validator. */
              commission_rates?: {
                /** rate is the commission rate charged to delegators, as a fraction. */
                rate?: string;
                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                max_rate?: string;
                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                max_change_rate?: string;
              };
              /**
               * update_time is the last time the commission rate was changed.
               * @format date-time
               */
              update_time?: string;
            };
            /**
             * min_self_delegation is the validator's self declared minimum self delegation.
             *
             * Since: cosmos-sdk 0.46
             */
            min_self_delegation?: string;
            /**
             * strictly positive if this validator's unbonding has been stopped by external modules
             * @format int64
             */
            unbonding_on_hold_ref_count?: string;
            /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
            unbonding_ids?: string[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/validators`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Validator
     * @summary Validator queries validator info for given validator address.
     * @request GET:/cosmos/staking/v1beta1/validators/{validator_addr}
     */
    validator: (validatorAddr: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Validator defines a validator, together with the total amount of the
           * Validator's bond shares and their exchange rate to coins. Slashing results in
           * a decrease in the exchange rate, allowing correct calculation of future
           * undelegations without iterating over delegators. When coins are delegated to
           * this validator, the validator is credited with a delegation whose number of
           * bond shares is based on the amount of coins delegated divided by the current
           * exchange rate. Voting power can be calculated as total bonded shares
           * multiplied by exchange rate.
           */
          validator?: {
            /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
            operator_address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_pubkey?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** jailed defined whether the validator has been jailed from bonded status or not. */
            jailed?: boolean;
            /**
             * status is the validator status (bonded/unbonding/unbonded).
             * @default "BOND_STATUS_UNSPECIFIED"
             */
            status?:
              | "BOND_STATUS_UNSPECIFIED"
              | "BOND_STATUS_UNBONDED"
              | "BOND_STATUS_UNBONDING"
              | "BOND_STATUS_BONDED";
            /** tokens define the delegated tokens (incl. self-delegation). */
            tokens?: string;
            /** delegator_shares defines total shares issued to a validator's delegators. */
            delegator_shares?: string;
            /** description defines the description terms for the validator. */
            description?: {
              /** moniker defines a human-readable name for the validator. */
              moniker?: string;
              /** identity defines an optional identity signature (ex. UPort or Keybase). */
              identity?: string;
              /** website defines an optional website link. */
              website?: string;
              /** security_contact defines an optional email for security contact. */
              security_contact?: string;
              /** details define other optional details. */
              details?: string;
            };
            /**
             * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
             * @format int64
             */
            unbonding_height?: string;
            /**
             * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
             * @format date-time
             */
            unbonding_time?: string;
            /** commission defines the commission parameters. */
            commission?: {
              /** commission_rates defines the initial commission rates to be used for creating a validator. */
              commission_rates?: {
                /** rate is the commission rate charged to delegators, as a fraction. */
                rate?: string;
                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                max_rate?: string;
                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                max_change_rate?: string;
              };
              /**
               * update_time is the last time the commission rate was changed.
               * @format date-time
               */
              update_time?: string;
            };
            /**
             * min_self_delegation is the validator's self declared minimum self delegation.
             *
             * Since: cosmos-sdk 0.46
             */
            min_self_delegation?: string;
            /**
             * strictly positive if this validator's unbonding has been stopped by external modules
             * @format int64
             */
            unbonding_on_hold_ref_count?: string;
            /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
            unbonding_ids?: string[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/validators/${validatorAddr}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name ValidatorDelegations
     * @summary ValidatorDelegations queries delegate info for given validator.
     * @request GET:/cosmos/staking/v1beta1/validators/{validator_addr}/delegations
     */
    validatorDelegations: (
      validatorAddr: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          delegation_responses?: {
            /**
             * Delegation represents the bond with tokens held by an account. It is
             * owned by one delegator, and is associated with the voting power of one
             * validator.
             */
            delegation?: {
              /** delegator_address is the encoded address of the delegator. */
              delegator_address?: string;
              /** validator_address is the encoded address of the validator. */
              validator_address?: string;
              /** shares define the delegation shares received. */
              shares?: string;
            };
            /**
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/validators/${validatorAddr}/delegations`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Delegation
     * @summary Delegation queries delegate info for given validator delegator pair.
     * @request GET:/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}
     */
    delegation: (
      validatorAddr: string,
      delegatorAddr: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * DelegationResponse is equivalent to Delegation except that it contains a
           * balance in addition to shares which is more suitable for client responses.
           */
          delegation_response?: {
            /**
             * Delegation represents the bond with tokens held by an account. It is
             * owned by one delegator, and is associated with the voting power of one
             * validator.
             */
            delegation?: {
              /** delegator_address is the encoded address of the delegator. */
              delegator_address?: string;
              /** validator_address is the encoded address of the validator. */
              validator_address?: string;
              /** shares define the delegation shares received. */
              shares?: string;
            };
            /**
             * Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/validators/${validatorAddr}/delegations/${delegatorAddr}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name UnbondingDelegation
 * @summary UnbondingDelegation queries unbonding info for given validator delegator
pair.
 * @request GET:/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation
 */
    unbondingDelegation: (
      validatorAddr: string,
      delegatorAddr: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * UnbondingDelegation stores all of a single delegator's unbonding bonds
           * for a single validator in an time-ordered list.
           */
          unbond?: {
            /** delegator_address is the encoded address of the delegator. */
            delegator_address?: string;
            /** validator_address is the encoded address of the validator. */
            validator_address?: string;
            /** entries are the unbonding delegation entries. */
            entries?: {
              /**
               * creation_height is the height which the unbonding took place.
               * @format int64
               */
              creation_height?: string;
              /**
               * completion_time is the unix time for unbonding completion.
               * @format date-time
               */
              completion_time?: string;
              /** initial_balance defines the tokens initially scheduled to receive at completion. */
              initial_balance?: string;
              /** balance defines the tokens to receive at completion. */
              balance?: string;
              /**
               * Incrementing id that uniquely identifies this entry
               * @format uint64
               */
              unbonding_id?: string;
              /**
               * Strictly positive if this entry's unbonding has been stopped by external modules
               * @format int64
               */
              unbonding_on_hold_ref_count?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/validators/${validatorAddr}/delegations/${delegatorAddr}/unbonding_delegation`,
        method: "GET",
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set.
     *
     * @tags Query
     * @name ValidatorUnbondingDelegations
     * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
     * @request GET:/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations
     */
    validatorUnbondingDelegations: (
      validatorAddr: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          unbonding_responses?: {
            /** delegator_address is the encoded address of the delegator. */
            delegator_address?: string;
            /** validator_address is the encoded address of the validator. */
            validator_address?: string;
            /** entries are the unbonding delegation entries. */
            entries?: {
              /**
               * creation_height is the height which the unbonding took place.
               * @format int64
               */
              creation_height?: string;
              /**
               * completion_time is the unix time for unbonding completion.
               * @format date-time
               */
              completion_time?: string;
              /** initial_balance defines the tokens initially scheduled to receive at completion. */
              initial_balance?: string;
              /** balance defines the tokens to receive at completion. */
              balance?: string;
              /**
               * Incrementing id that uniquely identifies this entry
               * @format uint64
               */
              unbonding_id?: string;
              /**
               * Strictly positive if this entry's unbonding has been stopped by external modules
               * @format int64
               */
              unbonding_on_hold_ref_count?: string;
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/staking/v1beta1/validators/${validatorAddr}/unbonding_delegations`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name AppliedPlan
     * @summary AppliedPlan queries a previously applied upgrade plan by its name.
     * @request GET:/cosmos/upgrade/v1beta1/applied_plan/{name}
     */
    appliedPlan: (name: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * height is the block height at which the plan was applied.
           * @format int64
           */
          height?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/upgrade/v1beta1/applied_plan/${name}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name Authority
     * @summary Returns the account with authority to conduct upgrades
     * @request GET:/cosmos/upgrade/v1beta1/authority
     */
    authority: (params: RequestParams = {}) =>
      this.request<
        {
          address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/upgrade/v1beta1/authority`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name CurrentPlan
     * @summary CurrentPlan queries the current upgrade plan.
     * @request GET:/cosmos/upgrade/v1beta1/current_plan
     */
    currentPlan: (params: RequestParams = {}) =>
      this.request<
        {
          /** plan is the current upgrade plan. */
          plan?: {
            /**
             * Sets the name for the upgrade. This name will be used by the upgraded
             * version of the software to apply any special "on-upgrade" commands during
             * the first BeginBlock method after the upgrade is applied. It is also used
             * to detect whether a software version can handle a given upgrade. If no
             * upgrade handler with this name has been set in the software, it will be
             * assumed that the software is out-of-date when the upgrade Time or Height is
             * reached and the software will exit.
             */
            name?: string;
            /**
             * Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
             * has been removed from the SDK.
             * If this field is not empty, an error will be thrown.
             * @format date-time
             */
            time?: string;
            /**
             * The height at which the upgrade must be performed.
             * @format int64
             */
            height?: string;
            /**
             * Any application specific upgrade info to be included on-chain
             * such as a git commit that validators could automatically upgrade to
             */
            info?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            upgraded_client_state?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/upgrade/v1beta1/current_plan`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.43
     *
     * @tags Query
     * @name ModuleVersions
     * @summary ModuleVersions queries the list of module versions from state.
     * @request GET:/cosmos/upgrade/v1beta1/module_versions
     */
    moduleVersions: (
      query?: {
        /**
         * module_name is a field to query a specific module
         * consensus version from state. Leaving this empty will
         * fetch the full list of module versions from state.
         */
        module_name?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** module_versions is a list of module names with their consensus versions. */
          module_versions?: {
            /** name of the app module */
            name?: string;
            /**
             * consensus version of the app module
             * @format uint64
             */
            version?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/upgrade/v1beta1/module_versions`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name UpgradedConsensusState
 * @summary UpgradedConsensusState queries the consensus state that will serve
as a trusted kernel for the next version of this chain. It will only be
stored at the last height of this chain.
UpgradedConsensusState RPC not supported with legacy querier
This rpc is deprecated now that IBC has its own replacement
(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)
 * @request GET:/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}
 */
    upgradedConsensusState: (lastHeight: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Since: cosmos-sdk 0.43
           * @format byte
           */
          upgraded_consensus_state?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/upgrade/v1beta1/upgraded_consensus_state/${lastHeight}`,
        method: "GET",
        ...params,
      }),

    /**
 * @description Since: cosmos-sdk 0.46
 *
 * @tags Service
 * @name AbciQuery
 * @summary ABCIQuery defines a query handler that supports ABCI queries directly to the
application, bypassing Tendermint completely. The ABCI query must contain
a valid and supported path, including app, custom, p2p, and store.
 * @request GET:/cosmos/base/tendermint/v1beta1/abci_query
 */
    abciQuery: (
      query?: {
        /** @format byte */
        data?: string;
        path?: string;
        /** @format int64 */
        height?: string;
        prove?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** @format int64 */
          code?: number;
          log?: string;
          info?: string;
          /** @format int64 */
          index?: string;
          /** @format byte */
          key?: string;
          /** @format byte */
          value?: string;
          /**
           * ProofOps is Merkle proof defined by the list of ProofOps.
           *
           * Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
           */
          proof_ops?: {
            ops?: {
              type?: string;
              /** @format byte */
              key?: string;
              /** @format byte */
              data?: string;
            }[];
          };
          /** @format int64 */
          height?: string;
          codespace?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/abci_query`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetLatestBlock
     * @summary GetLatestBlock returns the latest block.
     * @request GET:/cosmos/base/tendermint/v1beta1/blocks/latest
     */
    getLatestBlock: (params: RequestParams = {}) =>
      this.request<
        {
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /** Deprecated: please use `sdk_block` instead */
          block?: {
            /** Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /** @format byte */
              proposer_address?: string;
            };
            /** Data contains the set of transactions included in the block */
            data?: {
              /**
               * Txs that will be applied by state @ block.Height+1.
               * NOTE: not all txs here are valid.  We're just agreeing on the order first.
               * This means that block.AppHash does not include these txs.
               */
              txs?: string[];
            };
            evidence?: {
              evidence?: {
                /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                duplicate_vote_evidence?: {
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_a?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_b?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format int64 */
                  validator_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
                /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                light_client_attack_evidence?: {
                  conflicting_block?: {
                    signed_header?: {
                      /** Header defines the structure of a block header. */
                      header?: {
                        /**
                         * basic block info
                         * Consensus captures the consensus rules for processing a block in the blockchain,
                         * including all blockchain data structures and the rules of the application's
                         * state transition machine.
                         */
                        version?: {
                          /** @format uint64 */
                          block?: string;
                          /** @format uint64 */
                          app?: string;
                        };
                        chain_id?: string;
                        /** @format int64 */
                        height?: string;
                        /** @format date-time */
                        time?: string;
                        /** BlockID */
                        last_block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        /**
                         * hashes of block data
                         * @format byte
                         */
                        last_commit_hash?: string;
                        /** @format byte */
                        data_hash?: string;
                        /**
                         * hashes from the app output from the prev block
                         * @format byte
                         */
                        validators_hash?: string;
                        /** @format byte */
                        next_validators_hash?: string;
                        /** @format byte */
                        consensus_hash?: string;
                        /** @format byte */
                        app_hash?: string;
                        /** @format byte */
                        last_results_hash?: string;
                        /**
                         * consensus info
                         * @format byte
                         */
                        evidence_hash?: string;
                        /** @format byte */
                        proposer_address?: string;
                      };
                      /** Commit contains the evidence that a block was committed by a set of validators. */
                      commit?: {
                        /** @format int64 */
                        height?: string;
                        /** @format int32 */
                        round?: number;
                        /** BlockID */
                        block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        signatures?: {
                          /**
                           * BlockIdFlag indicates which BlockID the signature is for
                           * @default "BLOCK_ID_FLAG_UNKNOWN"
                           */
                          block_id_flag?:
                            | "BLOCK_ID_FLAG_UNKNOWN"
                            | "BLOCK_ID_FLAG_ABSENT"
                            | "BLOCK_ID_FLAG_COMMIT"
                            | "BLOCK_ID_FLAG_NIL";
                          /** @format byte */
                          validator_address?: string;
                          /** @format date-time */
                          timestamp?: string;
                          /** @format byte */
                          signature?: string;
                        }[];
                      };
                    };
                    validator_set?: {
                      validators?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      }[];
                      proposer?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      };
                      /** @format int64 */
                      total_voting_power?: string;
                    };
                  };
                  /** @format int64 */
                  common_height?: string;
                  byzantine_validators?: {
                    /** @format byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** @format byte */
                      ed25519?: string;
                      /** @format byte */
                      secp256k1?: string;
                    };
                    /** @format int64 */
                    voting_power?: string;
                    /** @format int64 */
                    proposer_priority?: string;
                  }[];
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
              }[];
            };
            /** Commit contains the evidence that a block was committed by a set of validators. */
            last_commit?: {
              /** @format int64 */
              height?: string;
              /** @format int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default "BLOCK_ID_FLAG_UNKNOWN"
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** @format byte */
                validator_address?: string;
                /** @format date-time */
                timestamp?: string;
                /** @format byte */
                signature?: string;
              }[];
            };
          };
          /**
           * Since: cosmos-sdk 0.47
           * Block is tendermint type Block, with the Header proposer address
           * field converted to bech32 string.
           */
          sdk_block?: {
            /** Header defines the structure of a Tendermint block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /**
               * proposer_address is the original block proposer address, formatted as a Bech32 string.
               * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
               * for better UX.
               */
              proposer_address?: string;
            };
            /** Data contains the set of transactions included in the block */
            data?: {
              /**
               * Txs that will be applied by state @ block.Height+1.
               * NOTE: not all txs here are valid.  We're just agreeing on the order first.
               * This means that block.AppHash does not include these txs.
               */
              txs?: string[];
            };
            evidence?: {
              evidence?: {
                /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                duplicate_vote_evidence?: {
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_a?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_b?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format int64 */
                  validator_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
                /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                light_client_attack_evidence?: {
                  conflicting_block?: {
                    signed_header?: {
                      /** Header defines the structure of a block header. */
                      header?: {
                        /**
                         * basic block info
                         * Consensus captures the consensus rules for processing a block in the blockchain,
                         * including all blockchain data structures and the rules of the application's
                         * state transition machine.
                         */
                        version?: {
                          /** @format uint64 */
                          block?: string;
                          /** @format uint64 */
                          app?: string;
                        };
                        chain_id?: string;
                        /** @format int64 */
                        height?: string;
                        /** @format date-time */
                        time?: string;
                        /** BlockID */
                        last_block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        /**
                         * hashes of block data
                         * @format byte
                         */
                        last_commit_hash?: string;
                        /** @format byte */
                        data_hash?: string;
                        /**
                         * hashes from the app output from the prev block
                         * @format byte
                         */
                        validators_hash?: string;
                        /** @format byte */
                        next_validators_hash?: string;
                        /** @format byte */
                        consensus_hash?: string;
                        /** @format byte */
                        app_hash?: string;
                        /** @format byte */
                        last_results_hash?: string;
                        /**
                         * consensus info
                         * @format byte
                         */
                        evidence_hash?: string;
                        /** @format byte */
                        proposer_address?: string;
                      };
                      /** Commit contains the evidence that a block was committed by a set of validators. */
                      commit?: {
                        /** @format int64 */
                        height?: string;
                        /** @format int32 */
                        round?: number;
                        /** BlockID */
                        block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        signatures?: {
                          /**
                           * BlockIdFlag indicates which BlockID the signature is for
                           * @default "BLOCK_ID_FLAG_UNKNOWN"
                           */
                          block_id_flag?:
                            | "BLOCK_ID_FLAG_UNKNOWN"
                            | "BLOCK_ID_FLAG_ABSENT"
                            | "BLOCK_ID_FLAG_COMMIT"
                            | "BLOCK_ID_FLAG_NIL";
                          /** @format byte */
                          validator_address?: string;
                          /** @format date-time */
                          timestamp?: string;
                          /** @format byte */
                          signature?: string;
                        }[];
                      };
                    };
                    validator_set?: {
                      validators?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      }[];
                      proposer?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      };
                      /** @format int64 */
                      total_voting_power?: string;
                    };
                  };
                  /** @format int64 */
                  common_height?: string;
                  byzantine_validators?: {
                    /** @format byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** @format byte */
                      ed25519?: string;
                      /** @format byte */
                      secp256k1?: string;
                    };
                    /** @format int64 */
                    voting_power?: string;
                    /** @format int64 */
                    proposer_priority?: string;
                  }[];
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
              }[];
            };
            /** Commit contains the evidence that a block was committed by a set of validators. */
            last_commit?: {
              /** @format int64 */
              height?: string;
              /** @format int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default "BLOCK_ID_FLAG_UNKNOWN"
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** @format byte */
                validator_address?: string;
                /** @format date-time */
                timestamp?: string;
                /** @format byte */
                signature?: string;
              }[];
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/blocks/latest`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetBlockByHeight
     * @summary GetBlockByHeight queries block for given height.
     * @request GET:/cosmos/base/tendermint/v1beta1/blocks/{height}
     */
    getBlockByHeight: (height: string, params: RequestParams = {}) =>
      this.request<
        {
          /** BlockID */
          block_id?: {
            /** @format byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** @format int64 */
              total?: number;
              /** @format byte */
              hash?: string;
            };
          };
          /** Deprecated: please use `sdk_block` instead */
          block?: {
            /** Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /** @format byte */
              proposer_address?: string;
            };
            /** Data contains the set of transactions included in the block */
            data?: {
              /**
               * Txs that will be applied by state @ block.Height+1.
               * NOTE: not all txs here are valid.  We're just agreeing on the order first.
               * This means that block.AppHash does not include these txs.
               */
              txs?: string[];
            };
            evidence?: {
              evidence?: {
                /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                duplicate_vote_evidence?: {
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_a?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_b?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format int64 */
                  validator_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
                /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                light_client_attack_evidence?: {
                  conflicting_block?: {
                    signed_header?: {
                      /** Header defines the structure of a block header. */
                      header?: {
                        /**
                         * basic block info
                         * Consensus captures the consensus rules for processing a block in the blockchain,
                         * including all blockchain data structures and the rules of the application's
                         * state transition machine.
                         */
                        version?: {
                          /** @format uint64 */
                          block?: string;
                          /** @format uint64 */
                          app?: string;
                        };
                        chain_id?: string;
                        /** @format int64 */
                        height?: string;
                        /** @format date-time */
                        time?: string;
                        /** BlockID */
                        last_block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        /**
                         * hashes of block data
                         * @format byte
                         */
                        last_commit_hash?: string;
                        /** @format byte */
                        data_hash?: string;
                        /**
                         * hashes from the app output from the prev block
                         * @format byte
                         */
                        validators_hash?: string;
                        /** @format byte */
                        next_validators_hash?: string;
                        /** @format byte */
                        consensus_hash?: string;
                        /** @format byte */
                        app_hash?: string;
                        /** @format byte */
                        last_results_hash?: string;
                        /**
                         * consensus info
                         * @format byte
                         */
                        evidence_hash?: string;
                        /** @format byte */
                        proposer_address?: string;
                      };
                      /** Commit contains the evidence that a block was committed by a set of validators. */
                      commit?: {
                        /** @format int64 */
                        height?: string;
                        /** @format int32 */
                        round?: number;
                        /** BlockID */
                        block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        signatures?: {
                          /**
                           * BlockIdFlag indicates which BlockID the signature is for
                           * @default "BLOCK_ID_FLAG_UNKNOWN"
                           */
                          block_id_flag?:
                            | "BLOCK_ID_FLAG_UNKNOWN"
                            | "BLOCK_ID_FLAG_ABSENT"
                            | "BLOCK_ID_FLAG_COMMIT"
                            | "BLOCK_ID_FLAG_NIL";
                          /** @format byte */
                          validator_address?: string;
                          /** @format date-time */
                          timestamp?: string;
                          /** @format byte */
                          signature?: string;
                        }[];
                      };
                    };
                    validator_set?: {
                      validators?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      }[];
                      proposer?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      };
                      /** @format int64 */
                      total_voting_power?: string;
                    };
                  };
                  /** @format int64 */
                  common_height?: string;
                  byzantine_validators?: {
                    /** @format byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** @format byte */
                      ed25519?: string;
                      /** @format byte */
                      secp256k1?: string;
                    };
                    /** @format int64 */
                    voting_power?: string;
                    /** @format int64 */
                    proposer_priority?: string;
                  }[];
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
              }[];
            };
            /** Commit contains the evidence that a block was committed by a set of validators. */
            last_commit?: {
              /** @format int64 */
              height?: string;
              /** @format int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default "BLOCK_ID_FLAG_UNKNOWN"
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** @format byte */
                validator_address?: string;
                /** @format date-time */
                timestamp?: string;
                /** @format byte */
                signature?: string;
              }[];
            };
          };
          /**
           * Since: cosmos-sdk 0.47
           * Block is tendermint type Block, with the Header proposer address
           * field converted to bech32 string.
           */
          sdk_block?: {
            /** Header defines the structure of a Tendermint block header. */
            header?: {
              /**
               * basic block info
               * Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** @format uint64 */
                block?: string;
                /** @format uint64 */
                app?: string;
              };
              chain_id?: string;
              /** @format int64 */
              height?: string;
              /** @format date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * @format byte
               */
              last_commit_hash?: string;
              /** @format byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * @format byte
               */
              validators_hash?: string;
              /** @format byte */
              next_validators_hash?: string;
              /** @format byte */
              consensus_hash?: string;
              /** @format byte */
              app_hash?: string;
              /** @format byte */
              last_results_hash?: string;
              /**
               * consensus info
               * @format byte
               */
              evidence_hash?: string;
              /**
               * proposer_address is the original block proposer address, formatted as a Bech32 string.
               * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
               * for better UX.
               */
              proposer_address?: string;
            };
            /** Data contains the set of transactions included in the block */
            data?: {
              /**
               * Txs that will be applied by state @ block.Height+1.
               * NOTE: not all txs here are valid.  We're just agreeing on the order first.
               * This means that block.AppHash does not include these txs.
               */
              txs?: string[];
            };
            evidence?: {
              evidence?: {
                /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                duplicate_vote_evidence?: {
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_a?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /**
                   * Vote represents a prevote or precommit vote from validators for
                   * consensus.
                   */
                  vote_b?: {
                    /**
                     * SignedMsgType is a type of signed message in the consensus.
                     *
                     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                     * @default "SIGNED_MSG_TYPE_UNKNOWN"
                     */
                    type?:
                      | "SIGNED_MSG_TYPE_UNKNOWN"
                      | "SIGNED_MSG_TYPE_PREVOTE"
                      | "SIGNED_MSG_TYPE_PRECOMMIT"
                      | "SIGNED_MSG_TYPE_PROPOSAL";
                    /** @format int64 */
                    height?: string;
                    /** @format int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** @format byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** @format int64 */
                        total?: number;
                        /** @format byte */
                        hash?: string;
                      };
                    };
                    /** @format date-time */
                    timestamp?: string;
                    /** @format byte */
                    validator_address?: string;
                    /** @format int32 */
                    validator_index?: number;
                    /**
                     * Vote signature by the validator if they participated in consensus for the
                     * associated block.
                     * @format byte
                     */
                    signature?: string;
                    /**
                     * Vote extension provided by the application. Only valid for precommit
                     * messages.
                     * @format byte
                     */
                    extension?: string;
                    /**
                     * Vote extension signature by the validator if they participated in
                     * consensus for the associated block.
                     * Only valid for precommit messages.
                     * @format byte
                     */
                    extension_signature?: string;
                  };
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format int64 */
                  validator_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
                /** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                light_client_attack_evidence?: {
                  conflicting_block?: {
                    signed_header?: {
                      /** Header defines the structure of a block header. */
                      header?: {
                        /**
                         * basic block info
                         * Consensus captures the consensus rules for processing a block in the blockchain,
                         * including all blockchain data structures and the rules of the application's
                         * state transition machine.
                         */
                        version?: {
                          /** @format uint64 */
                          block?: string;
                          /** @format uint64 */
                          app?: string;
                        };
                        chain_id?: string;
                        /** @format int64 */
                        height?: string;
                        /** @format date-time */
                        time?: string;
                        /** BlockID */
                        last_block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        /**
                         * hashes of block data
                         * @format byte
                         */
                        last_commit_hash?: string;
                        /** @format byte */
                        data_hash?: string;
                        /**
                         * hashes from the app output from the prev block
                         * @format byte
                         */
                        validators_hash?: string;
                        /** @format byte */
                        next_validators_hash?: string;
                        /** @format byte */
                        consensus_hash?: string;
                        /** @format byte */
                        app_hash?: string;
                        /** @format byte */
                        last_results_hash?: string;
                        /**
                         * consensus info
                         * @format byte
                         */
                        evidence_hash?: string;
                        /** @format byte */
                        proposer_address?: string;
                      };
                      /** Commit contains the evidence that a block was committed by a set of validators. */
                      commit?: {
                        /** @format int64 */
                        height?: string;
                        /** @format int32 */
                        round?: number;
                        /** BlockID */
                        block_id?: {
                          /** @format byte */
                          hash?: string;
                          /** PartsetHeader */
                          part_set_header?: {
                            /** @format int64 */
                            total?: number;
                            /** @format byte */
                            hash?: string;
                          };
                        };
                        signatures?: {
                          /**
                           * BlockIdFlag indicates which BlockID the signature is for
                           * @default "BLOCK_ID_FLAG_UNKNOWN"
                           */
                          block_id_flag?:
                            | "BLOCK_ID_FLAG_UNKNOWN"
                            | "BLOCK_ID_FLAG_ABSENT"
                            | "BLOCK_ID_FLAG_COMMIT"
                            | "BLOCK_ID_FLAG_NIL";
                          /** @format byte */
                          validator_address?: string;
                          /** @format date-time */
                          timestamp?: string;
                          /** @format byte */
                          signature?: string;
                        }[];
                      };
                    };
                    validator_set?: {
                      validators?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      }[];
                      proposer?: {
                        /** @format byte */
                        address?: string;
                        /** PublicKey defines the keys available for use with Validators */
                        pub_key?: {
                          /** @format byte */
                          ed25519?: string;
                          /** @format byte */
                          secp256k1?: string;
                        };
                        /** @format int64 */
                        voting_power?: string;
                        /** @format int64 */
                        proposer_priority?: string;
                      };
                      /** @format int64 */
                      total_voting_power?: string;
                    };
                  };
                  /** @format int64 */
                  common_height?: string;
                  byzantine_validators?: {
                    /** @format byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** @format byte */
                      ed25519?: string;
                      /** @format byte */
                      secp256k1?: string;
                    };
                    /** @format int64 */
                    voting_power?: string;
                    /** @format int64 */
                    proposer_priority?: string;
                  }[];
                  /** @format int64 */
                  total_voting_power?: string;
                  /** @format date-time */
                  timestamp?: string;
                };
              }[];
            };
            /** Commit contains the evidence that a block was committed by a set of validators. */
            last_commit?: {
              /** @format int64 */
              height?: string;
              /** @format int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** @format byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** @format int64 */
                  total?: number;
                  /** @format byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default "BLOCK_ID_FLAG_UNKNOWN"
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** @format byte */
                validator_address?: string;
                /** @format date-time */
                timestamp?: string;
                /** @format byte */
                signature?: string;
              }[];
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/blocks/${height}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetNodeInfo
     * @summary GetNodeInfo queries the current node info.
     * @request GET:/cosmos/base/tendermint/v1beta1/node_info
     */
    getNodeInfo: (params: RequestParams = {}) =>
      this.request<
        {
          default_node_info?: {
            protocol_version?: {
              /** @format uint64 */
              p2p?: string;
              /** @format uint64 */
              block?: string;
              /** @format uint64 */
              app?: string;
            };
            default_node_id?: string;
            listen_addr?: string;
            network?: string;
            version?: string;
            /** @format byte */
            channels?: string;
            moniker?: string;
            other?: {
              tx_index?: string;
              rpc_address?: string;
            };
          };
          /** VersionInfo is the type for the GetNodeInfoResponse message. */
          application_version?: {
            name?: string;
            app_name?: string;
            version?: string;
            git_commit?: string;
            build_tags?: string;
            go_version?: string;
            build_deps?: {
              /** module path */
              path?: string;
              /** module version */
              version?: string;
              /** checksum */
              sum?: string;
            }[];
            /** Since: cosmos-sdk 0.43 */
            cosmos_sdk_version?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/node_info`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetSyncing
     * @summary GetSyncing queries node syncing.
     * @request GET:/cosmos/base/tendermint/v1beta1/syncing
     */
    getSyncing: (params: RequestParams = {}) =>
      this.request<
        {
          syncing?: boolean;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/syncing`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetLatestValidatorSet
     * @summary GetLatestValidatorSet queries latest validator-set.
     * @request GET:/cosmos/base/tendermint/v1beta1/validatorsets/latest
     */
    getLatestValidatorSet: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** @format int64 */
          block_height?: string;
          validators?: {
            address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            pub_key?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/validatorsets/latest`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetValidatorSetByHeight
     * @summary GetValidatorSetByHeight queries validator-set at a given height.
     * @request GET:/cosmos/base/tendermint/v1beta1/validatorsets/{height}
     */
    getValidatorSetByHeight: (
      height: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** @format int64 */
          block_height?: string;
          validators?: {
            address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            pub_key?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** @format int64 */
            voting_power?: string;
            /** @format int64 */
            proposer_priority?: string;
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/tendermint/v1beta1/validatorsets/${height}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name Config
     * @summary Config queries for the operator configuration.
     * @request GET:/cosmos/base/node/v1beta1/config
     */
    config: (params: RequestParams = {}) =>
      this.request<
        {
          minimum_gas_price?: string;
          pruning_keep_recent?: string;
          pruning_interval?: string;
          /** @format uint64 */
          halt_height?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/node/v1beta1/config`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name Status
     * @summary Status queries for the node status.
     * @request GET:/cosmos/base/node/v1beta1/status
     */
    status: (params: RequestParams = {}) =>
      this.request<
        {
          /** @format uint64 */
          earliest_store_height?: string;
          /** @format uint64 */
          height?: string;
          /** @format date-time */
          timestamp?: string;
          /** @format byte */
          app_hash?: string;
          /** @format byte */
          validator_hash?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/base/node/v1beta1/status`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ConsensusParams
     * @summary Params queries the parameters of x/consensus module.
     * @request GET:/cosmos/consensus/v1/params
     */
    consensusParams: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * params are the tendermint consensus params stored in the consensus module.
           * Please note that `params.version` is not populated in this response, it is
           * tracked separately in the x/upgrade module.
           */
          params?: {
            /** BlockParams contains limits on the block size. */
            block?: {
              /**
               * Max block size, in bytes.
               * Note: must be greater than 0
               * @format int64
               */
              max_bytes?: string;
              /**
               * Max gas per block.
               * Note: must be greater or equal to -1
               * @format int64
               */
              max_gas?: string;
            };
            /** EvidenceParams determine how we handle evidence of malfeasance. */
            evidence?: {
              /**
               * Max age of evidence, in blocks.
               *
               * The basic formula for calculating this is: MaxAgeDuration / {average block
               * time}.
               * @format int64
               */
              max_age_num_blocks?: string;
              /**
               * Max age of evidence, in time.
               *
               * It should correspond with an app's "unbonding period" or other similar
               * mechanism for handling [Nothing-At-Stake
               * attacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed).
               */
              max_age_duration?: string;
              /**
               * This sets the maximum size of total evidence in bytes that can be committed in a single block.
               * and should fall comfortably under the max block bytes.
               * Default is 1048576 or 1MB
               * @format int64
               */
              max_bytes?: string;
            };
            /**
             * ValidatorParams restrict the public key types validators can use.
             * NOTE: uses ABCI pubkey naming, not Amino names.
             */
            validator?: {
              pub_key_types?: string[];
            };
            /** VersionParams contains the ABCI application version. */
            version?: {
              /** @format uint64 */
              app?: string;
            };
            /** ABCIParams configure functionality specific to the Application Blockchain Interface. */
            abci?: {
              /**
               * vote_extensions_enable_height configures the first height during which
               * vote extensions will be enabled. During this specified height, and for all
               * subsequent heights, precommit messages that do not contain valid extension data
               * will be considered invalid. Prior to this height, vote extensions will not
               * be used or accepted by validators on the network.
               *
               * Once enabled, vote extensions will be created by the application in ExtendVote,
               * passed to the application for validation in VerifyVoteExtension and given
               * to the application to use when proposing a block during PrepareProposal.
               * @format int64
               */
              vote_extensions_enable_height?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/consensus/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Allowance
     * @summary Allowance returns granted allwance to the grantee by the granter.
     * @request GET:/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}
     */
    allowance: (granter: string, grantee: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Grant is stored in the KVStore to record a grant with full context
           * allowance is a allowance granted for grantee by granter.
           */
          allowance?: {
            /** granter is the address of the user granting an allowance of their funds. */
            granter?: string;
            /** grantee is the address of the user being granted an allowance of another user's funds. */
            grantee?: string;
            /** allowance can be any of basic, periodic, allowed fee allowance. */
            allowance?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/feegrant/v1beta1/allowance/${granter}/${grantee}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Allowances
     * @summary Allowances returns all the grants for the given grantee address.
     * @request GET:/cosmos/feegrant/v1beta1/allowances/{grantee}
     */
    allowances: (
      grantee: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** allowances are allowance's granted for grantee by granter. */
          allowances?: {
            /** granter is the address of the user granting an allowance of their funds. */
            granter?: string;
            /** grantee is the address of the user being granted an allowance of another user's funds. */
            grantee?: string;
            /** allowance can be any of basic, periodic, allowed fee allowance. */
            allowance?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/feegrant/v1beta1/allowances/${grantee}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name AllowancesByGranter
     * @summary AllowancesByGranter returns all the grants given by an address
     * @request GET:/cosmos/feegrant/v1beta1/issued/{granter}
     */
    allowancesByGranter: (
      granter: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** allowances that have been issued by the granter. */
          allowances?: {
            /** granter is the address of the user granting an allowance of their funds. */
            granter?: string;
            /** grantee is the address of the user being granted an allowance of another user's funds. */
            grantee?: string;
            /** allowance can be any of basic, periodic, allowed fee allowance. */
            allowance?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          }[];
          /** pagination defines an pagination for the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/feegrant/v1beta1/issued/${granter}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Erc20Params
     * @summary Params retrieves the erc20 module params
     * @request GET:/cosmos/evm/erc20/v1/params
     */
    erc20Params: (params: RequestParams = {}) =>
      this.request<
        {
          /** params are the erc20 module parameters */
          params?: {
            /**
             * enable_erc20 is the parameter to enable the conversion of Cosmos coins <-->
             * ERC20 tokens.
             */
            enable_erc20?: boolean;
            /**
             * native_precompiles defines the slice of hex addresses of the
             * active precompiles that are used to interact with native staking coins as
             * ERC20s
             */
            native_precompiles?: string[];
            /**
             * dynamic_precompiles defines the slice of hex addresses of the
             * active precompiles that are used to interact with Bank coins as ERC20s
             */
            dynamic_precompiles?: string[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/erc20/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TokenPairs
     * @summary TokenPairs retrieves registered token pairs
     * @request GET:/cosmos/evm/erc20/v1/token_pairs
     */
    tokenPairs: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** token_pairs is a slice of registered token pairs for the erc20 module */
          token_pairs?: {
            /** erc20_address is the hex address of ERC20 contract token */
            erc20_address?: string;
            /** denom defines the cosmos base denomination to be mapped to */
            denom?: string;
            /** enabled defines the token mapping enable status */
            enabled?: boolean;
            /**
             * contract_owner is the an ENUM specifying the type of ERC20 owner (0
             * invalid, 1 ModuleAccount, 2 external address)
             * Owner enumerates the ownership of a ERC20 contract.
             *
             *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
             *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
             *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
             * @default "OWNER_UNSPECIFIED"
             */
            contract_owner?:
              | "OWNER_UNSPECIFIED"
              | "OWNER_MODULE"
              | "OWNER_EXTERNAL";
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/erc20/v1/token_pairs`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TokenPair
     * @summary TokenPair retrieves a registered token pair
     * @request GET:/cosmos/evm/erc20/v1/token_pairs/{token}
     */
    tokenPair: (token: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * token_pairs returns the info about a registered token pair for the erc20
           * module
           * TokenPair defines an instance that records a pairing consisting of a native
           * Cosmos Coin and an ERC20 token address.
           */
          token_pair?: {
            /** erc20_address is the hex address of ERC20 contract token */
            erc20_address?: string;
            /** denom defines the cosmos base denomination to be mapped to */
            denom?: string;
            /** enabled defines the token mapping enable status */
            enabled?: boolean;
            /**
             * contract_owner is the an ENUM specifying the type of ERC20 owner (0
             * invalid, 1 ModuleAccount, 2 external address)
             * Owner enumerates the ownership of a ERC20 contract.
             *
             *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
             *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
             *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
             * @default "OWNER_UNSPECIFIED"
             */
            contract_owner?:
              | "OWNER_UNSPECIFIED"
              | "OWNER_MODULE"
              | "OWNER_EXTERNAL";
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/erc20/v1/token_pairs/${token}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VmAccount
     * @summary Account queries an Ethereum account.
     * @request GET:/cosmos/evm/vm/v1/account/{address}
     */
    vmAccount: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /** balance is the balance of the EVM denomination. */
          balance?: string;
          /** code_hash is the hex-formatted code bytes from the EOA. */
          code_hash?: string;
          /**
           * nonce is the account's sequence number.
           * @format uint64
           */
          nonce?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/account/${address}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name VmBalance
 * @summary Balance queries the balance of a the EVM denomination for a single
account.
 * @request GET:/cosmos/evm/vm/v1/balances/{address}
 */
    vmBalance: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /** balance is the balance of the EVM denomination. */
          balance?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/balances/${address}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name VmBaseFee
 * @summary BaseFee queries the base fee of the parent block of the current block,
it's similar to feemarket module's method, but also checks london hardfork
status.
 * @request GET:/cosmos/evm/vm/v1/base_fee
 */
    vmBaseFee: (params: RequestParams = {}) =>
      this.request<
        {
          /** base_fee is the EIP1559 base fee */
          base_fee?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/base_fee`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VmCode
     * @summary Code queries the balance of all coins for a single account.
     * @request GET:/cosmos/evm/vm/v1/codes/{address}
     */
    vmCode: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * code represents the code bytes from an ethereum address.
           * @format byte
           */
          code?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/codes/${address}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VmConfig
     * @summary Config queries the EVM configuration
     * @request GET:/cosmos/evm/vm/v1/config
     */
    vmConfig: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * config is the evm configuration
           * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
           * instead of *big.Int.
           */
          config?: {
            /** homestead_block switch (nil no fork, 0 = already homestead) */
            homestead_block?: string;
            /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
            dao_fork_block?: string;
            /**
             * dao_fork_support defines whether the nodes supports or opposes the DAO
             * hard-fork
             */
            dao_fork_support?: boolean;
            /**
             * eip150_block: EIP150 implements the Gas price changes
             * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
             */
            eip150_block?: string;
            /**
             * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
             * pricing changed)
             */
            eip150_hash?: string;
            /** eip155_block: EIP155Block HF block */
            eip155_block?: string;
            /** eip158_block: EIP158 HF block */
            eip158_block?: string;
            /**
             * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
             * byzantium)
             */
            byzantium_block?: string;
            /**
             * constantinople_block: Constantinople switch block (nil no fork, 0 = already
             * activated)
             */
            constantinople_block?: string;
            /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
            petersburg_block?: string;
            /**
             * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
             * istanbul)
             */
            istanbul_block?: string;
            /**
             * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
             * already activated)
             */
            muir_glacier_block?: string;
            /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
            berlin_block?: string;
            /** london_block: London switch block (nil = no fork, 0 = already on london) */
            london_block?: string;
            /**
             * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
             * already activated)
             */
            arrow_glacier_block?: string;
            /**
             * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
             * already activated)
             */
            gray_glacier_block?: string;
            /**
             * merge_netsplit_block: Virtual fork after The Merge to use as a network
             * splitter
             */
            merge_netsplit_block?: string;
            /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
            shanghai_block?: string;
            /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
            cancun_block?: string;
            /**
             * chain_id is the id of the chain (EIP-155)
             * @format uint64
             */
            chain_id?: string;
            /** denom is the denomination used on the EVM */
            denom?: string;
            /**
             * decimals is the real decimal precision of the denomination used on the EVM
             * @format uint64
             */
            decimals?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/config`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name CosmosAccount
     * @summary CosmosAccount queries an Ethereum account's Cosmos Address.
     * @request GET:/cosmos/evm/vm/v1/cosmos_account/{address}
     */
    cosmosAccount: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /** cosmos_address is the cosmos address of the account. */
          cosmos_address?: string;
          /**
           * sequence is the account's sequence number.
           * @format uint64
           */
          sequence?: string;
          /**
           * account_number is the account number
           * @format uint64
           */
          account_number?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/cosmos_account/${address}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name EstimateGas
     * @summary EstimateGas implements the `eth_estimateGas` rpc api
     * @request GET:/cosmos/evm/vm/v1/estimate_gas
     */
    estimateGas: (
      query?: {
        /**
         * args uses the same json format as the json rpc api.
         * @format byte
         */
        args?: string;
        /**
         * gas_cap defines the default gas cap to be used.
         * @format uint64
         */
        gas_cap?: string;
        /**
         * proposer_address of the requested block in hex format.
         * @format byte
         */
        proposer_address?: string;
        /**
         * chain_id is the eip155 chain id parsed from the requested block header.
         * @format int64
         */
        chain_id?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * gas returns the estimated gas
           * @format uint64
           */
          gas?: string;
          /**
           * ret is the returned data from evm function (result or data supplied with
           * revert opcode)
           * @format byte
           */
          ret?: string;
          /** vm_error is the error returned by vm execution */
          vm_error?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/estimate_gas`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name EthCall
     * @summary EthCall implements the `eth_call` rpc api
     * @request GET:/cosmos/evm/vm/v1/eth_call
     */
    ethCall: (
      query?: {
        /**
         * args uses the same json format as the json rpc api.
         * @format byte
         */
        args?: string;
        /**
         * gas_cap defines the default gas cap to be used.
         * @format uint64
         */
        gas_cap?: string;
        /**
         * proposer_address of the requested block in hex format.
         * @format byte
         */
        proposer_address?: string;
        /**
         * chain_id is the eip155 chain id parsed from the requested block header.
         * @format int64
         */
        chain_id?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * hash of the ethereum transaction in hex format. This hash differs from the
           * Tendermint sha256 hash of the transaction bytes. See
           * https://github.com/tendermint/tendermint/issues/6539 for reference
           */
          hash?: string;
          /**
           * logs contains the transaction hash and the proto-compatible ethereum
           * logs.
           */
          logs?: {
            /** address of the contract that generated the event */
            address?: string;
            /** topics is a list of topics provided by the contract. */
            topics?: string[];
            /**
             * data which is supplied by the contract, usually ABI-encoded
             * @format byte
             */
            data?: string;
            /**
             * block_number of the block in which the transaction was included
             * @format uint64
             */
            block_number?: string;
            /** tx_hash is the transaction hash */
            tx_hash?: string;
            /**
             * tx_index of the transaction in the block
             * @format uint64
             */
            tx_index?: string;
            /** block_hash of the block in which the transaction was included */
            block_hash?: string;
            /**
             * index of the log in the block
             * @format uint64
             */
            index?: string;
            /**
             * removed is true if this log was reverted due to a chain
             * reorganisation. You must pay attention to this field if you receive logs
             * through a filter query.
             */
            removed?: boolean;
          }[];
          /**
           * ret is the returned data from evm function (result or data supplied with
           * revert opcode)
           * @format byte
           */
          ret?: string;
          /** vm_error is the error returned by vm execution */
          vm_error?: string;
          /**
           * gas_used specifies how much gas was consumed by the transaction
           * @format uint64
           */
          gas_used?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/eth_call`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name GlobalMinGasPrice
 * @summary GlobalMinGasPrice queries the MinGasPrice
it's similar to feemarket module's method,
but makes the conversion to 18 decimals
when the evm denom is represented with a different precision.
 * @request GET:/cosmos/evm/vm/v1/min_gas_price
 */
    globalMinGasPrice: (params: RequestParams = {}) =>
      this.request<
        {
          /** min_gas_price is the feemarket's min_gas_price */
          min_gas_price?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/min_gas_price`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VmParams
     * @summary Params queries the parameters of x/vm module.
     * @request GET:/cosmos/evm/vm/v1/params
     */
    vmParams: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Params defines the EVM module parameters
           * params define the evm module parameters.
           */
          params?: {
            /**
             * evm_denom represents the token denomination used to run the EVM state
             * transitions.
             */
            evm_denom?: string;
            /** extra_eips defines the additional EIPs for the vm.Config */
            extra_eips?: string[];
            /**
             * chain_config defines the EVM chain configuration parameters
             * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
             * instead of *big.Int.
             */
            chain_config?: {
              /** homestead_block switch (nil no fork, 0 = already homestead) */
              homestead_block?: string;
              /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
              dao_fork_block?: string;
              /**
               * dao_fork_support defines whether the nodes supports or opposes the DAO
               * hard-fork
               */
              dao_fork_support?: boolean;
              /**
               * eip150_block: EIP150 implements the Gas price changes
               * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
               */
              eip150_block?: string;
              /**
               * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
               * pricing changed)
               */
              eip150_hash?: string;
              /** eip155_block: EIP155Block HF block */
              eip155_block?: string;
              /** eip158_block: EIP158 HF block */
              eip158_block?: string;
              /**
               * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
               * byzantium)
               */
              byzantium_block?: string;
              /**
               * constantinople_block: Constantinople switch block (nil no fork, 0 = already
               * activated)
               */
              constantinople_block?: string;
              /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
              petersburg_block?: string;
              /**
               * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
               * istanbul)
               */
              istanbul_block?: string;
              /**
               * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
               * already activated)
               */
              muir_glacier_block?: string;
              /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
              berlin_block?: string;
              /** london_block: London switch block (nil = no fork, 0 = already on london) */
              london_block?: string;
              /**
               * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
               * already activated)
               */
              arrow_glacier_block?: string;
              /**
               * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
               * already activated)
               */
              gray_glacier_block?: string;
              /**
               * merge_netsplit_block: Virtual fork after The Merge to use as a network
               * splitter
               */
              merge_netsplit_block?: string;
              /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
              shanghai_block?: string;
              /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
              cancun_block?: string;
              /**
               * chain_id is the id of the chain (EIP-155)
               * @format uint64
               */
              chain_id?: string;
              /** denom is the denomination used on the EVM */
              denom?: string;
              /**
               * decimals is the real decimal precision of the denomination used on the EVM
               * @format uint64
               */
              decimals?: string;
            };
            /**
             * allow_unprotected_txs defines if replay-protected (i.e non EIP155
             * signed) transactions can be executed on the state machine.
             */
            allow_unprotected_txs?: boolean;
            /** evm_channels is the list of channel identifiers from EVM compatible chains */
            evm_channels?: string[];
            /** access_control defines the permission policy of the EVM */
            access_control?: {
              /** create defines the permission policy for creating contracts */
              create?: {
                /**
                 * access_type defines which type of permission is required for the operation
                 * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
                 *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
                 *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
                 * @default "ACCESS_TYPE_PERMISSIONLESS"
                 */
                access_type?:
                  | "ACCESS_TYPE_PERMISSIONLESS"
                  | "ACCESS_TYPE_RESTRICTED"
                  | "ACCESS_TYPE_PERMISSIONED";
                /**
                 * access_control_list defines defines different things depending on the
                 * AccessType:
                 * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
                 * performing the operation
                 * - ACCESS_TYPE_RESTRICTED: ignored
                 * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
                 * the operation
                 */
                access_control_list?: string[];
              };
              /** call defines the permission policy for calling contracts */
              call?: {
                /**
                 * access_type defines which type of permission is required for the operation
                 * - ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone
                 *  - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone
                 *  - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses
                 * @default "ACCESS_TYPE_PERMISSIONLESS"
                 */
                access_type?:
                  | "ACCESS_TYPE_PERMISSIONLESS"
                  | "ACCESS_TYPE_RESTRICTED"
                  | "ACCESS_TYPE_PERMISSIONED";
                /**
                 * access_control_list defines defines different things depending on the
                 * AccessType:
                 * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from
                 * performing the operation
                 * - ACCESS_TYPE_RESTRICTED: ignored
                 * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform
                 * the operation
                 */
                access_control_list?: string[];
              };
            };
            /**
             * active_static_precompiles defines the slice of hex addresses of the
             * precompiled contracts that are active
             */
            active_static_precompiles?: string[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Storage
     * @summary Storage queries the balance of all coins for a single account.
     * @request GET:/cosmos/evm/vm/v1/storage/{address}/{key}
     */
    storage: (address: string, key: string, params: RequestParams = {}) =>
      this.request<
        {
          /** value defines the storage state value hash associated with the given key. */
          value?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/storage/${address}/${key}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name TraceBlock
 * @summary TraceBlock implements the `debug_traceBlockByNumber` and
`debug_traceBlockByHash` rpc api
 * @request GET:/cosmos/evm/vm/v1/trace_block
 */
    traceBlock: (
      query?: {
        /** tracer is a custom javascript tracer. */
        "trace_config.tracer"?: string;
        /**
         * timeout overrides the default timeout of 5 seconds for JavaScript-based
         * tracing calls.
         */
        "trace_config.timeout"?: string;
        /**
         * reexec defines the number of blocks the tracer is willing to go back.
         * @format uint64
         */
        "trace_config.reexec"?: string;
        /** disable_stack switches stack capture. */
        "trace_config.disable_stack"?: boolean;
        /** disable_storage switches storage capture. */
        "trace_config.disable_storage"?: boolean;
        /** debug can be used to print output during capture end. */
        "trace_config.debug"?: boolean;
        /**
         * limit defines the maximum length of output, but zero means unlimited.
         * @format int32
         */
        "trace_config.limit"?: number;
        /** homestead_block switch (nil no fork, 0 = already homestead). */
        "trace_config.overrides.homestead_block"?: string;
        /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork). */
        "trace_config.overrides.dao_fork_block"?: string;
        /**
         * dao_fork_support defines whether the nodes supports or opposes the DAO
         * hard-fork.
         */
        "trace_config.overrides.dao_fork_support"?: boolean;
        /**
         * eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).
         */
        "trace_config.overrides.eip150_block"?: string;
        /**
         * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
         * pricing changed).
         */
        "trace_config.overrides.eip150_hash"?: string;
        /** eip155_block: EIP155Block HF block. */
        "trace_config.overrides.eip155_block"?: string;
        /** eip158_block: EIP158 HF block. */
        "trace_config.overrides.eip158_block"?: string;
        /**
         * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
         * byzantium).
         */
        "trace_config.overrides.byzantium_block"?: string;
        /**
         * constantinople_block: Constantinople switch block (nil no fork, 0 = already
         * activated).
         */
        "trace_config.overrides.constantinople_block"?: string;
        /** petersburg_block: Petersburg switch block (nil same as Constantinople). */
        "trace_config.overrides.petersburg_block"?: string;
        /**
         * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
         * istanbul).
         */
        "trace_config.overrides.istanbul_block"?: string;
        /**
         * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
         * already activated).
         */
        "trace_config.overrides.muir_glacier_block"?: string;
        /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin). */
        "trace_config.overrides.berlin_block"?: string;
        /** london_block: London switch block (nil = no fork, 0 = already on london). */
        "trace_config.overrides.london_block"?: string;
        /**
         * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
         * already activated).
         */
        "trace_config.overrides.arrow_glacier_block"?: string;
        /**
         * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
         * already activated).
         */
        "trace_config.overrides.gray_glacier_block"?: string;
        /**
         * merge_netsplit_block: Virtual fork after The Merge to use as a network
         * splitter.
         */
        "trace_config.overrides.merge_netsplit_block"?: string;
        /** shanghai_block switch block (nil = no fork, 0 = already on shanghai). */
        "trace_config.overrides.shanghai_block"?: string;
        /** cancun_block switch block (nil = no fork, 0 = already on cancun). */
        "trace_config.overrides.cancun_block"?: string;
        /**
         * chain_id is the id of the chain (EIP-155).
         * @format uint64
         */
        "trace_config.overrides.chain_id"?: string;
        /** denom is the denomination used on the EVM. */
        "trace_config.overrides.denom"?: string;
        /**
         * decimals is the real decimal precision of the denomination used on the EVM.
         * @format uint64
         */
        "trace_config.overrides.decimals"?: string;
        /** enable_memory switches memory capture. */
        "trace_config.enable_memory"?: boolean;
        /** enable_return_data switches the capture of return data. */
        "trace_config.enable_return_data"?: boolean;
        /** tracer_json_config configures the tracer using a JSON string. */
        "trace_config.tracer_json_config"?: string;
        /**
         * block_number of the traced block.
         * @format int64
         */
        block_number?: string;
        /** block_hash (hex) of the traced block. */
        block_hash?: string;
        /**
         * block_time of the traced block.
         * @format date-time
         */
        block_time?: string;
        /**
         * proposer_address is the address of the requested block.
         * @format byte
         */
        proposer_address?: string;
        /**
         * chain_id is the eip155 chain id parsed from the requested block header.
         * @format int64
         */
        chain_id?: string;
        /**
         * block_max_gas of the traced block.
         * @format int64
         */
        block_max_gas?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * data is the response serialized in bytes
           * @format byte
           */
          data?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/trace_block`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TraceTx
     * @summary TraceTx implements the `debug_traceTransaction` rpc api
     * @request GET:/cosmos/evm/vm/v1/trace_tx
     */
    traceTx: (
      query?: {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        "msg.data.type_url"?: string;
        /**
         * Must be a valid serialized protocol buffer of the above specified type.
         * @format byte
         */
        "msg.data.value"?: string;
        /**
         * size is the encoded storage size of the transaction (DEPRECATED).
         * @format double
         */
        "msg.size"?: number;
        /** hash of the transaction in hex format. */
        "msg.hash"?: string;
        /**
         * from is the ethereum signer address in hex format. This address value is
         * checked against the address derived from the signature (V, R, S) using the
         * secp256k1 elliptic curve.
         */
        "msg.from"?: string;
        /** tracer is a custom javascript tracer. */
        "trace_config.tracer"?: string;
        /**
         * timeout overrides the default timeout of 5 seconds for JavaScript-based
         * tracing calls.
         */
        "trace_config.timeout"?: string;
        /**
         * reexec defines the number of blocks the tracer is willing to go back.
         * @format uint64
         */
        "trace_config.reexec"?: string;
        /** disable_stack switches stack capture. */
        "trace_config.disable_stack"?: boolean;
        /** disable_storage switches storage capture. */
        "trace_config.disable_storage"?: boolean;
        /** debug can be used to print output during capture end. */
        "trace_config.debug"?: boolean;
        /**
         * limit defines the maximum length of output, but zero means unlimited.
         * @format int32
         */
        "trace_config.limit"?: number;
        /** homestead_block switch (nil no fork, 0 = already homestead). */
        "trace_config.overrides.homestead_block"?: string;
        /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork). */
        "trace_config.overrides.dao_fork_block"?: string;
        /**
         * dao_fork_support defines whether the nodes supports or opposes the DAO
         * hard-fork.
         */
        "trace_config.overrides.dao_fork_support"?: boolean;
        /**
         * eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).
         */
        "trace_config.overrides.eip150_block"?: string;
        /**
         * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
         * pricing changed).
         */
        "trace_config.overrides.eip150_hash"?: string;
        /** eip155_block: EIP155Block HF block. */
        "trace_config.overrides.eip155_block"?: string;
        /** eip158_block: EIP158 HF block. */
        "trace_config.overrides.eip158_block"?: string;
        /**
         * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
         * byzantium).
         */
        "trace_config.overrides.byzantium_block"?: string;
        /**
         * constantinople_block: Constantinople switch block (nil no fork, 0 = already
         * activated).
         */
        "trace_config.overrides.constantinople_block"?: string;
        /** petersburg_block: Petersburg switch block (nil same as Constantinople). */
        "trace_config.overrides.petersburg_block"?: string;
        /**
         * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
         * istanbul).
         */
        "trace_config.overrides.istanbul_block"?: string;
        /**
         * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
         * already activated).
         */
        "trace_config.overrides.muir_glacier_block"?: string;
        /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin). */
        "trace_config.overrides.berlin_block"?: string;
        /** london_block: London switch block (nil = no fork, 0 = already on london). */
        "trace_config.overrides.london_block"?: string;
        /**
         * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
         * already activated).
         */
        "trace_config.overrides.arrow_glacier_block"?: string;
        /**
         * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
         * already activated).
         */
        "trace_config.overrides.gray_glacier_block"?: string;
        /**
         * merge_netsplit_block: Virtual fork after The Merge to use as a network
         * splitter.
         */
        "trace_config.overrides.merge_netsplit_block"?: string;
        /** shanghai_block switch block (nil = no fork, 0 = already on shanghai). */
        "trace_config.overrides.shanghai_block"?: string;
        /** cancun_block switch block (nil = no fork, 0 = already on cancun). */
        "trace_config.overrides.cancun_block"?: string;
        /**
         * chain_id is the id of the chain (EIP-155).
         * @format uint64
         */
        "trace_config.overrides.chain_id"?: string;
        /** denom is the denomination used on the EVM. */
        "trace_config.overrides.denom"?: string;
        /**
         * decimals is the real decimal precision of the denomination used on the EVM.
         * @format uint64
         */
        "trace_config.overrides.decimals"?: string;
        /** enable_memory switches memory capture. */
        "trace_config.enable_memory"?: boolean;
        /** enable_return_data switches the capture of return data. */
        "trace_config.enable_return_data"?: boolean;
        /** tracer_json_config configures the tracer using a JSON string. */
        "trace_config.tracer_json_config"?: string;
        /**
         * block_number of requested transaction.
         * @format int64
         */
        block_number?: string;
        /** block_hash of requested transaction. */
        block_hash?: string;
        /**
         * block_time of requested transaction.
         * @format date-time
         */
        block_time?: string;
        /**
         * proposer_address is the proposer of the requested block.
         * @format byte
         */
        proposer_address?: string;
        /**
         * chain_id is the eip155 chain id parsed from the requested block header.
         * @format int64
         */
        chain_id?: string;
        /**
         * block_max_gas of the block of the requested transaction.
         * @format int64
         */
        block_max_gas?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * data is the response serialized in bytes
           * @format byte
           */
          data?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/trace_tx`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ValidatorAccount
 * @summary ValidatorAccount queries an Ethereum account's from a validator consensus
Address.
 * @request GET:/cosmos/evm/vm/v1/validator_account/{cons_address}
 */
    validatorAccount: (consAddress: string, params: RequestParams = {}) =>
      this.request<
        {
          /** account_address is the cosmos address of the account in bech32 format. */
          account_address?: string;
          /**
           * sequence is the account's sequence number.
           * @format uint64
           */
          sequence?: string;
          /**
           * account_number is the account number
           * @format uint64
           */
          account_number?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/vm/v1/validator_account/${consAddress}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name BaseFee
     * @summary BaseFee queries the base fee of the parent block of the current block.
     * @request GET:/cosmos/evm/feemarket/v1/base_fee
     */
    baseFee: (params: RequestParams = {}) =>
      this.request<
        {
          /** base_fee is the EIP1559 base fee */
          base_fee?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/feemarket/v1/base_fee`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name BlockGas
     * @summary BlockGas queries the gas used at a given block height
     * @request GET:/cosmos/evm/feemarket/v1/block_gas
     */
    blockGas: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * gas is the returned block gas
           * @format int64
           */
          gas?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/feemarket/v1/block_gas`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name FeemarketParams
     * @summary Params queries the parameters of x/feemarket module.
     * @request GET:/cosmos/evm/feemarket/v1/params
     */
    feemarketParams: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Params defines the EVM module parameters
           * params define the evm module parameters.
           */
          params?: {
            /** no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
            no_base_fee?: boolean;
            /**
             * base_fee_change_denominator bounds the amount the base fee can change
             * between blocks.
             * @format int64
             */
            base_fee_change_denominator?: number;
            /**
             * elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may
             * have.
             * @format int64
             */
            elasticity_multiplier?: number;
            /**
             * enable_height defines at which block height the base fee calculation is
             * enabled.
             * @format int64
             */
            enable_height?: string;
            /** base_fee for EIP-1559 blocks. */
            base_fee?: string;
            /**
             * min_gas_price defines the minimum gas price value for cosmos and eth
             * transactions
             */
            min_gas_price?: string;
            /**
             * min_gas_multiplier bounds the minimum gas used to be charged
             * to senders based on gas limit
             */
            min_gas_multiplier?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evm/feemarket/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.47
     *
     * @tags Query
     * @name AccountInfo
     * @summary AccountInfo queries account info which is common to all account types.
     * @request GET:/cosmos/auth/v1beta1/account_info/{address}
     */
    accountInfo: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /** info is the account info which is represented by BaseAccount. */
          info?: {
            address?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            pub_key?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /** @format uint64 */
            account_number?: string;
            /** @format uint64 */
            sequence?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/account_info/${address}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description When called from another module, this query might consume a high amount of gas if the pagination field is incorrectly set. Since: cosmos-sdk 0.43
     *
     * @tags Query
     * @name Accounts
     * @summary Accounts returns all the existing accounts.
     * @request GET:/cosmos/auth/v1beta1/accounts
     */
    accounts: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** accounts are the existing accounts */
          accounts?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/accounts`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Account
     * @summary Account returns account details based on address.
     * @request GET:/cosmos/auth/v1beta1/accounts/{address}
     */
    account: (address: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          account?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/accounts/${address}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46.2
     *
     * @tags Query
     * @name AccountAddressById
     * @summary AccountAddressByID returns account address based on account number.
     * @request GET:/cosmos/auth/v1beta1/address_by_id/{id}
     */
    accountAddressById: (
      id: string,
      query?: {
        /**
         * account_id is the account number of the address to be queried.
         *
         * Since: cosmos-sdk 0.47
         * @format uint64
         */
        account_id?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          account_address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/address_by_id/${id}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name Bech32Prefix
     * @summary Bech32Prefix queries bech32Prefix
     * @request GET:/cosmos/auth/v1beta1/bech32
     */
    bech32Prefix: (params: RequestParams = {}) =>
      this.request<
        {
          bech32_prefix?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/bech32`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name AddressBytesToString
     * @summary AddressBytesToString converts Account Address bytes to string
     * @request GET:/cosmos/auth/v1beta1/bech32/{address_bytes}
     */
    addressBytesToString: (addressBytes: string, params: RequestParams = {}) =>
      this.request<
        {
          address_string?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/bech32/${addressBytes}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name AddressStringToBytes
     * @summary AddressStringToBytes converts Address string to bytes
     * @request GET:/cosmos/auth/v1beta1/bech32/{address_string}
     */
    addressStringToBytes: (addressString: string, params: RequestParams = {}) =>
      this.request<
        {
          /** @format byte */
          address_bytes?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/bech32/${addressString}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.46
     *
     * @tags Query
     * @name ModuleAccounts
     * @summary ModuleAccounts returns all the existing module accounts.
     * @request GET:/cosmos/auth/v1beta1/module_accounts
     */
    moduleAccounts: (params: RequestParams = {}) =>
      this.request<
        {
          accounts?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/module_accounts`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ModuleAccountByName
     * @summary ModuleAccountByName returns the module account info by module name
     * @request GET:/cosmos/auth/v1beta1/module_accounts/{name}
     */
    moduleAccountByName: (name: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          account?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/module_accounts/${name}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name AuthParams
     * @summary Params queries all parameters.
     * @request GET:/cosmos/auth/v1beta1/params
     */
    authParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /** @format uint64 */
            max_memo_characters?: string;
            /** @format uint64 */
            tx_sig_limit?: string;
            /** @format uint64 */
            tx_size_cost_per_byte?: string;
            /** @format uint64 */
            sig_verify_cost_ed25519?: string;
            /** @format uint64 */
            sig_verify_cost_secp256k1?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/auth/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name CommunityPool
     * @summary CommunityPool queries the community pool coins.
     * @request GET:/cosmos/distribution/v1beta1/community_pool
     */
    communityPool: (params: RequestParams = {}) =>
      this.request<
        {
          /** pool defines community pool's coins. */
          pool?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/community_pool`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name DelegationTotalRewards
 * @summary DelegationTotalRewards queries the total rewards accrued by each
validator.
 * @request GET:/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards
 */
    delegationTotalRewards: (
      delegatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** rewards defines all the rewards accrued by a delegator. */
          rewards?: {
            validator_address?: string;
            reward?: {
              denom?: string;
              amount?: string;
            }[];
          }[];
          /** total defines the sum of all the rewards. */
          total?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/delegators/${delegatorAddress}/rewards`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DelegationRewards
     * @summary DelegationRewards queries the total rewards accrued by a delegation.
     * @request GET:/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}
     */
    delegationRewards: (
      delegatorAddress: string,
      validatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** rewards defines the rewards accrued by a delegation. */
          rewards?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/delegators/${delegatorAddress}/rewards/${validatorAddress}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DistributionDelegatorValidators
     * @summary DelegatorValidators queries the validators of a delegator.
     * @request GET:/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators
     */
    distributionDelegatorValidators: (
      delegatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** validators defines the validators a delegator is delegating for. */
          validators?: string[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/delegators/${delegatorAddress}/validators`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DelegatorWithdrawAddress
     * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
     * @request GET:/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address
     */
    delegatorWithdrawAddress: (
      delegatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** withdraw_address defines the delegator address to query for. */
          withdraw_address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/delegators/${delegatorAddress}/withdraw_address`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DistributionParams
     * @summary Params queries params of the distribution module.
     * @request GET:/cosmos/distribution/v1beta1/params
     */
    distributionParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            community_tax?: string;
            /**
             * Deprecated: The base_proposer_reward field is deprecated and is no longer used
             * in the x/distribution module's reward mechanism.
             */
            base_proposer_reward?: string;
            /**
             * Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
             * in the x/distribution module's reward mechanism.
             */
            bonus_proposer_reward?: string;
            withdraw_addr_enabled?: boolean;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ValidatorDistributionInfo
     * @summary ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator
     * @request GET:/cosmos/distribution/v1beta1/validators/{validator_address}
     */
    validatorDistributionInfo: (
      validatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** operator_address defines the validator operator address. */
          operator_address?: string;
          /** self_bond_rewards defines the self delegations rewards. */
          self_bond_rewards?: {
            denom?: string;
            amount?: string;
          }[];
          /** commission defines the commission the validator received. */
          commission?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/validators/${validatorAddress}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ValidatorCommission
     * @summary ValidatorCommission queries accumulated commission for a validator.
     * @request GET:/cosmos/distribution/v1beta1/validators/{validator_address}/commission
     */
    validatorCommission: (
      validatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** commission defines the commission the validator received. */
          commission?: {
            commission?: {
              denom?: string;
              amount?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/validators/${validatorAddress}/commission`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ValidatorOutstandingRewards
     * @summary ValidatorOutstandingRewards queries rewards of a validator address.
     * @request GET:/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards
     */
    validatorOutstandingRewards: (
      validatorAddress: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
           * for a validator inexpensive to track, allows simple sanity checks.
           */
          rewards?: {
            rewards?: {
              denom?: string;
              amount?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/validators/${validatorAddress}/outstanding_rewards`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ValidatorSlashes
     * @summary ValidatorSlashes queries slash events of a validator.
     * @request GET:/cosmos/distribution/v1beta1/validators/{validator_address}/slashes
     */
    validatorSlashes: (
      validatorAddress: string,
      query?: {
        /**
         * starting_height defines the optional starting height to query the slashes.
         * @format uint64
         */
        starting_height?: string;
        /**
         * starting_height defines the optional ending height to query the slashes.
         * @format uint64
         */
        ending_height?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** slashes defines the slashes the validator received. */
          slashes?: {
            /** @format uint64 */
            validator_period?: string;
            fraction?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/distribution/v1beta1/validators/${validatorAddress}/slashes`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name AllEvidence
     * @summary AllEvidence queries all evidence.
     * @request GET:/cosmos/evidence/v1beta1/evidence
     */
    allEvidence: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** evidence returns all evidences. */
          evidence?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evidence/v1beta1/evidence`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Evidence
     * @summary Evidence queries evidence based on evidence hash.
     * @request GET:/cosmos/evidence/v1beta1/evidence/{hash}
     */
    evidence: (
      hash: string,
      query?: {
        /**
         * evidence_hash defines the hash of the requested evidence.
         * Deprecated: Use hash, a HEX encoded string, instead.
         * @format byte
         */
        evidence_hash?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          evidence?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/evidence/v1beta1/evidence/${hash}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovParams
     * @summary Params queries all parameters of the gov module.
     * @request GET:/cosmos/gov/v1beta1/params/{params_type}
     */
    govParams: (paramsType: string, params: RequestParams = {}) =>
      this.request<
        {
          /** voting_params defines the parameters related to voting. */
          voting_params?: {
            /** Duration of the voting period. */
            voting_period?: string;
          };
          /** deposit_params defines the parameters related to deposit. */
          deposit_params?: {
            /** Minimum deposit for a proposal to enter voting period. */
            min_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
             * months.
             */
            max_deposit_period?: string;
          };
          /** tally_params defines the parameters related to tally. */
          tally_params?: {
            /**
             * Minimum percentage of total stake needed to vote for a result to be
             * considered valid.
             * @format byte
             */
            quorum?: string;
            /**
             * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
             * @format byte
             */
            threshold?: string;
            /**
             * Minimum value of Veto votes to Total votes ratio for proposal to be
             * vetoed. Default value: 1/3.
             * @format byte
             */
            veto_threshold?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/params/${paramsType}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Proposals
     * @summary Proposals queries all proposals based on given status.
     * @request GET:/cosmos/gov/v1beta1/proposals
     */
    proposals: (
      query?: {
        /**
         * proposal_status defines the status of the proposals.
         *
         *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
         *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
         * period.
         *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
         * period.
         *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
         * passed.
         *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
         * been rejected.
         *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
         * failed.
         * @default "PROPOSAL_STATUS_UNSPECIFIED"
         */
        proposal_status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /** voter defines the voter address for the proposals. */
        voter?: string;
        /** depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** proposals defines all the requested governance proposals. */
          proposals?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            content?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /**
             * status defines the proposal status.
             * @default "PROPOSAL_STATUS_UNSPECIFIED"
             */
            status?:
              | "PROPOSAL_STATUS_UNSPECIFIED"
              | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
              | "PROPOSAL_STATUS_VOTING_PERIOD"
              | "PROPOSAL_STATUS_PASSED"
              | "PROPOSAL_STATUS_REJECTED"
              | "PROPOSAL_STATUS_FAILED";
            /**
             * final_tally_result is the final tally result of the proposal. When
             * querying a proposal via gRPC, this field is not populated until the
             * proposal's voting period has ended.
             */
            final_tally_result?: {
              /** yes is the number of yes votes on a proposal. */
              yes?: string;
              /** abstain is the number of abstain votes on a proposal. */
              abstain?: string;
              /** no is the number of no votes on a proposal. */
              no?: string;
              /** no_with_veto is the number of no with veto votes on a proposal. */
              no_with_veto?: string;
            };
            /**
             * submit_time is the time of proposal submission.
             * @format date-time
             */
            submit_time?: string;
            /**
             * deposit_end_time is the end time for deposition.
             * @format date-time
             */
            deposit_end_time?: string;
            /** total_deposit is the total deposit on the proposal. */
            total_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * voting_start_time is the starting time to vote on a proposal.
             * @format date-time
             */
            voting_start_time?: string;
            /**
             * voting_end_time is the end time of voting on a proposal.
             * @format date-time
             */
            voting_end_time?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Proposal
     * @summary Proposal queries proposal details based on ProposalID.
     * @request GET:/cosmos/gov/v1beta1/proposals/{proposal_id}
     */
    proposal: (proposalId: string, params: RequestParams = {}) =>
      this.request<
        {
          /** Proposal defines the core field members of a governance proposal. */
          proposal?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            content?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /**
             * status defines the proposal status.
             * @default "PROPOSAL_STATUS_UNSPECIFIED"
             */
            status?:
              | "PROPOSAL_STATUS_UNSPECIFIED"
              | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
              | "PROPOSAL_STATUS_VOTING_PERIOD"
              | "PROPOSAL_STATUS_PASSED"
              | "PROPOSAL_STATUS_REJECTED"
              | "PROPOSAL_STATUS_FAILED";
            /**
             * final_tally_result is the final tally result of the proposal. When
             * querying a proposal via gRPC, this field is not populated until the
             * proposal's voting period has ended.
             */
            final_tally_result?: {
              /** yes is the number of yes votes on a proposal. */
              yes?: string;
              /** abstain is the number of abstain votes on a proposal. */
              abstain?: string;
              /** no is the number of no votes on a proposal. */
              no?: string;
              /** no_with_veto is the number of no with veto votes on a proposal. */
              no_with_veto?: string;
            };
            /**
             * submit_time is the time of proposal submission.
             * @format date-time
             */
            submit_time?: string;
            /**
             * deposit_end_time is the end time for deposition.
             * @format date-time
             */
            deposit_end_time?: string;
            /** total_deposit is the total deposit on the proposal. */
            total_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * voting_start_time is the starting time to vote on a proposal.
             * @format date-time
             */
            voting_start_time?: string;
            /**
             * voting_end_time is the end time of voting on a proposal.
             * @format date-time
             */
            voting_end_time?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals/${proposalId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Deposits
     * @summary Deposits queries all deposits of a single proposal.
     * @request GET:/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits
     */
    deposits: (
      proposalId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** deposits defines the requested deposits. */
          deposits?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** depositor defines the deposit addresses from the proposals. */
            depositor?: string;
            /** amount to be deposited by depositor. */
            amount?: {
              denom?: string;
              amount?: string;
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals/${proposalId}/deposits`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Deposit
     * @summary Deposit queries single deposit information based on proposalID, depositor address.
     * @request GET:/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}
     */
    deposit: (
      proposalId: string,
      depositor: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Deposit defines an amount deposited by an account address to an active
           * proposal.
           */
          deposit?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** depositor defines the deposit addresses from the proposals. */
            depositor?: string;
            /** amount to be deposited by depositor. */
            amount?: {
              denom?: string;
              amount?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals/${proposalId}/deposits/${depositor}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TallyResult
     * @summary TallyResult queries the tally of a proposal vote.
     * @request GET:/cosmos/gov/v1beta1/proposals/{proposal_id}/tally
     */
    tallyResult: (proposalId: string, params: RequestParams = {}) =>
      this.request<
        {
          /** tally defines the requested tally. */
          tally?: {
            /** yes is the number of yes votes on a proposal. */
            yes?: string;
            /** abstain is the number of abstain votes on a proposal. */
            abstain?: string;
            /** no is the number of no votes on a proposal. */
            no?: string;
            /** no_with_veto is the number of no with veto votes on a proposal. */
            no_with_veto?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals/${proposalId}/tally`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Votes
     * @summary Votes queries votes of a given proposal.
     * @request GET:/cosmos/gov/v1beta1/proposals/{proposal_id}/votes
     */
    votes: (
      proposalId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** votes defines the queried votes. */
          votes?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** voter is the voter address of the proposal. */
            voter?: string;
            /**
             * Deprecated: Prefer to use `options` instead. This field is set in queries
             * if and only if `len(options) == 1` and that option has weight 1. In all
             * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
             * @default "VOTE_OPTION_UNSPECIFIED"
             */
            option?:
              | "VOTE_OPTION_UNSPECIFIED"
              | "VOTE_OPTION_YES"
              | "VOTE_OPTION_ABSTAIN"
              | "VOTE_OPTION_NO"
              | "VOTE_OPTION_NO_WITH_VETO";
            /**
             * options is the weighted vote options.
             *
             * Since: cosmos-sdk 0.43
             */
            options?: {
              /**
               * option defines the valid vote options, it must not contain duplicate vote options.
               * @default "VOTE_OPTION_UNSPECIFIED"
               */
              option?:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /** weight is the vote weight associated with the vote option. */
              weight?: string;
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals/${proposalId}/votes`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Vote
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @request GET:/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}
     */
    vote: (proposalId: string, voter: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Vote defines a vote on a governance proposal.
           * A Vote consists of a proposal ID, the voter, and the vote option.
           */
          vote?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** voter is the voter address of the proposal. */
            voter?: string;
            /**
             * Deprecated: Prefer to use `options` instead. This field is set in queries
             * if and only if `len(options) == 1` and that option has weight 1. In all
             * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
             * @default "VOTE_OPTION_UNSPECIFIED"
             */
            option?:
              | "VOTE_OPTION_UNSPECIFIED"
              | "VOTE_OPTION_YES"
              | "VOTE_OPTION_ABSTAIN"
              | "VOTE_OPTION_NO"
              | "VOTE_OPTION_NO_WITH_VETO";
            /**
             * options is the weighted vote options.
             *
             * Since: cosmos-sdk 0.43
             */
            options?: {
              /**
               * option defines the valid vote options, it must not contain duplicate vote options.
               * @default "VOTE_OPTION_UNSPECIFIED"
               */
              option?:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /** weight is the vote weight associated with the vote option. */
              weight?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1beta1/proposals/${proposalId}/votes/${voter}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Constitution
     * @summary Constitution queries the chain's constitution.
     * @request GET:/cosmos/gov/v1/constitution
     */
    constitution: (params: RequestParams = {}) =>
      this.request<
        {
          constitution?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/constitution`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Params
     * @summary Params queries all parameters of the gov module.
     * @request GET:/cosmos/gov/v1/params/{params_type}
     */
    govV1Params: (paramsType: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Deprecated: Prefer to use `params` instead.
           * voting_params defines the parameters related to voting.
           */
          voting_params?: {
            /** Duration of the voting period. */
            voting_period?: string;
          };
          /**
           * Deprecated: Prefer to use `params` instead.
           * deposit_params defines the parameters related to deposit.
           */
          deposit_params?: {
            /** Minimum deposit for a proposal to enter voting period. */
            min_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
             * months.
             */
            max_deposit_period?: string;
          };
          /**
           * Deprecated: Prefer to use `params` instead.
           * tally_params defines the parameters related to tally.
           */
          tally_params?: {
            /**
             * Minimum percentage of total stake needed to vote for a result to be
             * considered valid.
             */
            quorum?: string;
            /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
            threshold?: string;
            /**
             * Minimum value of Veto votes to Total votes ratio for proposal to be
             * vetoed. Default value: 1/3.
             */
            veto_threshold?: string;
          };
          /**
           * params defines all the paramaters of x/gov module.
           *
           * Since: cosmos-sdk 0.47
           */
          params?: {
            /** Minimum deposit for a proposal to enter voting period. */
            min_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
             * months.
             */
            max_deposit_period?: string;
            /** Duration of the voting period. */
            voting_period?: string;
            /**
             * Minimum percentage of total stake needed to vote for a result to be
             *  considered valid.
             */
            quorum?: string;
            /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
            threshold?: string;
            /**
             * Minimum value of Veto votes to Total votes ratio for proposal to be
             *  vetoed. Default value: 1/3.
             */
            veto_threshold?: string;
            /** The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
            min_initial_deposit_ratio?: string;
            /**
             * The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
             *
             * Since: cosmos-sdk 0.50
             */
            proposal_cancel_ratio?: string;
            /**
             * The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
             * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
             *
             * Since: cosmos-sdk 0.50
             */
            proposal_cancel_dest?: string;
            /**
             * Duration of the voting period of an expedited proposal.
             *
             * Since: cosmos-sdk 0.50
             */
            expedited_voting_period?: string;
            /**
             * Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
             *
             * Since: cosmos-sdk 0.50
             */
            expedited_threshold?: string;
            /** Minimum expedited deposit for a proposal to enter voting period. */
            expedited_min_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /** burn deposits if a proposal does not meet quorum */
            burn_vote_quorum?: boolean;
            /** burn deposits if the proposal does not enter voting period */
            burn_proposal_deposit_prevote?: boolean;
            /** burn deposits if quorum with vote type no_veto is met */
            burn_vote_veto?: boolean;
            /**
             * The ratio representing the proportion of the deposit value minimum that must be met when making a deposit.
             * Default value: 0.01. Meaning that for a chain with a min_deposit of 100stake, a deposit of 1stake would be
             * required.
             *
             * Since: cosmos-sdk 0.50
             */
            min_deposit_ratio?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/params/${paramsType}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Proposal
     * @summary Proposals queries all proposals based on given status.
     * @request GET:/cosmos/gov/v1/proposals
     */
    govV1Proposal: (
      query?: {
        /**
         * proposal_status defines the status of the proposals.
         *
         *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
         *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
         * period.
         *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
         * period.
         *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
         * passed.
         *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
         * been rejected.
         *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
         * failed.
         * @default "PROPOSAL_STATUS_UNSPECIFIED"
         */
        proposal_status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /** voter defines the voter address for the proposals. */
        voter?: string;
        /** depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** proposals defines all the requested governance proposals. */
          proposals?: {
            /**
             * id defines the unique id of the proposal.
             * @format uint64
             */
            id?: string;
            /** messages are the arbitrary messages to be executed if the proposal passes. */
            messages?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            }[];
            /**
             * status defines the proposal status.
             * @default "PROPOSAL_STATUS_UNSPECIFIED"
             */
            status?:
              | "PROPOSAL_STATUS_UNSPECIFIED"
              | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
              | "PROPOSAL_STATUS_VOTING_PERIOD"
              | "PROPOSAL_STATUS_PASSED"
              | "PROPOSAL_STATUS_REJECTED"
              | "PROPOSAL_STATUS_FAILED";
            /**
             * final_tally_result is the final tally result of the proposal. When
             * querying a proposal via gRPC, this field is not populated until the
             * proposal's voting period has ended.
             */
            final_tally_result?: {
              /** yes_count is the number of yes votes on a proposal. */
              yes_count?: string;
              /** abstain_count is the number of abstain votes on a proposal. */
              abstain_count?: string;
              /** no_count is the number of no votes on a proposal. */
              no_count?: string;
              /** no_with_veto_count is the number of no with veto votes on a proposal. */
              no_with_veto_count?: string;
            };
            /**
             * submit_time is the time of proposal submission.
             * @format date-time
             */
            submit_time?: string;
            /**
             * deposit_end_time is the end time for deposition.
             * @format date-time
             */
            deposit_end_time?: string;
            /** total_deposit is the total deposit on the proposal. */
            total_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * voting_start_time is the starting time to vote on a proposal.
             * @format date-time
             */
            voting_start_time?: string;
            /**
             * voting_end_time is the end time of voting on a proposal.
             * @format date-time
             */
            voting_end_time?: string;
            /**
             * metadata is any arbitrary metadata attached to the proposal.
             * the recommended format of the metadata is to be found here:
             * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
             */
            metadata?: string;
            /**
             * title is the title of the proposal
             * Since: cosmos-sdk 0.47
             */
            title?: string;
            /**
             * summary is a short summary of the proposal
             * Since: cosmos-sdk 0.47
             */
            summary?: string;
            /**
             * proposer is the address of the proposal sumbitter
             * Since: cosmos-sdk 0.47
             */
            proposer?: string;
            /**
             * expedited defines if the proposal is expedited
             * Since: cosmos-sdk 0.50
             */
            expedited?: boolean;
            /**
             * failed_reason defines the reason why the proposal failed
             * Since: cosmos-sdk 0.50
             */
            failed_reason?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Proposal2
     * @summary Proposal queries proposal details based on ProposalID.
     * @request GET:/cosmos/gov/v1/proposals/{proposal_id}
     * @originalName govV1Proposal
     * @duplicate
     */
    govV1Proposal2: (proposalId: string, params: RequestParams = {}) =>
      this.request<
        {
          /** Proposal defines the core field members of a governance proposal. */
          proposal?: {
            /**
             * id defines the unique id of the proposal.
             * @format uint64
             */
            id?: string;
            /** messages are the arbitrary messages to be executed if the proposal passes. */
            messages?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            }[];
            /**
             * status defines the proposal status.
             * @default "PROPOSAL_STATUS_UNSPECIFIED"
             */
            status?:
              | "PROPOSAL_STATUS_UNSPECIFIED"
              | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
              | "PROPOSAL_STATUS_VOTING_PERIOD"
              | "PROPOSAL_STATUS_PASSED"
              | "PROPOSAL_STATUS_REJECTED"
              | "PROPOSAL_STATUS_FAILED";
            /**
             * final_tally_result is the final tally result of the proposal. When
             * querying a proposal via gRPC, this field is not populated until the
             * proposal's voting period has ended.
             */
            final_tally_result?: {
              /** yes_count is the number of yes votes on a proposal. */
              yes_count?: string;
              /** abstain_count is the number of abstain votes on a proposal. */
              abstain_count?: string;
              /** no_count is the number of no votes on a proposal. */
              no_count?: string;
              /** no_with_veto_count is the number of no with veto votes on a proposal. */
              no_with_veto_count?: string;
            };
            /**
             * submit_time is the time of proposal submission.
             * @format date-time
             */
            submit_time?: string;
            /**
             * deposit_end_time is the end time for deposition.
             * @format date-time
             */
            deposit_end_time?: string;
            /** total_deposit is the total deposit on the proposal. */
            total_deposit?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * voting_start_time is the starting time to vote on a proposal.
             * @format date-time
             */
            voting_start_time?: string;
            /**
             * voting_end_time is the end time of voting on a proposal.
             * @format date-time
             */
            voting_end_time?: string;
            /**
             * metadata is any arbitrary metadata attached to the proposal.
             * the recommended format of the metadata is to be found here:
             * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
             */
            metadata?: string;
            /**
             * title is the title of the proposal
             * Since: cosmos-sdk 0.47
             */
            title?: string;
            /**
             * summary is a short summary of the proposal
             * Since: cosmos-sdk 0.47
             */
            summary?: string;
            /**
             * proposer is the address of the proposal sumbitter
             * Since: cosmos-sdk 0.47
             */
            proposer?: string;
            /**
             * expedited defines if the proposal is expedited
             * Since: cosmos-sdk 0.50
             */
            expedited?: boolean;
            /**
             * failed_reason defines the reason why the proposal failed
             * Since: cosmos-sdk 0.50
             */
            failed_reason?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals/${proposalId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Deposit
     * @summary Deposits queries all deposits of a single proposal.
     * @request GET:/cosmos/gov/v1/proposals/{proposal_id}/deposits
     */
    govV1Deposit: (
      proposalId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** deposits defines the requested deposits. */
          deposits?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** depositor defines the deposit addresses from the proposals. */
            depositor?: string;
            /** amount to be deposited by depositor. */
            amount?: {
              denom?: string;
              amount?: string;
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals/${proposalId}/deposits`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Deposit2
     * @summary Deposit queries single deposit information based on proposalID, depositAddr.
     * @request GET:/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}
     * @originalName govV1Deposit
     * @duplicate
     */
    govV1Deposit2: (
      proposalId: string,
      depositor: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Deposit defines an amount deposited by an account address to an active
           * proposal.
           */
          deposit?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** depositor defines the deposit addresses from the proposals. */
            depositor?: string;
            /** amount to be deposited by depositor. */
            amount?: {
              denom?: string;
              amount?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals/${proposalId}/deposits/${depositor}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1TallyResult
     * @summary TallyResult queries the tally of a proposal vote.
     * @request GET:/cosmos/gov/v1/proposals/{proposal_id}/tally
     */
    govV1TallyResult: (proposalId: string, params: RequestParams = {}) =>
      this.request<
        {
          /** tally defines the requested tally. */
          tally?: {
            /** yes_count is the number of yes votes on a proposal. */
            yes_count?: string;
            /** abstain_count is the number of abstain votes on a proposal. */
            abstain_count?: string;
            /** no_count is the number of no votes on a proposal. */
            no_count?: string;
            /** no_with_veto_count is the number of no with veto votes on a proposal. */
            no_with_veto_count?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals/${proposalId}/tally`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Votes
     * @summary Votes queries votes of a given proposal.
     * @request GET:/cosmos/gov/v1/proposals/{proposal_id}/votes
     */
    govV1Votes: (
      proposalId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** votes defines the queried votes. */
          votes?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** voter is the voter address of the proposal. */
            voter?: string;
            /** options is the weighted vote options. */
            options?: {
              /**
               * option defines the valid vote options, it must not contain duplicate vote options.
               * @default "VOTE_OPTION_UNSPECIFIED"
               */
              option?:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /** weight is the vote weight associated with the vote option. */
              weight?: string;
            }[];
            /**
             * metadata is any arbitrary metadata attached to the vote.
             * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
             */
            metadata?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals/${proposalId}/votes`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name GovV1Vote
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @request GET:/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}
     */
    govV1Vote: (
      proposalId: string,
      voter: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * Vote defines a vote on a governance proposal.
           * A Vote consists of a proposal ID, the voter, and the vote option.
           */
          vote?: {
            /**
             * proposal_id defines the unique id of the proposal.
             * @format uint64
             */
            proposal_id?: string;
            /** voter is the voter address of the proposal. */
            voter?: string;
            /** options is the weighted vote options. */
            options?: {
              /**
               * option defines the valid vote options, it must not contain duplicate vote options.
               * @default "VOTE_OPTION_UNSPECIFIED"
               */
              option?:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /** weight is the vote weight associated with the vote option. */
              weight?: string;
            }[];
            /**
             * metadata is any arbitrary metadata attached to the vote.
             * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
             */
            metadata?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/gov/v1/proposals/${proposalId}/votes/${voter}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.47
     *
     * @tags Service
     * @name TxDecode
     * @summary TxDecode decodes the transaction.
     * @request POST:/cosmos/tx/v1beta1/decode
     */
    txDecode: (
      body: {
        /**
         * tx_bytes is the raw transaction.
         * @format byte
         */
        tx_bytes?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        CosmosTxV1Beta1TxDecodeResponse,
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/decode`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.47
     *
     * @tags Service
     * @name TxDecodeAmino
     * @summary TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.
     * @request POST:/cosmos/tx/v1beta1/decode/amino
     */
    txDecodeAmino: (
      body: {
        /** @format byte */
        amino_binary?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          amino_json?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/decode/amino`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.47
     *
     * @tags Service
     * @name TxEncode
     * @summary TxEncode encodes the transaction.
     * @request POST:/cosmos/tx/v1beta1/encode
     */
    txEncode: (
      body: CosmosTxV1Beta1TxEncodeRequest,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * tx_bytes is the encoded transaction bytes.
           * @format byte
           */
          tx_bytes?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/encode`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.47
     *
     * @tags Service
     * @name TxEncodeAmino
     * @summary TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.
     * @request POST:/cosmos/tx/v1beta1/encode/amino
     */
    txEncodeAmino: (
      body: {
        amino_json?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** @format byte */
          amino_binary?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/encode/amino`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name Simulate
     * @summary Simulate simulates executing a transaction for estimating gas usage.
     * @request POST:/cosmos/tx/v1beta1/simulate
     */
    simulate: (
      body: CosmosTxV1Beta1SimulateRequest,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** gas_info is the information about gas used in the simulation. */
          gas_info?: {
            /**
             * GasWanted is the maximum units of work we allow this tx to perform.
             * @format uint64
             */
            gas_wanted?: string;
            /**
             * GasUsed is the amount of gas actually consumed.
             * @format uint64
             */
            gas_used?: string;
          };
          /** result is the result of the simulation. */
          result?: {
            /**
             * Data is any data returned from message or handler execution. It MUST be
             * length prefixed in order to separate data from multiple message executions.
             * Deprecated. This field is still populated, but prefer msg_response instead
             * because it also contains the Msg response typeURL.
             * @format byte
             */
            data?: string;
            /** Log contains the log information from message or handler execution. */
            log?: string;
            /**
             * Events contains a slice of Event objects that were emitted during message
             * or handler execution.
             */
            events?: {
              type?: string;
              attributes?: {
                key?: string;
                value?: string;
                index?: boolean;
              }[];
            }[];
            /**
             * msg_responses contains the Msg handler responses type packed in Anys.
             *
             * Since: cosmos-sdk 0.46
             */
            msg_responses?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/simulate`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetTxsEvent
     * @summary GetTxsEvent fetches txs by event.
     * @request GET:/cosmos/tx/v1beta1/txs
     */
    getTxsEvent: (
      query?: {
        /**
         * events is the list of transaction event type.
         * Deprecated post v0.47.x: use query instead, which should contain a valid
         * events query.
         */
        events?: string[];
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         *  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults
         * to ASC in this case.
         *  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
         *  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @default "ORDER_BY_UNSPECIFIED"
         */
        order_by?: "ORDER_BY_UNSPECIFIED" | "ORDER_BY_ASC" | "ORDER_BY_DESC";
        /**
         * page is the page number to query, starts at 1. If not provided, will
         * default to first page.
         * @format uint64
         */
        page?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        limit?: string;
        /**
         * query defines the transaction event query that is proxied to Tendermint's
         * TxSearch RPC method. The query must be valid.
         *
         * Since cosmos-sdk 0.50
         */
        query?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        CosmosTxV1Beta1GetTxsEventResponse,
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/txs`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name BroadcastTx
     * @summary BroadcastTx broadcast transaction.
     * @request POST:/cosmos/tx/v1beta1/txs
     */
    broadcastTx: (
      body: {
        /**
         * tx_bytes is the raw transaction.
         * @format byte
         */
        tx_bytes?: string;
        /**
         * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
         * method.
         *
         *  - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
         *  - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
         * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
         *  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
         * for a CheckTx execution response only.
         *  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
         * returns immediately.
         * @default "BROADCAST_MODE_UNSPECIFIED"
         */
        mode?:
          | "BROADCAST_MODE_UNSPECIFIED"
          | "BROADCAST_MODE_BLOCK"
          | "BROADCAST_MODE_SYNC"
          | "BROADCAST_MODE_ASYNC";
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * TxResponse defines a structure containing relevant tx data and metadata. The
           * tags are stringified and the log is JSON decoded.
           */
          tx_response?: {
            /**
             * The block height
             * @format int64
             */
            height?: string;
            /** The transaction hash. */
            txhash?: string;
            /** Namespace for the Code */
            codespace?: string;
            /**
             * Response code.
             * @format int64
             */
            code?: number;
            /** Result bytes, if any. */
            data?: string;
            /**
             * The output of the application's logger (raw string). May be
             * non-deterministic.
             */
            raw_log?: string;
            /** The output of the application's logger (typed). May be non-deterministic. */
            logs?: {
              /** @format int64 */
              msg_index?: number;
              log?: string;
              /**
               * Events contains a slice of Event objects that were emitted during some
               * execution.
               */
              events?: {
                type?: string;
                attributes?: {
                  key?: string;
                  value?: string;
                }[];
              }[];
            }[];
            /** Additional information. May be non-deterministic. */
            info?: string;
            /**
             * Amount of gas requested for transaction.
             * @format int64
             */
            gas_wanted?: string;
            /**
             * Amount of gas consumed by transaction.
             * @format int64
             */
            gas_used?: string;
            /**
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            tx?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
            /**
             * Time of the previous block. For heights > 1, it's the weighted median of
             * the timestamps of the valid votes in the block.LastCommit. For height == 1,
             * it's genesis time.
             */
            timestamp?: string;
            /**
             * Events defines all the events emitted by processing a transaction. Note,
             * these events include those emitted by processing all the messages and those
             * emitted from the ante. Whereas Logs contains the events, with
             * additional metadata, emitted only by processing the messages.
             *
             * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
             */
            events?: {
              type?: string;
              attributes?: {
                key?: string;
                value?: string;
                index?: boolean;
              }[];
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/txs`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Since: cosmos-sdk 0.45.2
     *
     * @tags Service
     * @name GetBlockWithTxs
     * @summary GetBlockWithTxs fetches a block with decoded txs.
     * @request GET:/cosmos/tx/v1beta1/txs/block/{height}
     */
    getBlockWithTxs: (
      height: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        CosmosTxV1Beta1GetBlockWithTxsResponse,
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/txs/block/${height}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Service
     * @name GetTx
     * @summary GetTx fetches a tx by hash.
     * @request GET:/cosmos/tx/v1beta1/txs/{hash}
     */
    getTx: (hash: string, params: RequestParams = {}) =>
      this.request<
        CosmosTxV1Beta1GetTxResponse,
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/tx/v1beta1/txs/${hash}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name SlashingParams
     * @summary Params queries the parameters of slashing module
     * @request GET:/cosmos/slashing/v1beta1/params
     */
    slashingParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** Params represents the parameters used for by the slashing module. */
          params?: {
            /** @format int64 */
            signed_blocks_window?: string;
            /** @format byte */
            min_signed_per_window?: string;
            downtime_jail_duration?: string;
            /** @format byte */
            slash_fraction_double_sign?: string;
            /** @format byte */
            slash_fraction_downtime?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/slashing/v1beta1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name SigningInfos
     * @summary SigningInfos queries signing info of all validators
     * @request GET:/cosmos/slashing/v1beta1/signing_infos
     */
    signingInfos: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** info is the signing info of all validators */
          info?: {
            address?: string;
            /**
             * Height at which validator was first a candidate OR was un-jailed
             * @format int64
             */
            start_height?: string;
            /**
             * Index which is incremented every time a validator is bonded in a block and
             * _may_ have signed a pre-commit or not. This in conjunction with the
             * signed_blocks_window param determines the index in the missed block bitmap.
             * @format int64
             */
            index_offset?: string;
            /**
             * Timestamp until which the validator is jailed due to liveness downtime.
             * @format date-time
             */
            jailed_until?: string;
            /**
             * Whether or not a validator has been tombstoned (killed out of validator
             * set). It is set once the validator commits an equivocation or for any other
             * configured misbehavior.
             */
            tombstoned?: boolean;
            /**
             * A counter of missed (unsigned) blocks. It is used to avoid unnecessary
             * reads in the missed block bitmap.
             * @format int64
             */
            missed_blocks_counter?: string;
          }[];
          /**
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/slashing/v1beta1/signing_infos`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name SigningInfo
     * @summary SigningInfo queries the signing info of given cons address
     * @request GET:/cosmos/slashing/v1beta1/signing_infos/{cons_address}
     */
    signingInfo: (consAddress: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * val_signing_info is the signing info of requested val cons address
           * ValidatorSigningInfo defines a validator's signing info for monitoring their
           * liveness activity.
           */
          val_signing_info?: {
            address?: string;
            /**
             * Height at which validator was first a candidate OR was un-jailed
             * @format int64
             */
            start_height?: string;
            /**
             * Index which is incremented every time a validator is bonded in a block and
             * _may_ have signed a pre-commit or not. This in conjunction with the
             * signed_blocks_window param determines the index in the missed block bitmap.
             * @format int64
             */
            index_offset?: string;
            /**
             * Timestamp until which the validator is jailed due to liveness downtime.
             * @format date-time
             */
            jailed_until?: string;
            /**
             * Whether or not a validator has been tombstoned (killed out of validator
             * set). It is set once the validator commits an equivocation or for any other
             * configured misbehavior.
             */
            tombstoned?: boolean;
            /**
             * A counter of missed (unsigned) blocks. It is used to avoid unnecessary
             * reads in the missed block bitmap.
             * @format int64
             */
            missed_blocks_counter?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/cosmos/slashing/v1beta1/signing_infos/${consAddress}`,
        method: "GET",
        ...params,
      }),
  };
  strideLabs = {
    /**
     * No description
     *
     * @tags Query
     * @name AllBlacklistedDenoms
     * @summary Queries all blacklisted denoms
     * @request GET:/Stride-Labs/ibc-rate-limiting/ratelimit/blacklisted_denoms
     */
    allBlacklistedDenoms: (params: RequestParams = {}) =>
      this.request<
        {
          denoms?: string[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/Stride-Labs/ibc-rate-limiting/ratelimit/blacklisted_denoms`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name RateLimit
 * @summary Queries a specific rate limit by channel ID and denom
Ex:
 - /ratelimit/{channel_id}/by_denom?denom={denom}
 * @request GET:/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimit/{channel_id}/by_denom
 */
    rateLimit: (
      channelId: string,
      query?: {
        denom?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * RateLimit stores all the context about a given rate limit, including
           * the relevant denom and channel, rate limit thresholds, and current
           * progress towards the limits
           */
          rate_limit?: {
            /** Path holds the denom and channelID that define the rate limited route */
            path?: {
              denom?: string;
              channel_id?: string;
            };
            /** Quota defines the rate limit thresholds for transfer packets */
            quota?: {
              /**
               * MaxPercentSend defines the threshold for outflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_send?: string;
              /**
               * MaxPercentSend defines the threshold for inflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_recv?: string;
              /**
               * DurationHours specifies the number of hours before the rate limit
               * is reset (e.g. 24 indicates that the rate limit is reset each day)
               * @format uint64
               */
              duration_hours?: string;
            };
            flow?: {
              /**
               * Inflow defines the total amount of inbound transfers for the given
               * rate limit in the current window
               */
              inflow?: string;
              /**
               * Outflow defines the total amount of outbound transfers for the given
               * rate limit in the current window
               */
              outflow?: string;
              /**
               * ChannelValue stores the total supply of the denom at the start of
               * the rate limit. This is used as the denominator when checking
               * the rate limit threshold
               * The ChannelValue is fixed for the duration of the rate limit window
               */
              channel_value?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimit/${channelId}/by_denom`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name AllRateLimits
     * @summary Queries all rate limits
     * @request GET:/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimits
     */
    allRateLimits: (params: RequestParams = {}) =>
      this.request<
        {
          rate_limits?: {
            /** Path holds the denom and channelID that define the rate limited route */
            path?: {
              denom?: string;
              channel_id?: string;
            };
            /** Quota defines the rate limit thresholds for transfer packets */
            quota?: {
              /**
               * MaxPercentSend defines the threshold for outflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_send?: string;
              /**
               * MaxPercentSend defines the threshold for inflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_recv?: string;
              /**
               * DurationHours specifies the number of hours before the rate limit
               * is reset (e.g. 24 indicates that the rate limit is reset each day)
               * @format uint64
               */
              duration_hours?: string;
            };
            flow?: {
              /**
               * Inflow defines the total amount of inbound transfers for the given
               * rate limit in the current window
               */
              inflow?: string;
              /**
               * Outflow defines the total amount of outbound transfers for the given
               * rate limit in the current window
               */
              outflow?: string;
              /**
               * ChannelValue stores the total supply of the denom at the start of
               * the rate limit. This is used as the denominator when checking
               * the rate limit threshold
               * The ChannelValue is fixed for the duration of the rate limit window
               */
              channel_value?: string;
            };
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimits`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name RateLimitsByChainId
     * @summary Queries all the rate limits for a given chain
     * @request GET:/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimits/{chain_id}
     */
    rateLimitsByChainId: (chainId: string, params: RequestParams = {}) =>
      this.request<
        {
          rate_limits?: {
            /** Path holds the denom and channelID that define the rate limited route */
            path?: {
              denom?: string;
              channel_id?: string;
            };
            /** Quota defines the rate limit thresholds for transfer packets */
            quota?: {
              /**
               * MaxPercentSend defines the threshold for outflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_send?: string;
              /**
               * MaxPercentSend defines the threshold for inflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_recv?: string;
              /**
               * DurationHours specifies the number of hours before the rate limit
               * is reset (e.g. 24 indicates that the rate limit is reset each day)
               * @format uint64
               */
              duration_hours?: string;
            };
            flow?: {
              /**
               * Inflow defines the total amount of inbound transfers for the given
               * rate limit in the current window
               */
              inflow?: string;
              /**
               * Outflow defines the total amount of outbound transfers for the given
               * rate limit in the current window
               */
              outflow?: string;
              /**
               * ChannelValue stores the total supply of the denom at the start of
               * the rate limit. This is used as the denominator when checking
               * the rate limit threshold
               * The ChannelValue is fixed for the duration of the rate limit window
               */
              channel_value?: string;
            };
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimits/${chainId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name RateLimitsByChannelId
     * @summary Queries all the rate limits for a given channel ID
     * @request GET:/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimits/{channel_id}
     */
    rateLimitsByChannelId: (channelId: string, params: RequestParams = {}) =>
      this.request<
        {
          rate_limits?: {
            /** Path holds the denom and channelID that define the rate limited route */
            path?: {
              denom?: string;
              channel_id?: string;
            };
            /** Quota defines the rate limit thresholds for transfer packets */
            quota?: {
              /**
               * MaxPercentSend defines the threshold for outflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_send?: string;
              /**
               * MaxPercentSend defines the threshold for inflows
               * The threshold is defined as a percentage (e.g. 10 indicates 10%)
               */
              max_percent_recv?: string;
              /**
               * DurationHours specifies the number of hours before the rate limit
               * is reset (e.g. 24 indicates that the rate limit is reset each day)
               * @format uint64
               */
              duration_hours?: string;
            };
            flow?: {
              /**
               * Inflow defines the total amount of inbound transfers for the given
               * rate limit in the current window
               */
              inflow?: string;
              /**
               * Outflow defines the total amount of outbound transfers for the given
               * rate limit in the current window
               */
              outflow?: string;
              /**
               * ChannelValue stores the total supply of the denom at the start of
               * the rate limit. This is used as the denominator when checking
               * the rate limit threshold
               * The ChannelValue is fixed for the duration of the rate limit window
               */
              channel_value?: string;
            };
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/Stride-Labs/ibc-rate-limiting/ratelimit/ratelimits/${channelId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name AllWhitelistedAddresses
     * @summary Queries all whitelisted address pairs
     * @request GET:/Stride-Labs/ibc-rate-limiting/ratelimit/whitelisted_addresses
     */
    allWhitelistedAddresses: (params: RequestParams = {}) =>
      this.request<
        {
          address_pairs?: {
            sender?: string;
            receiver?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/Stride-Labs/ibc-rate-limiting/ratelimit/whitelisted_addresses`,
        method: "GET",
        ...params,
      }),
  };
  ibc = {
    /**
     * No description
     *
     * @tags Query
     * @name EscrowAddress
     * @summary EscrowAddress returns the escrow address for a particular port and channel id.
     * @request GET:/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address
     */
    escrowAddress: (
      channelId: string,
      portId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** the escrow account address */
          escrow_address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/transfer/v1/channels/${channelId}/ports/${portId}/escrow_address`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DenomHash
     * @summary DenomHash queries a denomination hash information.
     * @request GET:/ibc/apps/transfer/v1/denom_hashes/{trace}
     */
    denomHash: (trace: string, params: RequestParams = {}) =>
      this.request<
        {
          /** hash (in hex format) of the denomination trace information. */
          hash?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/transfer/v1/denom_hashes/${trace}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DenomTraces
     * @summary DenomTraces queries all denomination traces.
     * @request GET:/ibc/apps/transfer/v1/denom_traces
     */
    denomTraces: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** denom_traces returns all denominations trace information. */
          denom_traces?: {
            /**
             * path defines the chain of port/channel identifiers used for tracing the
             * source of the fungible token.
             */
            path?: string;
            /** base denomination of the relayed fungible token. */
            base_denom?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/transfer/v1/denom_traces`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name DenomTrace
     * @summary DenomTrace queries a denomination trace information.
     * @request GET:/ibc/apps/transfer/v1/denom_traces/{hash}
     */
    denomTrace: (hash: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * DenomTrace contains the base denomination for ICS20 fungible tokens and the
           * source tracing information path.
           */
          denom_trace?: {
            /**
             * path defines the chain of port/channel identifiers used for tracing the
             * source of the fungible token.
             */
            path?: string;
            /** base denomination of the relayed fungible token. */
            base_denom?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/transfer/v1/denom_traces/${hash}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TotalEscrowForDenom
     * @summary TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.
     * @request GET:/ibc/apps/transfer/v1/denoms/{denom}/total_escrow
     */
    totalEscrowForDenom: (denom: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Coin defines a token with a denomination and an amount.
           *
           * NOTE: The amount field is an Int which implements the custom method
           * signatures required by gogoproto.
           */
          amount?: {
            denom?: string;
            amount?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/transfer/v1/denoms/${denom}/total_escrow`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TransferParams
     * @summary Params queries all parameters of the ibc-transfer module.
     * @request GET:/ibc/apps/transfer/v1/params
     */
    transferParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /**
             * send_enabled enables or disables all cross-chain token transfers from this
             * chain.
             */
            send_enabled?: boolean;
            /**
             * receive_enabled enables or disables all cross-chain token transfers to this
             * chain.
             */
            receive_enabled?: boolean;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/transfer/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name FeeEnabledChannel
     * @summary FeeEnabledChannel returns true if the provided port and channel identifiers belong to a fee enabled channel
     * @request GET:/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/fee_enabled
     */
    feeEnabledChannel: (
      channelId: string,
      portId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** boolean flag representing the fee enabled channel status */
          fee_enabled?: boolean;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${channelId}/ports/${portId}/fee_enabled`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name IncentivizedPacketsForChannel
     * @summary Gets all incentivized packets for a specific channel
     * @request GET:/ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/incentivized_packets
     */
    incentivizedPacketsForChannel: (
      channelId: string,
      portId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         * Height to query at.
         * @format uint64
         */
        query_height?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** Map of all incentivized_packets */
          incentivized_packets?: {
            /** unique packet identifier comprised of the channel ID, port ID and sequence */
            packet_id?: {
              /** channel port identifier */
              port_id?: string;
              /** channel unique identifier */
              channel_id?: string;
              /**
               * packet sequence
               * @format uint64
               */
              sequence?: string;
            };
            /** list of packet fees */
            packet_fees?: {
              /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
              fee?: {
                /** the packet receive fee */
                recv_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
                /** the packet acknowledgement fee */
                ack_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
                /** the packet timeout fee */
                timeout_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
              };
              /** the refund address for unspent fees */
              refund_address?: string;
              /** optional list of relayers permitted to receive fees */
              relayers?: string[];
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${channelId}/ports/${portId}/incentivized_packets`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name CounterpartyPayee
     * @summary CounterpartyPayee returns the registered counterparty payee for forward relaying
     * @request GET:/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/counterparty_payee
     */
    counterpartyPayee: (
      channelId: string,
      relayer: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** the counterparty payee address used to compensate forward relaying */
          counterparty_payee?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${channelId}/relayers/${relayer}/counterparty_payee`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Payee
     * @summary Payee returns the registered payee address for a specific channel given the relayer address
     * @request GET:/ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/payee
     */
    payee: (channelId: string, relayer: string, params: RequestParams = {}) =>
      this.request<
        {
          /** the payee address to which packet fees are paid out */
          payee_address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${channelId}/relayers/${relayer}/payee`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name IncentivizedPacket
     * @summary IncentivizedPacket returns all packet fees for a packet given its identifier
     * @request GET:/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/incentivized_packet
     */
    incentivizedPacket: (
      packetIdChannelId: string,
      packetIdPortId: string,
      packetIdSequence: string,
      query?: {
        /**
         * block height at which to query.
         * @format uint64
         */
        query_height?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** IdentifiedPacketFees contains a list of type PacketFee and associated PacketId */
          incentivized_packet?: {
            /** unique packet identifier comprised of the channel ID, port ID and sequence */
            packet_id?: {
              /** channel port identifier */
              port_id?: string;
              /** channel unique identifier */
              channel_id?: string;
              /**
               * packet sequence
               * @format uint64
               */
              sequence?: string;
            };
            /** list of packet fees */
            packet_fees?: {
              /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
              fee?: {
                /** the packet receive fee */
                recv_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
                /** the packet acknowledgement fee */
                ack_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
                /** the packet timeout fee */
                timeout_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
              };
              /** the refund address for unspent fees */
              refund_address?: string;
              /** optional list of relayers permitted to receive fees */
              relayers?: string[];
            }[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${packetIdChannelId}/ports/${packetIdPortId}/sequences/${packetIdSequence}/incentivized_packet`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TotalAckFees
     * @summary TotalAckFees returns the total acknowledgement fees for a packet given its identifier
     * @request GET:/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_ack_fees
     */
    totalAckFees: (
      packetIdChannelId: string,
      packetIdPortId: string,
      packetIdSequence: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** the total packet acknowledgement fees */
          ack_fees?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${packetIdChannelId}/ports/${packetIdPortId}/sequences/${packetIdSequence}/total_ack_fees`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TotalRecvFees
     * @summary TotalRecvFees returns the total receive fees for a packet given its identifier
     * @request GET:/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_recv_fees
     */
    totalRecvFees: (
      packetIdChannelId: string,
      packetIdPortId: string,
      packetIdSequence: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** the total packet receive fees */
          recv_fees?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${packetIdChannelId}/ports/${packetIdPortId}/sequences/${packetIdSequence}/total_recv_fees`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name TotalTimeoutFees
     * @summary TotalTimeoutFees returns the total timeout fees for a packet given its identifier
     * @request GET:/ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_timeout_fees
     */
    totalTimeoutFees: (
      packetIdChannelId: string,
      packetIdPortId: string,
      packetIdSequence: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** the total packet timeout fees */
          timeout_fees?: {
            denom?: string;
            amount?: string;
          }[];
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/channels/${packetIdChannelId}/ports/${packetIdPortId}/sequences/${packetIdSequence}/total_timeout_fees`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name FeeEnabledChannels
     * @summary FeeEnabledChannels returns a list of all fee enabled channels
     * @request GET:/ibc/apps/fee/v1/fee_enabled
     */
    feeEnabledChannels: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         * block height at which to query.
         * @format uint64
         */
        query_height?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of fee enabled channels */
          fee_enabled_channels?: {
            /** unique port identifier */
            port_id?: string;
            /** unique channel identifier */
            channel_id?: string;
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/fee_enabled`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name IncentivizedPackets
     * @summary IncentivizedPackets returns all incentivized packets and their associated fees
     * @request GET:/ibc/apps/fee/v1/incentivized_packets
     */
    incentivizedPackets: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         * block height at which to query.
         * @format uint64
         */
        query_height?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of identified fees for incentivized packets */
          incentivized_packets?: {
            /** unique packet identifier comprised of the channel ID, port ID and sequence */
            packet_id?: {
              /** channel port identifier */
              port_id?: string;
              /** channel unique identifier */
              channel_id?: string;
              /**
               * packet sequence
               * @format uint64
               */
              sequence?: string;
            };
            /** list of packet fees */
            packet_fees?: {
              /** fee encapsulates the recv, ack and timeout fees associated with an IBC packet */
              fee?: {
                /** the packet receive fee */
                recv_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
                /** the packet acknowledgement fee */
                ack_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
                /** the packet timeout fee */
                timeout_fee?: {
                  denom?: string;
                  amount?: string;
                }[];
              };
              /** the refund address for unspent fees */
              refund_address?: string;
              /** optional list of relayers permitted to receive fees */
              relayers?: string[];
            }[];
          }[];
          /** pagination defines the pagination in the response. */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/fee/v1/incentivized_packets`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name InterchainAccount
     * @summary InterchainAccount returns the interchain account address for a given owner address on a given connection
     * @request GET:/ibc/apps/interchain_accounts/controller/v1/owners/{owner}/connections/{connection_id}
     */
    interchainAccount: (
      owner: string,
      connectionId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          address?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/interchain_accounts/controller/v1/owners/${owner}/connections/${connectionId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name InterchainAccountsControllerParams
     * @summary Params queries all parameters of the ICA controller submodule.
     * @request GET:/ibc/apps/interchain_accounts/controller/v1/params
     */
    interchainAccountsControllerParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /** controller_enabled enables or disables the controller submodule. */
            controller_enabled?: boolean;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/interchain_accounts/controller/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name InterchainAccountsHostParams
     * @summary Params queries all parameters of the ICA host submodule.
     * @request GET:/ibc/apps/interchain_accounts/host/v1/params
     */
    interchainAccountsHostParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /** host_enabled enables or disables the host submodule. */
            host_enabled?: boolean;
            /** allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain. */
            allow_messages?: string[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            type_url?: string;
            /** @format byte */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/apps/interchain_accounts/host/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Channels
     * @summary Channels queries all the IBC channels of a chain.
     * @request GET:/ibc/core/channel/v1/channels
     */
    channels: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of stored channels of the chain. */
          channels?: {
            /**
             * current state of the channel end
             * State defines if a channel is in one of the following states:
             * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
             *
             *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
             *  - STATE_INIT: A channel has just started the opening handshake.
             *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
             *  - STATE_OPEN: A channel has completed the handshake. Open channels are
             * ready to send and receive packets.
             *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
             * packets.
             *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
             *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
             * @default "STATE_UNINITIALIZED_UNSPECIFIED"
             */
            state?:
              | "STATE_UNINITIALIZED_UNSPECIFIED"
              | "STATE_INIT"
              | "STATE_TRYOPEN"
              | "STATE_OPEN"
              | "STATE_CLOSED"
              | "STATE_FLUSHING"
              | "STATE_FLUSHCOMPLETE";
            /**
             * whether the channel is ordered or unordered
             * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
             *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
             * which they were sent.
             *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
             * @default "ORDER_NONE_UNSPECIFIED"
             */
            ordering?:
              | "ORDER_NONE_UNSPECIFIED"
              | "ORDER_UNORDERED"
              | "ORDER_ORDERED";
            /** counterparty channel end */
            counterparty?: {
              /** port on the counterparty chain which owns the other end of the channel. */
              port_id?: string;
              /** channel end on the counterparty chain */
              channel_id?: string;
            };
            /**
             * list of connection identifiers, in order, along which packets sent on
             * this channel will travel
             */
            connection_hops?: string[];
            /** opaque channel version, which is agreed upon during the handshake */
            version?: string;
            /** port identifier */
            port_id?: string;
            /** channel identifier */
            channel_id?: string;
            /**
             * upgrade sequence indicates the latest upgrade attempt performed by this channel
             * the value of 0 indicates the channel has never been upgraded
             * @format uint64
             */
            upgrade_sequence?: string;
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Channel
     * @summary Channel queries an IBC Channel.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}
     */
    channel: (channelId: string, portId: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * channel associated with the request identifiers
           * Channel defines pipeline for exactly-once packet delivery between specific
           * modules on separate blockchains, which has at least one end capable of
           * sending packets and one end capable of receiving packets.
           */
          channel?: {
            /**
             * current state of the channel end
             * State defines if a channel is in one of the following states:
             * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
             *
             *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
             *  - STATE_INIT: A channel has just started the opening handshake.
             *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
             *  - STATE_OPEN: A channel has completed the handshake. Open channels are
             * ready to send and receive packets.
             *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
             * packets.
             *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
             *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
             * @default "STATE_UNINITIALIZED_UNSPECIFIED"
             */
            state?:
              | "STATE_UNINITIALIZED_UNSPECIFIED"
              | "STATE_INIT"
              | "STATE_TRYOPEN"
              | "STATE_OPEN"
              | "STATE_CLOSED"
              | "STATE_FLUSHING"
              | "STATE_FLUSHCOMPLETE";
            /**
             * whether the channel is ordered or unordered
             * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
             *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
             * which they were sent.
             *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
             * @default "ORDER_NONE_UNSPECIFIED"
             */
            ordering?:
              | "ORDER_NONE_UNSPECIFIED"
              | "ORDER_UNORDERED"
              | "ORDER_ORDERED";
            /** counterparty channel end */
            counterparty?: {
              /** port on the counterparty chain which owns the other end of the channel. */
              port_id?: string;
              /** channel end on the counterparty chain */
              channel_id?: string;
            };
            /**
             * list of connection identifiers, in order, along which packets sent on
             * this channel will travel
             */
            connection_hops?: string[];
            /** opaque channel version, which is agreed upon during the handshake */
            version?: string;
            /**
             * upgrade sequence indicates the latest upgrade attempt performed by this channel
             * the value of 0 indicates the channel has never been upgraded
             * @format uint64
             */
            upgrade_sequence?: string;
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ChannelClientState
 * @summary ChannelClientState queries for the client state for the channel associated
with the provided channel identifiers.
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state
 */
    channelClientState: (
      channelId: string,
      portId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * client state associated with the channel
           * IdentifiedClientState defines a client state with an additional client
           * identifier field.
           */
          identified_client_state?: {
            /** client identifier */
            client_id?: string;
            /**
             * client state
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            client_state?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/client_state`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ChannelConsensusState
 * @summary ChannelConsensusState queries for the consensus state for the channel
associated with the provided channel identifiers.
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}
 */
    channelConsensusState: (
      channelId: string,
      portId: string,
      revisionNumber: string,
      revisionHeight: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * consensus state associated with the channel
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          consensus_state?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
          /** client ID associated with the consensus state */
          client_id?: string;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/consensus_state/revision/${revisionNumber}/height/${revisionHeight}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name NextSequenceReceive
     * @summary NextSequenceReceive returns the next receive sequence for a given channel.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence
     */
    nextSequenceReceive: (
      channelId: string,
      portId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * next sequence receive number
           * @format uint64
           */
          next_sequence_receive?: string;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/next_sequence`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name NextSequenceSend
     * @summary NextSequenceSend returns the next send sequence for a given channel.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send
     */
    nextSequenceSend: (
      channelId: string,
      portId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * next sequence send number
           * @format uint64
           */
          next_sequence_send?: string;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/next_sequence_send`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name PacketAcknowledgements
 * @summary PacketAcknowledgements returns all the packet acknowledgements associated
with a channel.
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements
 */
    packetAcknowledgements: (
      channelId: string,
      portId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /** list of packet sequences. */
        packet_commitment_sequences?: string[];
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          acknowledgements?: {
            /** channel port identifier. */
            port_id?: string;
            /** channel unique identifier. */
            channel_id?: string;
            /**
             * packet sequence.
             * @format uint64
             */
            sequence?: string;
            /**
             * embedded data that represents packet state.
             * @format byte
             */
            data?: string;
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_acknowledgements`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name PacketAcknowledgement
     * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}
     */
    packetAcknowledgement: (
      channelId: string,
      portId: string,
      sequence: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * packet associated with the request fields
           * @format byte
           */
          acknowledgement?: string;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_acks/${sequence}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name PacketCommitments
 * @summary PacketCommitments returns all the packet commitments hashes associated
with a channel.
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments
 */
    packetCommitments: (
      channelId: string,
      portId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          commitments?: {
            /** channel port identifier. */
            port_id?: string;
            /** channel unique identifier. */
            channel_id?: string;
            /**
             * packet sequence.
             * @format uint64
             */
            sequence?: string;
            /**
             * embedded data that represents packet state.
             * @format byte
             */
            data?: string;
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_commitments`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name UnreceivedAcks
 * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated
with a channel and sequences.
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks
 */
    unreceivedAcks: (
      channelId: string,
      portId: string,
      packetAckSequences: string[],
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of unreceived acknowledgement sequences */
          sequences?: string[];
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_commitments/${packetAckSequences}/unreceived_acks`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name UnreceivedPackets
 * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a
channel and sequences.
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets
 */
    unreceivedPackets: (
      channelId: string,
      portId: string,
      packetCommitmentSequences: string[],
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of unreceived packet sequences */
          sequences?: string[];
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_commitments/${packetCommitmentSequences}/unreceived_packets`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name PacketCommitment
     * @summary PacketCommitment queries a stored packet commitment hash.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}
     */
    packetCommitment: (
      channelId: string,
      portId: string,
      sequence: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * packet associated with the request fields
           * @format byte
           */
          commitment?: string;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_commitments/${sequence}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name PacketReceipt
 * @summary PacketReceipt queries if a given packet sequence has been received on the
queried chain
 * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}
 */
    packetReceipt: (
      channelId: string,
      portId: string,
      sequence: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** success flag for if receipt exists */
          received?: boolean;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/packet_receipts/${sequence}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Upgrade
     * @summary Upgrade returns the upgrade for a given port and channel id.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade
     */
    upgrade: (channelId: string, portId: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Upgrade is a verifiable type which contains the relevant information
           * for an attempted upgrade. It provides the proposed changes to the channel
           * end, the timeout for this upgrade attempt and the next packet sequence
           * which allows the counterparty to efficiently know the highest sequence it has received.
           * The next sequence send is used for pruning and upgrading from unordered to ordered channels.
           */
          upgrade?: {
            /**
             * UpgradeFields are the fields in a channel end which may be changed
             * during a channel upgrade.
             */
            fields?: {
              /**
               * Order defines if a channel is ORDERED or UNORDERED
               * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               * which they were sent.
               *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default "ORDER_NONE_UNSPECIFIED"
               */
              ordering?:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              connection_hops?: string[];
              version?: string;
            };
            /**
             * Timeout defines an execution deadline structure for 04-channel handlers.
             * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
             * A valid Timeout contains either one or both of a timestamp and block height (sequence).
             */
            timeout?: {
              /**
               * block height after which the packet or upgrade times out
               * Normally the RevisionHeight is incremented at each height while keeping
               * RevisionNumber the same. However some consensus algorithms may choose to
               * reset the height in certain conditions e.g. hard forks, state-machine
               * breaking changes In these cases, the RevisionNumber is incremented so that
               * height continues to be monitonically increasing even as the RevisionHeight
               * gets reset
               */
              height?: {
                /**
                 * the revision that the client is currently on
                 * @format uint64
                 */
                revision_number?: string;
                /**
                 * the height within the given revision
                 * @format uint64
                 */
                revision_height?: string;
              };
              /**
               * block timestamp (in nanoseconds) after which the packet or upgrade times out
               * @format uint64
               */
              timestamp?: string;
            };
            /** @format uint64 */
            next_sequence_send?: string;
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/upgrade`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name UpgradeError
     * @summary UpgradeError returns the error receipt if the upgrade handshake failed.
     * @request GET:/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade_error
     */
    upgradeError: (
      channelId: string,
      portId: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the
           * upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the
           * next sequence.
           */
          error_receipt?: {
            /**
             * the channel upgrade sequence
             * @format uint64
             */
            sequence?: string;
            /** the error message detailing the cause of failure */
            message?: string;
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/channels/${channelId}/ports/${portId}/upgrade_error`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ConnectionChannels
 * @summary ConnectionChannels queries all the channels associated with a connection
end.
 * @request GET:/ibc/core/channel/v1/connections/{connection}/channels
 */
    connectionChannels: (
      connection: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of channels associated with a connection. */
          channels?: {
            /**
             * current state of the channel end
             * State defines if a channel is in one of the following states:
             * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
             *
             *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
             *  - STATE_INIT: A channel has just started the opening handshake.
             *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
             *  - STATE_OPEN: A channel has completed the handshake. Open channels are
             * ready to send and receive packets.
             *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
             * packets.
             *  - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
             *  - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.
             * @default "STATE_UNINITIALIZED_UNSPECIFIED"
             */
            state?:
              | "STATE_UNINITIALIZED_UNSPECIFIED"
              | "STATE_INIT"
              | "STATE_TRYOPEN"
              | "STATE_OPEN"
              | "STATE_CLOSED"
              | "STATE_FLUSHING"
              | "STATE_FLUSHCOMPLETE";
            /**
             * whether the channel is ordered or unordered
             * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
             *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
             * which they were sent.
             *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
             * @default "ORDER_NONE_UNSPECIFIED"
             */
            ordering?:
              | "ORDER_NONE_UNSPECIFIED"
              | "ORDER_UNORDERED"
              | "ORDER_ORDERED";
            /** counterparty channel end */
            counterparty?: {
              /** port on the counterparty chain which owns the other end of the channel. */
              port_id?: string;
              /** channel end on the counterparty chain */
              channel_id?: string;
            };
            /**
             * list of connection identifiers, in order, along which packets sent on
             * this channel will travel
             */
            connection_hops?: string[];
            /** opaque channel version, which is agreed upon during the handshake */
            version?: string;
            /** port identifier */
            port_id?: string;
            /** channel identifier */
            channel_id?: string;
            /**
             * upgrade sequence indicates the latest upgrade attempt performed by this channel
             * the value of 0 indicates the channel has never been upgraded
             * @format uint64
             */
            upgrade_sequence?: string;
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/connections/${connection}/channels`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ChannelParams
     * @summary ChannelParams queries all parameters of the ibc channel submodule.
     * @request GET:/ibc/core/channel/v1/params
     */
    channelParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /**
             * Timeout defines an execution deadline structure for 04-channel handlers.
             * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
             * A valid Timeout contains either one or both of a timestamp and block height (sequence).
             */
            upgrade_timeout?: {
              /**
               * block height after which the packet or upgrade times out
               * Normally the RevisionHeight is incremented at each height while keeping
               * RevisionNumber the same. However some consensus algorithms may choose to
               * reset the height in certain conditions e.g. hard forks, state-machine
               * breaking changes In these cases, the RevisionNumber is incremented so that
               * height continues to be monitonically increasing even as the RevisionHeight
               * gets reset
               */
              height?: {
                /**
                 * the revision that the client is currently on
                 * @format uint64
                 */
                revision_number?: string;
                /**
                 * the height within the given revision
                 * @format uint64
                 */
                revision_height?: string;
              };
              /**
               * block timestamp (in nanoseconds) after which the packet or upgrade times out
               * @format uint64
               */
              timestamp?: string;
            };
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/channel/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ClientConnections
 * @summary ClientConnections queries the connection paths associated with a client
state.
 * @request GET:/ibc/core/connection/v1/client_connections/{client_id}
 */
    clientConnections: (clientId: string, params: RequestParams = {}) =>
      this.request<
        {
          /** slice of all the connection paths associated with a client. */
          connection_paths?: string[];
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was generated
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/connection/v1/client_connections/${clientId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Connections
     * @summary Connections queries all the IBC connections of a chain.
     * @request GET:/ibc/core/connection/v1/connections
     */
    connections: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of stored connections of the chain. */
          connections?: {
            /** connection identifier. */
            id?: string;
            /** client associated with this connection. */
            client_id?: string;
            /**
             * IBC version which can be utilised to determine encodings or protocols for
             * channels or packets utilising this connection
             */
            versions?: {
              /** unique version identifier */
              identifier?: string;
              /** list of features compatible with the specified identifier */
              features?: string[];
            }[];
            /**
             * current state of the connection end.
             * @default "STATE_UNINITIALIZED_UNSPECIFIED"
             */
            state?:
              | "STATE_UNINITIALIZED_UNSPECIFIED"
              | "STATE_INIT"
              | "STATE_TRYOPEN"
              | "STATE_OPEN";
            /** counterparty chain associated with this connection. */
            counterparty?: {
              /**
               * identifies the client on the counterparty chain associated with a given
               * connection.
               */
              client_id?: string;
              /**
               * identifies the connection end on the counterparty chain associated with a
               * given connection.
               */
              connection_id?: string;
              /**
               * MerklePrefix is merkle path prefixed to the key.
               * The constructed key from the Path and the key will be append(Path.KeyPath,
               * append(Path.KeyPrefix, key...))
               * commitment merkle prefix of the counterparty chain.
               */
              prefix?: {
                /** @format byte */
                key_prefix?: string;
              };
            };
            /**
             * delay period associated with this connection.
             * @format uint64
             */
            delay_period?: string;
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
          /**
           * query block height
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/connection/v1/connections`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name Connection
     * @summary Connection queries an IBC connection end.
     * @request GET:/ibc/core/connection/v1/connections/{connection_id}
     */
    connection: (connectionId: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * connection associated with the request identifier
           * ConnectionEnd defines a stateful object on a chain connected to another
           * separate one.
           * NOTE: there must only be 2 defined ConnectionEnds to establish
           * a connection between two chains.
           */
          connection?: {
            /** client associated with this connection. */
            client_id?: string;
            /**
             * IBC version which can be utilised to determine encodings or protocols for
             * channels or packets utilising this connection.
             */
            versions?: {
              /** unique version identifier */
              identifier?: string;
              /** list of features compatible with the specified identifier */
              features?: string[];
            }[];
            /**
             * current state of the connection end.
             * @default "STATE_UNINITIALIZED_UNSPECIFIED"
             */
            state?:
              | "STATE_UNINITIALIZED_UNSPECIFIED"
              | "STATE_INIT"
              | "STATE_TRYOPEN"
              | "STATE_OPEN";
            /** counterparty chain associated with this connection. */
            counterparty?: {
              /**
               * identifies the client on the counterparty chain associated with a given
               * connection.
               */
              client_id?: string;
              /**
               * identifies the connection end on the counterparty chain associated with a
               * given connection.
               */
              connection_id?: string;
              /**
               * MerklePrefix is merkle path prefixed to the key.
               * The constructed key from the Path and the key will be append(Path.KeyPath,
               * append(Path.KeyPrefix, key...))
               * commitment merkle prefix of the counterparty chain.
               */
              prefix?: {
                /** @format byte */
                key_prefix?: string;
              };
            };
            /**
             * delay period that must pass before a consensus state can be used for
             * packet-verification NOTE: delay period logic is only implemented by some
             * clients.
             * @format uint64
             */
            delay_period?: string;
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/connection/v1/connections/${connectionId}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ConnectionClientState
 * @summary ConnectionClientState queries the client state associated with the
connection.
 * @request GET:/ibc/core/connection/v1/connections/{connection_id}/client_state
 */
    connectionClientState: (connectionId: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * client state associated with the channel
           * IdentifiedClientState defines a client state with an additional client
           * identifier field.
           */
          identified_client_state?: {
            /** client identifier */
            client_id?: string;
            /**
             * client state
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            client_state?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/connection/v1/connections/${connectionId}/client_state`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ConnectionConsensusState
 * @summary ConnectionConsensusState queries the consensus state associated with the
connection.
 * @request GET:/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}
 */
    connectionConsensusState: (
      connectionId: string,
      revisionNumber: string,
      revisionHeight: string,
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * consensus state associated with the channel
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          consensus_state?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
          /** client ID associated with the consensus state */
          client_id?: string;
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/connection/v1/connections/${connectionId}/consensus_state/revision/${revisionNumber}/height/${revisionHeight}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ConnectionParams
     * @summary ConnectionParams queries all parameters of the ibc connection submodule.
     * @request GET:/ibc/core/connection/v1/params
     */
    connectionParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /**
             * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
             * largest amount of time that the chain might reasonably take to produce the next block under normal operating
             * conditions. A safe choice is 3-5x the expected time per block.
             * @format uint64
             */
            max_expected_time_per_block?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/connection/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ClientStates
     * @summary ClientStates queries all the IBC light clients of a chain.
     * @request GET:/ibc/core/client/v1/client_states
     */
    clientStates: (
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** list of stored ClientStates of the chain. */
          client_states?: {
            /** client identifier */
            client_id?: string;
            /**
             * client state
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            client_state?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/client_states`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ClientState
     * @summary ClientState queries an IBC light client.
     * @request GET:/ibc/core/client/v1/client_states/{client_id}
     */
    clientState: (clientId: string, params: RequestParams = {}) =>
      this.request<
        {
          /**
           * client state associated with the request identifier
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          client_state?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * height at which the proof was retrieved
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/client_states/${clientId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ClientStatus
     * @summary Status queries the status of an IBC client.
     * @request GET:/ibc/core/client/v1/client_status/{client_id}
     */
    clientStatus: (clientId: string, params: RequestParams = {}) =>
      this.request<
        {
          status?: string;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/client_status/${clientId}`,
        method: "GET",
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ConsensusStates
 * @summary ConsensusStates queries all the consensus state associated with a given
client.
 * @request GET:/ibc/core/client/v1/consensus_states/{client_id}
 */
    consensusStates: (
      clientId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** consensus states associated with the identifier */
          consensus_states?: {
            /**
             * consensus state height
             * Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * @format uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * @format uint64
               */
              revision_height?: string;
            };
            /**
             * consensus state
             * `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *     // or ...
             *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
             *       foo = any.unpack(Foo.getDefaultInstance());
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_state?: {
              /**
               * A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Must be a valid serialized protocol buffer of the above specified type.
               * @format byte
               */
              value?: string;
            };
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/consensus_states/${clientId}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ConsensusStateHeights
     * @summary ConsensusStateHeights queries the height of every consensus states associated with a given client.
     * @request GET:/ibc/core/client/v1/consensus_states/{client_id}/heights
     */
    consensusStateHeights: (
      clientId: string,
      query?: {
        /**
         * key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         * @format byte
         */
        "pagination.key"?: string;
        /**
         * offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         * @format uint64
         */
        "pagination.offset"?: string;
        /**
         * limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         * @format uint64
         */
        "pagination.limit"?: string;
        /**
         * count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** consensus state heights */
          consensus_state_heights?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          }[];
          /**
           * pagination response
           * PageResponse is to be embedded in gRPC response messages where the
           * corresponding request message has used PageRequest.
           *
           *  message SomeResponse {
           *          repeated Bar results = 1;
           *          PageResponse page = 2;
           *  }
           */
          pagination?: {
            /**
             * next_key is the key to be passed to PageRequest.key to
             * query the next page most efficiently. It will be empty if
             * there are no more results.
             * @format byte
             */
            next_key?: string;
            /**
             * total is total number of results available if PageRequest.count_total
             * was set, its value is undefined otherwise
             * @format uint64
             */
            total?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/consensus_states/${clientId}/heights`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
 * No description
 *
 * @tags Query
 * @name ConsensusState
 * @summary ConsensusState queries a consensus state associated with a client state at
a given height.
 * @request GET:/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}
 */
    consensusState: (
      clientId: string,
      revisionNumber: string,
      revisionHeight: string,
      query?: {
        /**
         * latest_height overrrides the height field and queries the latest stored
         * ConsensusState.
         */
        latest_height?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /**
           * consensus state associated with the client identifier at the given height
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          consensus_state?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
          /**
           * merkle proof of existence
           * @format byte
           */
          proof?: string;
          /**
           * Height is a monotonically increasing data type
           * that can be compared against another Height for the purposes of updating and
           * freezing clients
           * Normally the RevisionHeight is incremented at each height while keeping
           * RevisionNumber the same. However some consensus algorithms may choose to
           * reset the height in certain conditions e.g. hard forks, state-machine
           * breaking changes In these cases, the RevisionNumber is incremented so that
           * height continues to be monitonically increasing even as the RevisionHeight
           * gets reset
           */
          proof_height?: {
            /**
             * the revision that the client is currently on
             * @format uint64
             */
            revision_number?: string;
            /**
             * the height within the given revision
             * @format uint64
             */
            revision_height?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/consensus_states/${clientId}/revision/${revisionNumber}/height/${revisionHeight}`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ClientParams
     * @summary ClientParams queries all parameters of the ibc client submodule.
     * @request GET:/ibc/core/client/v1/params
     */
    clientParams: (params: RequestParams = {}) =>
      this.request<
        {
          /** params defines the parameters of the module. */
          params?: {
            /**
             * allowed_clients defines the list of allowed client state types which can be created
             * and interacted with. If a client type is removed from the allowed clients list, usage
             * of this client will be disabled until it is added again to the list.
             */
            allowed_clients?: string[];
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/params`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name UpgradedClientState
     * @summary UpgradedClientState queries an Upgraded IBC light client.
     * @request GET:/ibc/core/client/v1/upgraded_client_states
     */
    upgradedClientState: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * client state associated with the request identifier
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          upgraded_client_state?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/upgraded_client_states`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name ClientUpgradedConsensusState
     * @summary UpgradedConsensusState queries an Upgraded IBC consensus state.
     * @request GET:/ibc/core/client/v1/upgraded_consensus_states
     */
    clientUpgradedConsensusState: (params: RequestParams = {}) =>
      this.request<
        {
          /**
           * Consensus state associated with the request identifier
           * `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *     // or ...
           *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
           *       foo = any.unpack(Foo.getDefaultInstance());
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          upgraded_consensus_state?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          };
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/upgraded_consensus_states`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Query
     * @name VerifyMembership
     * @summary VerifyMembership queries an IBC light client for proof verification of a value at a given key path.
     * @request POST:/ibc/core/client/v1/verify_membership
     */
    verifyMembership: (
      body: {
        /** client unique identifier. */
        client_id?: string;
        /**
         * the proof to be verified by the client.
         * @format byte
         */
        proof?: string;
        /**
         * Height is a monotonically increasing data type
         * that can be compared against another Height for the purposes of updating and
         * freezing clients
         * Normally the RevisionHeight is incremented at each height while keeping
         * RevisionNumber the same. However some consensus algorithms may choose to
         * reset the height in certain conditions e.g. hard forks, state-machine
         * breaking changes In these cases, the RevisionNumber is incremented so that
         * height continues to be monitonically increasing even as the RevisionHeight
         * gets reset
         */
        proof_height?: {
          /**
           * the revision that the client is currently on
           * @format uint64
           */
          revision_number?: string;
          /**
           * the height within the given revision
           * @format uint64
           */
          revision_height?: string;
        };
        /**
         * MerklePath is the path used to verify commitment proofs, which can be an
         * arbitrary structured object (defined by a commitment type).
         * MerklePath is represented from root-to-leaf
         * the commitment key path.
         */
        merkle_path?: {
          key_path?: string[];
        };
        /**
         * the value which is proven.
         * @format byte
         */
        value?: string;
        /**
         * optional time delay
         * @format uint64
         */
        time_delay?: string;
        /**
         * optional block delay
         * @format uint64
         */
        block_delay?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<
        {
          /** boolean indicating success or failure of proof verification. */
          success?: boolean;
        },
        {
          error?: string;
          /** @format int32 */
          code?: number;
          message?: string;
          details?: {
            /**
             * A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Must be a valid serialized protocol buffer of the above specified type.
             * @format byte
             */
            value?: string;
          }[];
        }
      >({
        path: `/ibc/core/client/v1/verify_membership`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),
  };
}
